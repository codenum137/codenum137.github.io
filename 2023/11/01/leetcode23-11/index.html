

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/H.png">
  <link rel="icon" href="/img/H.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="hey137">
  <meta name="keywords" content="">
  
    <meta name="description" content="2023年11月，力扣每日一题笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode23-11">
<meta property="og:url" content="https://codenum137.github.io/codenum137.github.io/2023/11/01/leetcode23-11/index.html">
<meta property="og:site_name" content="Hey~">
<meta property="og:description" content="2023年11月，力扣每日一题笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231101115818837.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231101120031858.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231101121312534.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231101122310790.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231103101229183.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231103105139031.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231109130858875.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231110094954664.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231113105050025.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231113161334209.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231113161434596.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231116120027193.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231117093859444.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231122115444781.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231123103327078.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231125100659250.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231127122859159.png">
<meta property="og:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231130100552783.png">
<meta property="article:published_time" content="2023-11-01T01:51:49.000Z">
<meta property="article:modified_time" content="2023-11-30T02:06:18.319Z">
<meta property="article:author" content="hey137">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://codenum137.github.io/2023/11/01/leetcode23-11/image-20231101115818837.png">
  
  
  
  <title>leetcode23-11 - Hey~</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.1.2/css/all.min.css">
<link rel="stylesheet" href="/css/code-collapse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"codenum137.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"VUZA7v64z7VyTAP8IacQddb3-gzGzoHsz","app_key":"s9nmj2bQKMeENVBm24I948wx","server_url":"https://vuza7v64.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hey~</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="leetcode23-11"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-01 09:51" pubdate>
          2023年11月1日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          44k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          363 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span>次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">leetcode23-11</h1>
            
            
              <div class="markdown-body">
                
                <h1>leetcode23-11</h1>
<h2 id="2127-参加会议的最多员工数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/">2127. 参加会议的最多员工数</a></h2>
<blockquote>
<p>一个公司准备组织一场会议，邀请名单上有 <code>n</code> 位员工。公司准备了一张 <strong>圆形</strong> 的桌子，可以坐下 <strong>任意数目</strong> 的员工。</p>
<p>员工编号为 <code>0</code> 到 <code>n - 1</code> 。每位员工都有一位 <strong>喜欢</strong> 的员工，每位员工 <strong>当且仅当</strong> 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong> 是他自己。</p>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>favorite</code> ，其中 <code>favorite[i]</code> 表示第 <code>i</code> 位员工喜欢的员工。请你返回参加会议的 <strong>最多员工数目</strong> 。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>如果将答案中的员工用单向边（a-&gt;b，表示a喜欢b）相连，那么最后其中一定存在一个环，因为假如没有环，这个单向边组成链条中必有一个点没有指出的边，也就是没有喜欢的人，那么他就不应该参会。且这个环，要么是一个两个点的环，要么是一个首尾相连的环，不然无法与喜欢的人在一起。</p>
<p>这样，我们可以穷举每个人作为起点，依次把前一个人喜欢的人顺时针放入圆桌，同时记录left和right，表示新加入的人左边的人和右边的人，故left始终是起点，而right是前一个新加入的人。而新加入的人new喜欢的人有如下情况：</p>
<ul>
<li>不在圆桌上，则继续加入圆桌</li>
<li>在圆桌上
<ul>
<li>是left，形成首尾相连的环，成功，统计长度。</li>
<li>是right，形成两个点的环，此时查看是否喜欢left的人，有则加入，并继续查看是否有喜欢新加入的人的人，直到没有喜欢新加入的人的人；对new也做同样处理，成功，统计长度。</li>
<li>既不是left，也不是right，无法坐在一起，失败。</li>
</ul>
</li>
</ul>
<p><s>且上述情况成功的人可以标作visited，不把他作为起点。遍历完成后统计最大值即为答案。</s></p>
<p><s>一次逻辑错误，2人环的可以圈地自萌，应记录2人环的数量，然后在最大值再加这个数量即是答案。</s></p>
<p><s>二次逻辑错误，当答案是其中一个二人环时，需特殊判断一下，否则答案会多2，如[1,2]会是4。</s></p>
<p><img src="/2023/11/01/leetcode23-11/image-20231101115818837.png" srcset="/img/loading.gif" lazyload alt="image-20231101115818837"></p>
<p><s>不只2人环可以圈地自萌，除了首尾相连（人数大于2）的成功情况（就二人环带尾巴都可以圈地自萌），并且当答案是首尾相连（人数大于2）时，无法圈地自萌。采用groups累计圈地自萌的数量，res只记录首尾相连(len&gt;2)的最大值，最后res取两者最大值。</s></p>
<p><img src="/2023/11/01/leetcode23-11/image-20231101120031858.png" srcset="/img/loading.gif" lazyload alt="image-20231101120031858"></p>
<p>此时样例无法通过了，需要区分groups是否是含有同一个二人环。修改第一次循环判断，增加对visited的判断，开始怀疑是否可以用visited代替table。。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, ok := table[favorite[new_person]]; !ok &amp;&amp; !(visited[favorite[new_person]]); _, ok = table[favorite[new_person]]<br></code></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">[2,2,1,2]<br></code></pre></td></tr></table></figure>
<p><img src="/2023/11/01/leetcode23-11/image-20231101121312534.png" srcset="/img/loading.gif" lazyload alt="image-20231101121312534"></p>
<p>然而还是出错，现在的问题是对于二人环的两边的尾巴，需要一个搜索来解决，而不是像我这样直接遍历得来的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure>
<p><img src="/2023/11/01/leetcode23-11/image-20231101122310790.png" srcset="/img/loading.gif" lazyload alt="image-20231101122310790"></p>
<p>本人写的笨比代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">int_max</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> a &gt; b &#123;<br>		<span class="hljs-keyword">return</span> a<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> b<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumInvitations</span><span class="hljs-params">(favorite []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	n := <span class="hljs-built_in">len</span>(favorite)<br>	visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>	<span class="hljs-comment">// for i := 0; i &lt; n; i++ &#123;</span><br>	<span class="hljs-comment">// 	visited[i] = false</span><br>	<span class="hljs-comment">// &#125;</span><br>	res, groups := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>		<span class="hljs-keyword">if</span> visited[i] &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		table := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;i: <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;<br>		left, right, new_person, now_len := i, i, i, <span class="hljs-number">1</span><br>		<span class="hljs-keyword">for</span> _, ok := table[favorite[new_person]]; !ok &amp;&amp; !(visited[favorite[new_person]]); _, ok = table[favorite[new_person]] &#123;<br>			right = new_person<br>			new_person = favorite[new_person]<br>			<span class="hljs-comment">// fmt.Printf(&quot;i:%d new_person:%d\n&quot;, i, new_person)</span><br>			table[new_person] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>			now_len++<br>		&#125;<br>		<span class="hljs-keyword">if</span> favorite[new_person] == left || favorite[new_person] == right &#123;<br>			<span class="hljs-keyword">if</span> favorite[new_person] == right &#123;<br>				left_new := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;left, new_person&#125;<br>				<span class="hljs-comment">// fmt.Printf(&quot;left_new:%v\n&quot;, left_new)</span><br>				<span class="hljs-comment">// fmt.Printf(&quot;table:%v\n&quot;, table)</span><br>				<span class="hljs-keyword">for</span> p := <span class="hljs-number">0</span>; p &lt; <span class="hljs-number">2</span>; p++ &#123;<br>					<span class="hljs-keyword">for</span> flag, target := <span class="hljs-literal">false</span>, left_new[p]; ; &#123;<br>						flag = <span class="hljs-literal">false</span><br>						<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>							<span class="hljs-keyword">if</span> _, ok := table[j]; ok || (favorite[j] != target) &#123;<br>								<span class="hljs-keyword">continue</span><br>							&#125; <span class="hljs-keyword">else</span> &#123;<br>								target = j<br>								<span class="hljs-comment">// fmt.Printf(&quot;i:%d new_person:%d\n&quot;, i, target)</span><br>								flag = <span class="hljs-literal">true</span><br>								table[j] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>								now_len++<br>								<span class="hljs-keyword">break</span><br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">if</span> !flag &#123;<br>							<span class="hljs-keyword">break</span><br>						&#125;<br>					&#125;<br>				&#125;<br>				groups += now_len<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">if</span> res &lt; now_len &#123;<br>					res = now_len<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">// fmt.Printf(&quot;res:%d now_len:%d\n&quot;, res, now_len)</span><br>			<span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> table &#123;<br>				visited[key] = <span class="hljs-literal">true</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	res = int_max(res, groups)<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>愚蠢的写法，for循环永远不会执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> flag, target := <span class="hljs-literal">false</span>, left_new[p]; flag; &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>这几天搞不清楚这个for的执行次序出错很多次了，应是先初始化，再做判断，执行一遍代码，然后循环（赋值，判断，执行代码）</p>
</li>
<li>
<p>官解</p>
<p>个人思路其实正确，重点在于如何求解环为2的长度。</p>
<blockquote>
<p>为了求解「基环内向树」上的最长的「双向游走」路径，我们可以使用拓扑排序 + 动态规划的方法。记 f[i]表示到节点 i为止的最长「游走」路径经过的节点个数，那么状态方程即为：</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mi>j</mi><mo>→</mo><mi>i</mi></mrow></munder><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[i] = \max_{j \to i}\{ f[j] \} + 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6138em;vertical-align:-0.8638em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">→</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8638em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p>
<p>即我们考虑节点 i 的上一个节点 j，在图中必须有从 j 到 i的一条有向边，这样我们就可以从 j 转移到 i。如果不存在满足要求的 j（例如「基环内向树」退化成一个大小 =2 的环），那么 f[i]=1。状态转移可以和拓扑排序同时进行。</p>
<p>在拓扑排序完成后，剩余没有被弹出过队列的节点就是环上的节点。我们可以找出每一个环。如果环的大小 ≥3，我们就用其来更新最大的环的大小；如果环的大小 =2，设环上的两个节点为 x和 y，那么该「基环内向树」上最长的「双向游走」的路径长度就是 f[x]+f[y]。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumInvitations</span><span class="hljs-params">(favorite []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(favorite)<br>    <span class="hljs-comment">// 统计入度，便于进行拓扑排序</span><br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> favorite &#123;<br>        indeg[x]++<br>    &#125;<br><br>    used := <span class="hljs-built_in">make</span>([] <span class="hljs-type">bool</span>, n)<br>    f := <span class="hljs-built_in">make</span>([] <span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        f[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    q := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        u := q[<span class="hljs-number">0</span>]<br>        used[u] = <span class="hljs-literal">true</span><br>        q = q[<span class="hljs-number">1</span>:]<br>        v := favorite[u]<br>        <span class="hljs-comment">// 状态转移</span><br>        f[v] = max(f[v], f[u] + <span class="hljs-number">1</span>);<br>        indeg[v]--<br>        <span class="hljs-keyword">if</span> indeg[v] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, v)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ring 表示最大的环的大小</span><br>    <span class="hljs-comment">// total 表示所有环大小为 2 的「基环内向树」上的最长的「双向游走」路径之和</span><br>    ring, total := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[i] &#123;<br>            j := favorite[i];<br>            <span class="hljs-comment">// favorite[favorite[i]] = i 说明环的大小为 2</span><br>            <span class="hljs-keyword">if</span> favorite[j] == i &#123;<br>                total += f[i] + f[j]<br>                used[i], used[j] = <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则环的大小至少为 3，我们需要找出环</span><br>                u, cnt := i, <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span> &#123;<br>                    cnt++<br>                    u = favorite[u]<br>                    used[u] = <span class="hljs-literal">true</span><br>                    <span class="hljs-keyword">if</span> u == i &#123;<br>                        <span class="hljs-keyword">break</span><br>                    &#125;<br>                &#125;<br>                ring = max(ring, cnt)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(ring, total)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2103-环和杆"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rings-and-rods/">2103. 环和杆</a></h2>
<blockquote>
<p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p>
<p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p>
<ul>
<li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>'R'</code>、<code>'G'</code>、<code>'B'</code>）。</li>
<li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>'0'</code> 到 <code>'9'</code>）。</li>
</ul>
<p>例如，<code>&quot;R3G2B1&quot;</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p>
<p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>模拟很简单，重点在于如何快速的判断三种颜色都存在。我的思路是，另每一个颜色代表一个质数，如2,3,5，每个杆都有一个初始值，为1。遍历颜色环，在i号杆就零i号杆的值乘以对于颜色的质数。最后遍历杆的值，能整除15的就是三种颜色都有的。</p>
<p>wait，有个新思路，上述涉及乘法可能会有溢出的问题，可以采用位运算。一种运算过一次就不一样的位运算，就是或。三种颜色对应不同位上的1，如001,010,100；每个杆初始值为0，按位或，最后为111的就是三种颜色都有的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPoints</span><span class="hljs-params">(rings <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	rgb := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;R&quot;</span>: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;G&quot;</span>: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>&#125;<br>	pole, res := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-number">0</span><br><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(rings); i += <span class="hljs-number">2</span> &#123;<br>		pn, _ := strconv.Atoi(<span class="hljs-type">string</span>(rings[i+<span class="hljs-number">1</span>])) <span class="hljs-comment">//Atoi返回转化后的数字和错误</span><br>		pole[pn] |= rgb[<span class="hljs-type">string</span>(rings[i])]<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>		<span class="hljs-comment">// fmt.Println(pole[i])</span><br>		<span class="hljs-keyword">if</span> pole[i] == <span class="hljs-number">7</span> &#123;<br>			res++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<p>学习一位数字的字符串转化整形</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">pole_index := rings[i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="117-填充每个节点的下一个右侧节点指针-II"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h2>
<blockquote>
<p>给定一个二叉树：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p>
</blockquote>
<ul>
<li>
<p><img src="/2023/11/01/leetcode23-11/image-20231103101229183.png" srcset="/img/loading.gif" lazyload alt="image-20231103101229183"></p>
<p>看示例本来以为可以偷鸡，但看代码才发现参数是Node *，返回值也是Node*。</p>
<p>用层序遍历可以解决，一开始在队列中加入1和NULL，然后对于节点的操作就是令该节点指向队列中的下一个节点，然后往队列中加入左右孩子（按顺序加入），对NULL的操作就是往队列中加入NULL。循环结束条件就是队列长度为1且是NULL。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>	<span class="hljs-keyword">var</span> now_node *Node<br>	q := <span class="hljs-built_in">make</span>([]*Node, <span class="hljs-number">0</span>)<br>	<span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>		q = <span class="hljs-built_in">append</span>(q, root)<br>	&#125;<br>	q = <span class="hljs-built_in">append</span>(q, <span class="hljs-literal">nil</span>)<br>	<span class="hljs-keyword">for</span> !(<span class="hljs-built_in">len</span>(q) == <span class="hljs-number">1</span> &amp;&amp; q[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span>) &#123;<br>		now_node, q = q[<span class="hljs-number">0</span>], q[<span class="hljs-number">1</span>:]<br>		<span class="hljs-keyword">if</span> now_node != <span class="hljs-literal">nil</span> &#123;<br>			now_node.Next = q[<span class="hljs-number">0</span>]<br>			<span class="hljs-keyword">if</span> now_node.Left != <span class="hljs-literal">nil</span> &#123;<br>				q = <span class="hljs-built_in">append</span>(q, now_node.Left)<br>			&#125;<br>			<span class="hljs-keyword">if</span> now_node.Right != <span class="hljs-literal">nil</span> &#123;<br>				q = <span class="hljs-built_in">append</span>(q, now_node.Right)<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			q = <span class="hljs-built_in">append</span>(q, <span class="hljs-literal">nil</span>)<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
<p>题目的进阶要求是使用常数级额外空间，允许使用递归。额，这怎么递归。</p>
</li>
<li>
<p>官解</p>
<p>也没有递归呀</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231103105139031.png" srcset="/img/loading.gif" lazyload alt="image-20231103105139031"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    start := root<br>    <span class="hljs-keyword">for</span> start != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">var</span> nextStart, last *Node<br>        handle := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cur *Node)</span></span> &#123;<br>            <span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> nextStart == <span class="hljs-literal">nil</span> &#123;<br>                nextStart = cur<br>            &#125;<br>            <span class="hljs-keyword">if</span> last != <span class="hljs-literal">nil</span> &#123;<br>                last.Next = cur<br>            &#125;<br>            last = cur<br>        &#125;<br>        <span class="hljs-keyword">for</span> p := start; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>            handle(p.Left)<br>            handle(p.Right)<br>        &#125;<br>        start = nextStart<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="421-数组中两个数的最大异或值△"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值△</a></h2>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
</blockquote>
<ul>
<li>
<p>个人思路：</p>
<p>暴力不行，会TLE</p>
</li>
<li>
<p>官解</p>
<blockquote>
<p>异或运算的性质</p>
<p>解决这个问题，我们首先需要利用异或运算的一个性质：</p>
<p>如果 a ^ b = c 成立，那么a ^ c = b 与 b ^ c = a 均成立。</p>
<p>即 如果有三个数，满足其中两个数的异或值等于另一个值，那么这三个数的顺序可以任意调换。</p>
<p>（说明：利用这条性质，可以不使用第 3 个变量而交换两个变量的值。）</p>
<p>那么如何理解这个性质呢？因为异或运算其实就是 二进制下不进位的加法，你不妨自己举几个例子，在草稿纸上验证一下。<br>
如何应用到本题？</p>
<p>这道题找最大值的思路是这样的：因为两两异或可以得到一个值，在所有的两两异或得到的值中，一定有一个最大值，我们推测这个最大值应该是什么样的？即根据“最大值”的存在性解题（一定存在）。在这里要强调一下：</p>
<p>我们只用关心这个最大的异或值需要满足什么性质，进而推出这个最大值是什么，而不必关心这个异或值是由哪两个数得来的。</p>
<p>（上面这句话很重要，如果读者一开始看不明白下面的思考，不妨多看几遍我上面写的这句话。）</p>
<p>于是有如下思考：</p>
<p>1、二进制下，我们希望一个数尽可能大，即希望越高位上越能够出现“1”，这样这个数就是所求的最大数，这是贪心算法的思想。</p>
<p>2、于是，我们可以从最高位开始，到最低位，首先假设高位是 “1”，把这 n 个数全部遍历一遍，看看这一位是不是真的可以是“1”，否则这一位就得是“0”，判断的依据是上面“异或运算的性质”，即下面的第 3 点；</p>
<p>3、如果 a ^ b = max 成立 ，max 表示当前得到的“最大值”，那么一定有 max ^ b = a 成立。我们可以先假设当前数位上的值为 “1”，再把当前得到的数与这个 n 个数的 前缀（因为是从高位到低位看，所以称为“前缀”）进行异或运算，放在一个哈希表中，再依次把所有 前缀 与这个假设的“最大值”进行异或以后得到的结果放到哈希表里查询一下，如果查得到，就说明这个数位上可以是“1”，否则就只能是 0（看起来很晕，可以看代码理解）。</p>
<p>一种极端的情况是，这 n 个数在某一个数位上全部是 0 ，那么任意两个数异或以后都只能是 0，那么假设当前数位是 1 这件事情就不成立。</p>
<p>4、如何得到前缀，可以用掩码（mask），掩码可以进行如下构造，将掩码与原数依次进行 “与” 运算，就能得到前缀。</p>
<p>作者：liweiwei1419<br>
链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/</a></p>
</blockquote>
<p>从最大值的存在性来解题，从最高位开始，先贪心假设该位可以为1，然后<strong>分别</strong>与数组异或，若异或的值能在哈希表（这个哈希表就是数组每个数的前缀）中找到，就说明该位可以是1（这里体现了题目中的两个数的异或最大值，若a^b=c，则c^b=a）。而之后是带着前面已经锁定的位继续遍历的，而不是单独的每一个位遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (x <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">const</span> highBit = <span class="hljs-number">30</span> <span class="hljs-comment">// 最高位的二进制位编号为 30</span><br>    <span class="hljs-keyword">for</span> k := highBit; k &gt;= <span class="hljs-number">0</span>; k-- &#123;<br>        <span class="hljs-comment">// 将所有的 pre^k(a_j) 放入哈希表中</span><br>        seen := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>            <span class="hljs-comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br>            <span class="hljs-comment">// 只需将其右移 k 位</span><br>            seen[num&gt;&gt;k] = <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br>        <span class="hljs-comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br>        xNext := x*<span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>        found := <span class="hljs-literal">false</span><br><br>        <span class="hljs-comment">// 枚举 i</span><br>        <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>            <span class="hljs-keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;<br>                found = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> found &#123;<br>            x = xNext<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br>            <span class="hljs-comment">// 即为 x = x*2</span><br>            x = xNext - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="187-重复的DNA序列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h2>
<blockquote>
<p><strong>DNA序列</strong> 由一系列核苷酸组成，缩写为 <code>'A'</code>, <code>'C'</code>, <code>'G'</code> 和 <code>'T'</code>.。</p>
<ul>
<li>例如，<code>&quot;ACGAATTCCG&quot;</code> 是一个 <strong>DNA序列</strong> 。</li>
</ul>
<p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p>
<p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的 <strong>长度为 <code>10</code></strong> 的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p><s>看ow比赛摸了，韩国队都打赢了，沙特队输了，意难平呀。</s></p>
</li>
<li>
<p>官解</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> L = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans []<span class="hljs-type">string</span>) &#123;<br>    cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">len</span>(s)-L; i++ &#123;<br>        sub := s[i : i+L]<br>        cnt[sub]++<br>        <span class="hljs-keyword">if</span> cnt[sub] == <span class="hljs-number">2</span> &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, sub)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="318-最大单词长度乘积"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2>
<blockquote>
<p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>重点在于如何检测两个单词不含有公共字母，用set去判断会超时。如果要求<code>length(words[i]) + length(words[j])</code>最大，可以采用贪心的思想，先排序，但乘法不一样。换用数组去判断，直接过了，看来不是用库的数据结构就一定快的呀。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPara</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 会超时</span><br>	<span class="hljs-comment">// seta := map[byte]struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// setb := map[byte]struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// set := map[byte]struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// for i := 0; i &lt; len(a); i++ &#123;</span><br>	<span class="hljs-comment">// 	seta[a[i]] = struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// 	set[a[i]] = struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// &#125;</span><br>	<span class="hljs-comment">// for i := 0; i &lt; len(b); i++ &#123;</span><br>	<span class="hljs-comment">// 	setb[b[i]] = struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// 	set[b[i]] = struct&#123;&#125;&#123;&#125;</span><br>	<span class="hljs-comment">// &#125;</span><br>	<span class="hljs-comment">// if len(set) == len(seta)+len(setb) &#123;</span><br>	<span class="hljs-comment">// 	return true</span><br>	<span class="hljs-comment">// &#125; else &#123;</span><br>	<span class="hljs-comment">// 	return false</span><br>	<span class="hljs-comment">// &#125;</span><br>	set := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>	setb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br>		<span class="hljs-keyword">if</span> set[a[i]-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span> &#123;<br>			set[a[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(b); i++ &#123;<br>		<span class="hljs-keyword">if</span> setb[b[i]-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span> &#123;<br>			setb[b[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>			set[b[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br>		<span class="hljs-keyword">if</span> set[i] &gt; <span class="hljs-number">1</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	res := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words); i++ &#123;<br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(words); j++ &#123;<br>			<span class="hljs-keyword">if</span> isPara(words[i], words[j]) &#123;<br>				<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words[i])*<span class="hljs-built_in">len</span>(words[j]) &gt; res &#123;<br>					res = <span class="hljs-built_in">len</span>(words[i]) * <span class="hljs-built_in">len</span>(words[j])<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<p>位运算，我也想到了，但只记得那个异或了。。将字符串或运算后，判断两个字符串是否含有公共字符直接按位与即可，若不等于0则说明有公共字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    masks := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(words))<br>    <span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> words &#123;<br>        <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>            masks[i] |= <span class="hljs-number">1</span> &lt;&lt; (ch - <span class="hljs-string">&#x27;a&#x27;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> masks &#123;<br>        <span class="hljs-keyword">for</span> j, y := <span class="hljs-keyword">range</span> masks[:i] &#123;<br>            <span class="hljs-keyword">if</span> x&amp;y == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(words[i])*<span class="hljs-built_in">len</span>(words[j]) &gt; ans &#123;<br>                ans = <span class="hljs-built_in">len</span>(words[i]) * <span class="hljs-built_in">len</span>(words[j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>进一步优化，维护一个数组用来记录对应掩码的最长单词长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    masks := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words &#123;<br>        mask := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>            mask |= <span class="hljs-number">1</span> &lt;&lt; (ch - <span class="hljs-string">&#x27;a&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; masks[mask] &#123;<br>            masks[mask] = <span class="hljs-built_in">len</span>(word)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> x, lenX := <span class="hljs-keyword">range</span> masks &#123;<br>        <span class="hljs-keyword">for</span> y, lenY := <span class="hljs-keyword">range</span> masks &#123;<br>            <span class="hljs-keyword">if</span> x&amp;y == <span class="hljs-number">0</span> &amp;&amp; lenX*lenY &gt; ans &#123;<br>                ans = lenX * lenY<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2586-统计范围内的元音字符串数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/">2586. 统计范围内的元音字符串数</a></h2>
<blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p>
<p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code> 。</p>
<p>返回 <code>words[i]</code> 是元音字符串的数目，其中 <code>i</code> 在闭区间 <code>[left, right]</code> 内。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>EZ</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isVowel</span><span class="hljs-params">(letter <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>	vowels := [<span class="hljs-number">5</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>		<span class="hljs-keyword">if</span> letter == vowels[i] &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">vowelStrings</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	res := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := left; i &lt;= right; i++ &#123;<br>		word_len := <span class="hljs-built_in">len</span>(words[i])<br>		<span class="hljs-keyword">if</span> isVowel(words[i][<span class="hljs-number">0</span>]) &amp;&amp; isVowel(words[i][word_len<span class="hljs-number">-1</span>]) &#123;<br>			res++<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<p>使用字典代替if判断，将会更快</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">vowelStrings</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    vowels := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;<span class="hljs-string">&#x27;a&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;e&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;i&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;o&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;u&#x27;</span> : &#123;&#125;&#125;<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span>(words[left : right + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">if</span> _, ok1 := vowels[word[<span class="hljs-number">0</span>]]; ok1 &#123;<br>            <span class="hljs-keyword">if</span> _, ok2 := vowels[word[<span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span>]]; ok2 &#123;<br>                ans++<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2609-最长平衡子字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/">2609. 最长平衡子字符串</a></h2>
<blockquote>
<p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。</p>
<p>如果子字符串中 <strong>所有的</strong> <code>0</code> <strong>都在</strong> <code>1</code> <strong>之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。</p>
<p>返回 <code>s</code> 中最长的平衡子字符串长度。</p>
<p>子字符串是字符串中的一个连续字符序列。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>一次遍历应该就行，遇0累加cnt，遇1累减cnt，等于0则统计一次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheLongestBalancedSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	res := <span class="hljs-number">0</span><br>	cnt0, cnt1 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>	i := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>		cnt0, cnt1 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>			i++<br>		&#125;<br>		<span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>			cnt0++<br>			i++<br>		&#125;<br>		<span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>			cnt1++<br>			i++<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> cnt0 &gt;= cnt1 &amp;&amp; res &lt; cnt1*<span class="hljs-number">2</span> &#123;<br>			res = cnt1 * <span class="hljs-number">2</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> cnt0 &lt;= cnt1 &amp;&amp; res &lt; cnt0*<span class="hljs-number">2</span> &#123;<br>			res = cnt0 * <span class="hljs-number">2</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheLongestBalancedSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>            count[<span class="hljs-number">1</span>]++<br>            res = max(res, <span class="hljs-number">2</span> * min(count[<span class="hljs-number">0</span>], count[<span class="hljs-number">1</span>]))<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>            count[<span class="hljs-number">0</span>], count[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count[<span class="hljs-number">0</span>]++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res   <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2258-逃离火灾"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/escape-the-spreading-fire/">2258. 逃离火灾</a></h2>
<blockquote>
<p>给你一个下标从 <strong>0</strong> 开始大小为 <code>m x n</code> 的二维整数数组 <code>grid</code> ，它表示一个网格图。每个格子为下面 3 个值之一：</p>
<ul>
<li><code>0</code> 表示草地。</li>
<li><code>1</code> 表示着火的格子。</li>
<li><code>2</code> 表示一座墙，你跟火都不能通过这个格子。</li>
</ul>
<p>一开始你在最左上角的格子 <code>(0, 0)</code> ，你想要到达最右下角的安全屋格子 <code>(m - 1, n - 1)</code> 。每一分钟，你可以移动到 <strong>相邻</strong> 的草地格子。每次你移动 <strong>之后</strong> ，着火的格子会扩散到所有不是墙的 <strong>相邻</strong> 格子。</p>
<p>请你返回你在初始位置可以停留的 <strong>最多</strong> 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code> 。如果不管你在初始位置停留多久，你 <strong>总是</strong> 能到达安全屋，请你返回 <code>109</code> 。</p>
<p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p>
<p>如果两个格子有共同边，那么它们为 <strong>相邻</strong> 格子。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>考虑火的到达安全屋的最短时间和人到达安全屋的最短时间</p>
<ul>
<li>如果火的最短时间&lt;人的最短时间，那么返回<code>-1</code></li>
<li>如果火的最短时间=人的最短时间，这时与火的位置有关。可以这样思考，考虑两者到达安全屋的前一分钟，火能否覆盖到人的位置。具体到本题，安全屋必然在右下角，故前一分钟要么在安全屋的上面，要么在安全屋的左面
<ul>
<li>若能覆盖，也是<code>-1</code>，因为人无法换路，换路火必然先于人到达安全屋。</li>
<li>若不能覆盖，人和火同时达到安全屋，按题意视为安全到达安全屋，返回<code>0</code>。</li>
</ul>
</li>
<li>如果火的最短时间&gt;人的最短时间，人可等待多出的时间，转化为两者时间相等的情况考虑。</li>
</ul>
<p>代码方面，两者的最短时间使用从安全屋开始的广度优先搜索，如何考虑相等时前一分钟的覆盖情况呢，我认为需要从安全屋的上面和左面来广搜。故不如直接从这两个点开始搜。</p>
<p>感觉思路有点奇怪，不是很想写代码（懒了。</p>
</li>
</ul>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>二分查找</p>
<p>我认为重点有二：</p>
<ol>
<li>
<p>如何意识到二分？线性即可二分</p>
<p>假设已知最大可以停留的时间为 stayTime，则当停留的时间大于 stayTime时则一定无法到达终点，当停留时间小于 stayTime时，则一定可以到达终点，二者成线性关系，因此可以利用二分查找找到最大停留时间。</p>
</li>
<li>
<p>由于火到达每个格子的时间是固定的，我们可以提前求出火到达每个格子的时间 fireTime[i][j]</p>
</li>
</ol>
<p>所以代码需要先广搜一遍出fireTime，然后是检查当前stayTime是否能到达安全屋的check函数，其仍是广搜，因为fireTime已经求出，到达一个新的点只需满足fireTime&gt;stayTime+到达该点需要的时间（在广搜中累加）即可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> dirs = [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">var</span> INF <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumMinutes</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    fireTime := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        fireTime[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            fireTime[i][j] = INF<br>        &#125;<br>    &#125;<br><br>    bfs := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        q := [][]<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &#123;<br>                    q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;i, j&#125;)<br>                    fireTime[i][j] = <span class="hljs-number">0</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        time := <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>            tmp := q<br>            q = [][]<span class="hljs-type">int</span>&#123;&#125;<br>            <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> tmp &#123;<br>                cx, cy := p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>                    nx, ny := cx + d[<span class="hljs-number">0</span>], cy + d[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &#123;<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">2</span> || fireTime[nx][ny] != INF &#123;<br>                                <span class="hljs-keyword">continue</span><br>                        &#125;<br>                        q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;nx, ny&#125;)<br>                        fireTime[nx][ny] = time <br>                    &#125;<br>                &#125;<br>            &#125;<br>            time += <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 通过 bfs 求出每个格子着火的时间 */</span><br>    bfs()<br>    <span class="hljs-comment">/* 二分查找找到最大停留时间 */</span><br>    check := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(stayTime <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, m)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>            visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        &#125;<br>        q := [][]<span class="hljs-type">int</span>&#123;&#125;<br>        q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, stayTime&#125;)<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>            tmp := q<br>            q = [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>            <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> tmp &#123;<br>                cx, cy, time := p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>], p[<span class="hljs-number">2</span>]<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>                    nx, ny := cx + d[<span class="hljs-number">0</span>], cy + d[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &#123;<br>                        <span class="hljs-keyword">if</span> visit[nx][ny] || grid[nx][ny] == <span class="hljs-number">2</span> &#123;<br>                            <span class="hljs-keyword">continue</span><br>                        &#125;<br>                        <span class="hljs-comment">/* 到达安全屋 */</span><br>                        <span class="hljs-keyword">if</span> nx == m - <span class="hljs-number">1</span> &amp;&amp; ny == n - <span class="hljs-number">1</span> &#123;<br>                            <span class="hljs-keyword">return</span> fireTime[nx][ny] &gt;= time + <span class="hljs-number">1</span><br>                        &#125;<br>                        <span class="hljs-comment">/* 火未到达当前位置 */</span><br>                        <span class="hljs-keyword">if</span> fireTime[nx][ny] &gt; time + <span class="hljs-number">1</span> &#123;<br>                            q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;nx, ny, time + <span class="hljs-number">1</span>&#125;)<br>                            visit[nx][ny] = <span class="hljs-literal">true</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>   <br>    &#125;<br><br>    ans := <span class="hljs-number">-1</span><br>    low, high := <span class="hljs-number">0</span>, m * n<br>    <span class="hljs-keyword">for</span> low &lt;= high &#123;<br>        mid := low + (high - low) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> check(mid) &#123;<br>            ans = mid<br>            low = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            high = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ans &gt;= m * n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>分类讨论</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231109130858875.png" srcset="/img/loading.gif" lazyload alt="image-20231109130858875"></p>
<p>我的思路是对的，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/escape-the-spreading-fire/solutions/1460794/er-fen-bfspythonjavacgo-by-endlesscheng-ypp1/">2258. 逃离火灾 - 力扣（LeetCode）</a>，广搜两次，安全屋的上面格子和左面格子即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;<br><span class="hljs-keyword">var</span> dirs = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumMinutes</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment">// 返回三个数，分别表示到达安全屋/安全屋左边/安全屋上边的最短时间</span><br>    bfs := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(q []pair)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>        time := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> time &#123;<br>            time[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> time[i] &#123;<br>                time[i][j] = <span class="hljs-number">-1</span> <span class="hljs-comment">// -1 表示未访问</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> q &#123;<br>            time[p.x][p.y] = <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> t := <span class="hljs-number">1</span>; <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>; t++ &#123; <span class="hljs-comment">// 每次循环向外扩展一圈</span><br>            tmp := q<br>            q = <span class="hljs-literal">nil</span><br>            <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> tmp &#123;<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123; <span class="hljs-comment">// 枚举上下左右四个方向</span><br>                    <span class="hljs-keyword">if</span> x, y := p.x+d.x, p.y+d.y; <span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt; m &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="hljs-number">0</span> &amp;&amp; time[x][y] &lt; <span class="hljs-number">0</span> &#123;<br>                        time[x][y] = t<br>                        q = <span class="hljs-built_in">append</span>(q, pair&#123;x, y&#125;)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> time[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>], time[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-2</span>], time[m<span class="hljs-number">-2</span>][n<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    manToHouseTime, m1, m2 := bfs([]pair&#123;&#123;&#125;&#125;)<br>    <span class="hljs-keyword">if</span> manToHouseTime &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 人无法到安全屋</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    firePos := []pair&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, x := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span> &#123;<br>                firePos = <span class="hljs-built_in">append</span>(firePos, pair&#123;i, j&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br>    fireToHouseTime, f1, f2 := bfs(firePos) <span class="hljs-comment">// 多个着火点同时跑 BFS</span><br>    <span class="hljs-keyword">if</span> fireToHouseTime &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 火无法到安全屋</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>_000_000_000<br>    &#125;<br><br>    d := fireToHouseTime - manToHouseTime<br>    <span class="hljs-keyword">if</span> d &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 火比人先到安全屋</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> m1 != <span class="hljs-number">-1</span> &amp;&amp; m1+d &lt; f1 || <span class="hljs-comment">// 安全屋左边相邻格子，人比火先到</span><br>       m2 != <span class="hljs-number">-1</span> &amp;&amp; m2+d &lt; f2 &#123;  <span class="hljs-comment">// 安全屋上边相邻格子，人比火先到</span><br>        <span class="hljs-keyword">return</span> d <span class="hljs-comment">// 图中第一种情况</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> d - <span class="hljs-number">1</span> <span class="hljs-comment">// 图中第二种情况</span><br>&#125;<br><br>作者：灵茶山艾府<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/escape-the-spreading-fire/solutions/1460794/er-fen-bfspythonjavacgo-by-endlesscheng-ypp1/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="2300-咒语和药水的成功对数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数</a></h2>
<blockquote>
<p>给你两个正整数数组 <code>spells</code> 和 <code>potions</code> ，长度分别为 <code>n</code> 和 <code>m</code> ，其中 <code>spells[i]</code> 表示第 <code>i</code> 个咒语的能量强度，<code>potions[j]</code> 表示第 <code>j</code> 瓶药水的能量强度。</p>
<p>同时给你一个整数 <code>success</code> 。一个咒语和药水的能量强度 <strong>相乘</strong> 如果 <strong>大于等于</strong> <code>success</code> ，那么它们视为一对 <strong>成功</strong> 的组合。</p>
<p>请你返回一个长度为 <code>n</code> 的整数数组 <code>pairs</code>，其中 <code>pairs[i]</code> 是能跟第 <code>i</code> 个咒语成功组合的 <strong>药水</strong> 数目。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>将药水排序，二分去查找即可。换c++写一阵子，为了<s>汉堡</s>，程序设计大赛。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">successfulPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;spells, vector&lt;<span class="hljs-type">int</span>&gt; &amp;potions, <span class="hljs-type">long</span> <span class="hljs-type">long</span> success)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(spells.size())</span></span>;<br>        <span class="hljs-built_in">sort</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; spells.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; endl;</span><br>            <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = potions.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span><br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> cross = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)spells[i] * potions[mid];<br>                <span class="hljs-keyword">if</span> (cross &gt;= success)<br>                &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            res[i] = potions.<span class="hljs-built_in">size</span>() - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>二分查找</p>
<p>先排序，且利用upper_bound直接查找目标值。upper_bound是二分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">successfulPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; spells, vector&lt;<span class="hljs-type">int</span>&gt;&amp; potions, <span class="hljs-type">long</span> <span class="hljs-type">long</span> success)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : spells) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = (success + i - <span class="hljs-number">1</span>) / i - <span class="hljs-number">1</span>;<br>            res.<span class="hljs-built_in">push_back</span>(potions.<span class="hljs-built_in">size</span>() - (<span class="hljs-built_in">upper_bound</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>(), t) - potions.<span class="hljs-built_in">begin</span>()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>为什么使用<code>auto&amp;</code>？</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231110094954664.png" srcset="/img/loading.gif" lazyload alt="image-20231110094954664"></p>
</li>
<li>
<p>双指针</p>
<p>spells升序，potions降序，i，j为两者排序后的初始下标，随着i的增加，j只增不减，为O(n)。为了记录原始下标，对<strong>spells下标</strong>按照其位置上的能量强度进行升序排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">successfulPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; spells, vector&lt;<span class="hljs-type">int</span>&gt;&amp; potions, <span class="hljs-type">long</span> <span class="hljs-type">long</span> success)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(spells.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(spells.size())</span></span>;<br>        <span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(), idx.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(idx.<span class="hljs-built_in">begin</span>(), idx.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>            <span class="hljs-keyword">return</span> spells[a] &lt; spells[b];<br>        &#125;);<br>        <span class="hljs-built_in">sort</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>            <span class="hljs-keyword">return</span> a &gt; b;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; spells.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> p = idx[i];<br>            <span class="hljs-type">int</span> v = spells[p];<br>            <span class="hljs-keyword">while</span> (j &lt; potions.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) potions[j] * v &gt;= success) &#123;<br>                ++j;<br>            &#125;<br>            res[p] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="765-情侣牵手"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/couples-holding-hands/">765. 情侣牵手</a></h2>
<blockquote>
<p><code>n</code> 对情侣坐在连续排列的 <code>2n</code> 个座位上，想要牵到对方的手。</p>
<p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i </code>个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2n-2, 2n-1)</code>。</p>
<p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起</em>。 <em>每次</em>交换可选择任意两人，让他们站起来交换座位。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>一开始将所有已经牵手的情侣去掉，剩下的都是未牵手的。然后明确一点，一个最小的情侣圈（情侣圈指这个圈子的所有情侣里是能通过交换座位来牵手的，不会出现单身狗。最小的是指这个圈无法通过划分变成两个更小的情侣圈）的人数是2n，那么必定需要交换n-1次来使情侣两两牵手。</p>
<p>如何寻找最小的情侣圈？</p>
<p>没想出来</p>
</li>
</ul>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>并查集</p>
<p>自己都说情侣圈了，其实就是找环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> getf(vector&lt;<span class="hljs-type">int</span>&gt;&amp; f, <span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">if</span> (f[x] == x) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-type">int</span> newf = getf(f, f[x]);<br>        f[x] = newf;<br>        <span class="hljs-keyword">return</span> newf;<br>    &#125;<br><br>    void add(vector&lt;<span class="hljs-type">int</span>&gt;&amp; f, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>        <span class="hljs-type">int</span> fx = getf(f, x);<br>        <span class="hljs-type">int</span> fy = getf(f, y);<br>        f[fx] = fy;<br>    &#125;<br><br>    <span class="hljs-type">int</span> minSwapsCouples(vector&lt;<span class="hljs-type">int</span>&gt;&amp; row) &#123;<br>        <span class="hljs-type">int</span> n = row.size();<br>        <span class="hljs-type">int</span> tot = n / <span class="hljs-number">2</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; f(tot, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tot; i++) &#123;<br>            f[i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> l = row[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> r = row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>;<br>            add(f, l, r);<br>        &#125;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tot; i++) &#123;<br>            <span class="hljs-type">int</span> fx = getf(f, i);<br>            m[fx]++;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> auto&amp; [f, sz]: m) &#123;<br>            ret += sz - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="715-Range-模块"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-module/">715. Range 模块</a></h2>
<blockquote>
<p>Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 <strong>半开区间</strong> 的范围并查询它们。</p>
<p><strong>半开区间</strong> <code>[left, right)</code> 表示所有 <code>left &lt;= x &lt; right</code> 的实数 <code>x</code> 。</p>
<p>实现 <code>RangeModule</code> 类:</p>
<ul>
<li><code>RangeModule()</code> 初始化数据结构的对象。</li>
<li><code>void addRange(int left, int right)</code> 添加 <strong>半开区间</strong> <code>[left, right)</code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 <code>[left, right)</code> 中尚未跟踪的任何数字到该区间中。</li>
<li><code>boolean queryRange(int left, int right)</code> 只有在当前正在跟踪区间 <code>[left, right)</code> 中的每一个实数时，才返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>void removeRange(int left, int right)</code> 停止跟踪 <strong>半开区间</strong> <code>[left, right)</code> 中当前正在跟踪的每个实数。</li>
</ul>
</blockquote>
<ul>
<li>
<p>官解</p>
<p><a target="_blank" rel="noopener" href="https://lfool.github.io/LFool-Notes/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3.html">线段树详解 (lfool.github.io)</a></p>
<p><strong>线段树解决的是「区间和」的问题，且该「区间」会被修改</strong></p>
</li>
</ul>
<h2 id="307-区域和检索-数组可修改"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></h2>
<blockquote>
<p>给你一个数组 <code>nums</code> ，请你完成两类查询。</p>
<ol>
<li>其中一类查询要求 <strong>更新</strong> 数组 <code>nums</code> 下标对应的值</li>
<li>另一类查询要求返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的nums元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li>
</ol>
<p>实现 <code>NumArray</code> 类：</p>
<ul>
<li><code>NumArray(int[] nums)</code> 用整数数组 <code>nums</code> 初始化对象</li>
<li><code>void update(int index, int val)</code> 将 <code>nums[index]</code> 的值 <strong>更新</strong> 为 <code>val</code></li>
<li><code>int sumRange(int left, int right)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的nums元素的 <strong>和</strong> （即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li>
</ul>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>前缀和会超时，原因应该是更新操作费时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; array;<br>    vector&lt;<span class="hljs-type">int</span>&gt; pre_sum;<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        array.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        pre_sum.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            array.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            pre_sum.<span class="hljs-built_in">push_back</span>(pre_sum[i - <span class="hljs-number">1</span>] + nums[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> diff = val - array[index];<br>        array[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; array.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pre_sum[i] += diff;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> left ? pre_sum[right] - pre_sum[left - <span class="hljs-number">1</span>] : pre_sum[right];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>分块和</p>
<p>重点在于对分块粒度的分析</p>
<blockquote>
<p><img src="/2023/11/01/leetcode23-11/image-20231113105050025.png" srcset="/img/loading.gif" lazyload alt="image-20231113105050025"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; sum; <span class="hljs-comment">// sum[i] 表示第 i 个块的元素和</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// 块的大小</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) : <span class="hljs-built_in">nums</span>(nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        size = <span class="hljs-built_in">sqrt</span>(n);<br>        sum.<span class="hljs-built_in">resize</span>((n + size - <span class="hljs-number">1</span>) / size); <span class="hljs-comment">// n/size 向上取整</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum[i / size] += nums[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        sum[index / size] += val - nums[index];<br>        nums[index] = val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;<br>        <span class="hljs-keyword">if</span> (b1 == b2) &#123; <span class="hljs-comment">// 区间 [left, right] 在同一块中</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>() + b1 * size + i1, nums.<span class="hljs-built_in">begin</span>() + b1 * size + i2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> sum1 = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>() + b1 * size + i1, nums.<span class="hljs-built_in">begin</span>() + b1 * size + size, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum2 = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>() + b2 * size, nums.<span class="hljs-built_in">begin</span>() + b2 * size + i2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum3 = <span class="hljs-built_in">accumulate</span>(sum.<span class="hljs-built_in">begin</span>() + b1 + <span class="hljs-number">1</span>, sum.<span class="hljs-built_in">begin</span>() + b2, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum1 + sum2 + sum3;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>树状数组</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/?envType=daily-question&amp;envId=2023-11-13">带你发明树状数组！附数学证明</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p>
<p>单点更新，范围查询。要点如下：</p>
<ul>
<li>
<p>一个区间可以按二进制来划分</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231113161334209.png" srcset="/img/loading.gif" lazyload alt="image-20231113161334209"></p>
</li>
<li>
<p>lowbit（i）是i&amp;-i</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231113161434596.png" srcset="/img/loading.gif" lazyload alt="image-20231113161434596"></p>
</li>
<li>
<p>如果 x 是一个被更新的关键区间的右端点，那么下一个被更新的关键区间的右端点为 x+lowbit(x)。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i &amp;= i - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// i -= i &amp; -i 的另一种写法,i&amp;-i是lowbit（i）</span><br>            s += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) : <span class="hljs-built_in">nums</span>(nums.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">tree</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-built_in">update</span>(i, nums[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> delta = val - nums[index];<br>        nums[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index + <span class="hljs-number">1</span>; i &lt; tree.<span class="hljs-built_in">size</span>(); i += i &amp; -i) &#123;<br>            tree[i] += delta;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">prefixSum</span>(right + <span class="hljs-number">1</span>) - <span class="hljs-built_in">prefixSum</span>(left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="2760-最长奇偶子数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/">2760. 最长奇偶子数组</a></h2>
<blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p>
<p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code> 开头、下标 <code>r</code> 结尾 <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的 <strong>最长子数组</strong> ：</p>
<ul>
<li><code>nums[l] % 2 == 0</code></li>
<li>对于范围 <code>[l, r - 1]</code> 内的所有下标 <code>i</code> ，<code>nums[i] % 2 != nums[i + 1] % 2</code></li>
<li>对于范围 <code>[l, r]</code> 内的所有下标 <code>i</code> ，<code>nums[i] &lt;= threshold</code></li>
</ul>
<p>以整数形式返回满足题目要求的最长子数组的长度。</p>
<p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>dp</p>
<p>用一维数组<code>dp[i]</code>表示以<code>i</code>为下标的数结尾的最长奇偶子数组长度，转移方程是</p>
<p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>nums[i]&lt;=threshold 且 nums[i] % 2 != nums[i + 1] % 2</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>其他</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i]=
\begin{cases}
dp[i-1]+1 &amp; \text{nums[i]&lt;=threshold 且 nums[i] \% 2 != nums[i + 1] \% 2}\\
1 &amp; \text{其他}
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">nums[i]&lt;=threshold </span><span class="mord cjk_fallback">且</span><span class="mord"> nums[i] % 2 != nums[i + 1] % 2</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">其他</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> threshold)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= threshold &amp;&amp; nums[i] % <span class="hljs-number">2</span> != nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>)<br>        &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; res)<br>            &#123;<br>                res = dp[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>错误，没注意第一个条件是<code>nums[l] % 2 == 0</code></p>
</li>
<li>
<p>枚举</p>
<p>一遍遍历，直接记录符合条件的子数组最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> threshold)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= threshold)<br>            &#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>                i++;<br>                <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] &lt;= threshold &amp;&amp; nums[i] % <span class="hljs-number">2</span> != nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>)<br>                &#123;<br>                    len++;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len &gt; res)<br>                &#123;<br>                    res = len;<br>                &#125;<br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>枚举</p>
</li>
<li>
<p>动态规划</p>
<p>dp为开头，而不是结尾，这样才能考虑第一位，因此需要反向遍历。w</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231116120027193.png" srcset="/img/loading.gif" lazyload alt="image-20231116120027193"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> threshold)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, dp = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = n - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] &gt; threshold) &#123;<br>                dp = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == n - <span class="hljs-number">1</span> || nums[l] % <span class="hljs-number">2</span> != nums[l + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>) &#123;<br>                dp++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, dp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="2736-最大和查询"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-queries/">2736. 最大和查询</a></h2>
<blockquote>
<p>给你两个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，另给你一个下标从 <strong>1</strong> 开始的二维数组 <code>queries</code> ，其中 <code>queries[i] = [xi, yi]</code> 。</p>
<p>对于第 <code>i</code> 个查询，在所有满足 <code>nums1[j] &gt;= xi</code> 且 <code>nums2[j] &gt;= yi</code> 的下标 <code>j</code> <code>(0 &lt;= j &lt; n)</code> 中，找出 <code>nums1[j] + nums2[j]</code> 的 <strong>最大值</strong> ，如果不存在满足条件的 <code>j</code> 则返回 <strong>-1</strong> 。</p>
<p>返回数组 <code>answer</code> *，*其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>贪心？</p>
<p>按最大和排序，但这是个困难题，铁超时。看眼提示</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231117093859444.png" srcset="/img/loading.gif" lazyload alt="image-20231117093859444"></p>
<p>看不懂</p>
</li>
</ul>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>单调栈+二分查找</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-queries/solutions/2524819/zui-da-he-cha-xun-by-leetcode-solution-jlk0/?envType=daily-question&amp;envId=2023-11-17">2736. 最大和查询 - 力扣（LeetCode）</a></p>
<p>爬完山还是很累。。不想看了。</p>
</li>
</ul>
</li>
</ul>
<h2 id="53-最大子数组和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2>
<p>滑雪回来，重整旗鼓。</p>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>好眼熟的题目。</p>
<ul>
<li>
<p>贪心</p>
<p>遍历数组，用一个变量<code>sum</code>累加，若<code>sum</code>变负了则置零重新开始累加，因为负了对加上这段将会使答案变小，因此抛弃，这就是贪心的思想。期间记录最大值，即为返回答案。</p>
<p>要注意sum和res的初始值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	sum, res := <span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>		sum += nums[i]<br>		<span class="hljs-keyword">if</span> res &lt; sum &#123;<br>			res = sum<br>		&#125;<br>		<span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>			sum = <span class="hljs-number">0</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>动态规划</p>
<p>[经典动态规划问题（理解「无后效性」)](<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?envType=daily-question&amp;envId=2023-11-20">53. 最大子数组和 - 力扣（LeetCode）</a>)。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2216-美化数组的最少删除数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/">2216. 美化数组的最少删除数</a></h2>
<blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p>
<ul>
<li><code>nums.length</code> 为偶数</li>
<li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li>
</ul>
<p>注意，空数组同样认为是美丽数组。</p>
<p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p>
<p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目*。*</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>直接解题法（</p>
<p>依题意，直接遍历，若<code>nums[i]</code>和<code>nums[i+1]</code>一致就删除，且删除后要与<code>nums[i+2]</code>不一致。删除<code>nums[i]</code>或<code>nums[i+1]</code>即可，由于是遍历过来的，前面不会有一致的，若删除前面可能导致一致，且无论删除<code>nums[i]</code>或<code>nums[i+1]</code>还是i之前的，对大于i+1都是一样的，不用纠结。</p>
<p>可以通过指针来模拟删除，而不是真的删除后位移数组。</p>
<p>AC，注意对i+1，i+2的越界判断以及最后数组长度是否为偶数的判断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDeletion</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	res := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); &#123;<br>		<span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(nums) &#123;<br>			res++<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>			<span class="hljs-keyword">if</span> i+<span class="hljs-number">2</span> &gt;= <span class="hljs-built_in">len</span>(nums) || nums[i] != nums[i+<span class="hljs-number">2</span>] || nums[i+<span class="hljs-number">1</span>] != nums[i+<span class="hljs-number">2</span>] &#123;<br>				i += <span class="hljs-number">3</span><br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				i += <span class="hljs-number">1</span><br>			&#125;<br>			res++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			i += <span class="hljs-number">2</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(nums)-res)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>		res++<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>官解</p>
<p>额，个人思考中，删除后要与<code>nums[i+1]</code>不一致这一点多余了，因为要判断这一点时，<code>nums[i]</code>和<code>nums[i+1]</code>是相等的，直接删除即可。本人代码优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDeletion</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	res := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); &#123;<br>		<span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(nums) &#123;<br>			res++<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>			i += <span class="hljs-number">1</span><br>			res++<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			i += <span class="hljs-number">2</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2304-网格中的最小路径代价"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">2304. 网格中的最小路径代价</a></h2>
<blockquote>
<p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, …, <code>(x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意：</strong> 在最后一行中的单元格不能触发移动。</p>
<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p>
<p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价*。*</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231122115444781.png" srcset="/img/loading.gif" lazyload alt="image-20231122115444781"></p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>dp</p>
<p>用一个二维数组<code>dp[i][j]</code>表示从第一行开始到达第i行第j列的单元格的最小路径代价。先初始化第一行为单元格的值，然后遍历得到最小值即可。</p>
<p>AC</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathCost</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, moveCost [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	m, n, res := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]), <span class="hljs-number">-1</span><br>	dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>	dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>]<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>		dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>			dp[i][j] = <span class="hljs-number">-1</span><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m<span class="hljs-number">-1</span>; i++ &#123;<br>		<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>			<span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; n; k++ &#123;<br>				temp := dp[i][j] + moveCost[grid[i][j]][k] + grid[i+<span class="hljs-number">1</span>][k]<br>				dp[i+<span class="hljs-number">1</span>][k] = my_min(dp[i+<span class="hljs-number">1</span>][k], temp)<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>		res = my_min(dp[m<span class="hljs-number">-1</span>][i], res)<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">my_min</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-keyword">if</span> a == <span class="hljs-number">-1</span> || b == <span class="hljs-number">-1</span> &#123;<br>		<span class="hljs-keyword">if</span> a == <span class="hljs-number">-1</span> &#123;<br>			<span class="hljs-keyword">return</span> b<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> a<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> a &lt; b &#123;<br>		<span class="hljs-keyword">return</span> a<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> b<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>官解</p>
<p>基本类似。</p>
</li>
</ul>
<h2 id="1410-HTML-实体解析器-c-宏，go声明初始化二维数组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/html-entity-parser/">1410. HTML 实体解析器(c++宏，go声明初始化二维数组)</a></h2>
<blockquote>
<p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p>
<p>HTML 里这些特殊字符和它们对应的字符实体包括：</p>
<ul>
<li>**双引号：**字符实体为 <code>&quot;</code> ，对应的字符是 <code>&quot;</code> 。</li>
<li>**单引号：**字符实体为 <code>'</code> ，对应的字符是 <code>'</code> 。</li>
<li>**与符号：**字符实体为 <code>&amp;</code> ，对应对的字符是 <code>&amp;</code> 。</li>
<li>**大于号：**字符实体为 <code>&gt;</code> ，对应的字符是 <code>&gt;</code> 。</li>
<li>**小于号：**字符实体为 <code>&lt;</code> ，对应的字符是 <code>&lt;</code> 。</li>
<li>**斜线号：**字符实体为 <code>⁄</code> ，对应的字符是 <code>/</code> 。</li>
</ul>
<p>给你输入字符串 <code>text</code> ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>额，学习go的字符串替换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Replace</span><span class="hljs-params">(s,old,<span class="hljs-built_in">new</span> <span class="hljs-type">string</span> ,n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>要替换的整个字符串</td>
</tr>
<tr>
<td>old</td>
<td>要替换的字符串</td>
</tr>
<tr>
<td>new</td>
<td>替换成什么字符串</td>
</tr>
<tr>
<td>n</td>
<td>要替换的次数，为-1则全部替换</td>
</tr>
</tbody>
</table>
<p>调用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs GO">strings.Replace(strHaiCoder, <span class="hljs-string">&quot;HaiCoder&quot;</span>, <span class="hljs-string">&quot;haicoder&quot;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<p>编写代码如下，特别注意二维字符串数组的声明初始化</p>
<ul>
<li>使用花括号，而不是[]</li>
<li><code>'</code>不需要转义，即不要写成<code>\'</code></li>
<li>最后一个花括号后面还有一个逗号</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entityParser</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">var</span> smap [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<br>		&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;,<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>		text = strings.Replace(text, smap[i][<span class="hljs-number">0</span>], smap[i][<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> text<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但是出错</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231123103327078.png" srcset="/img/loading.gif" lazyload alt="image-20231123103327078"></p>
<p>就是说，只需要一次转义。因此需要将<code>&amp;amp</code>的处理放在最后面。</p>
<p>AC</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entityParser</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">var</span> smap [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<br>		&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;,<br>		&#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;,<br>	&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>		text = strings.Replace(text, smap[i][<span class="hljs-number">0</span>], smap[i][<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>)<br>	&#125;<br>	<span class="hljs-keyword">return</span> text<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<p>官解是去模拟的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entityParser</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    entityMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;&amp;quot;&quot;</span>: <span class="hljs-string">&quot;\&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;apos;&quot;</span>: <span class="hljs-string">&quot;&#x27;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;gt;&quot;</span>: <span class="hljs-string">&quot;&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;lt;&quot;</span>: <span class="hljs-string">&quot;&lt;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;frasl;&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;amp;&quot;</span>: <span class="hljs-string">&quot;&amp;&quot;</span>,<br>    &#125;<br><br>    i := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(text)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i &lt; n &#123;<br>        isEntity := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;&amp;&#x27;</span> &#123;<br>            <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> entityMap &#123;<br>                <span class="hljs-keyword">if</span> i + <span class="hljs-built_in">len</span>(k) &lt;= n &amp;&amp; text[i : i + <span class="hljs-built_in">len</span>(k)] == k &#123;<br>                    res = <span class="hljs-built_in">append</span>(res, v)<br>                    isEntity = <span class="hljs-literal">true</span><br>                    i += <span class="hljs-built_in">len</span>(k)<br>                    <span class="hljs-keyword">break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !isEntity &#123;<br>            res = <span class="hljs-built_in">append</span>(res, text[i:i+<span class="hljs-number">1</span>])<br>            i++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strings.Join(res, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另外，看到一个用c++宏来解题的代码，比较优雅</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPLACE(STRING, CHAR)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    static constexpr string_view sv = #STRING;\</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (i + sv.size() &lt;= s &amp;&amp; string_view(&amp;c, sv.size()) == sv) &#123;\</span><br><span class="hljs-meta">        ans += CHAR;\</span><br><span class="hljs-meta">        i += sv.size();\</span><br><span class="hljs-meta">        continue;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">entityParser</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> s = text.<span class="hljs-built_in">size</span>();<br>        string ans;<br>        ans.<span class="hljs-built_in">reserve</span>(s);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s;) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c = text[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&amp;&#x27;</span>) &#123;<br>                <span class="hljs-built_in">REPLACE</span>(&amp;quot;, <span class="hljs-string">&#x27;\&quot;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;apos;, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;amp;, <span class="hljs-string">&#x27;&amp;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;gt;, <span class="hljs-string">&#x27;&gt;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;lt;, <span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;frasl;, <span class="hljs-string">&#x27;/&#x27;</span>)<br>            &#125;<br>            ans += c;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2824-统计和小于目标的下标对数目"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/">2824. 统计和小于目标的下标对数目</a></h2>
<blockquote>
<p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>target</code> ，请你返回满足 <code>0 &lt;= i &lt; j &lt; n</code> 且 <code>nums[i] + nums[j] &lt; target</code> 的下标对 <code>(i, j)</code> 的数目。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>贪心</p>
<p>排序，然后遍历。</p>
<p>AC</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	sort.Ints(nums)<br>	res := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>		<span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br>			<span class="hljs-keyword">if</span> nums[i]+nums[j] &lt; target &#123;<br>				res++<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>官解</p>
<p>排序之后，重点在于找到不满足的那个<code>nums[j]</code>即可。</p>
<ul>
<li>
<p>二分查找</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        res += sort.SearchInts(nums[<span class="hljs-number">0</span>:i], target - nums[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>双指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i &lt; j; i++ &#123;<br>        <span class="hljs-keyword">for</span> i &lt; j &amp;&amp;  nums[i] + nums[j] &gt;= target &#123;<br>            j--<br>        &#125;<br>        res += j - i<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="1457-二叉树中的伪回文路径"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/">1457. 二叉树中的伪回文路径</a></h2>
<blockquote>
<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>
<p>请你返回从根到叶子节点的所有路径中 <strong>伪回文</strong> 路径的数目。</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231125100659250.png" srcset="/img/loading.gif" lazyload alt="image-20231125100659250"></p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>伪回文序列指的是存在一个序列是回文序列，也就是说需要满足这个序列中的数个数为奇数最多只能有一个，其他数的个数均为偶数。</p>
<ul>
<li>
<p>深度搜素</p>
<p>深搜每一条路径，记录每一条路径的序列后判断是否为伪回文即可。</p>
<p>MLE，因为虽然go语言的参数传递全是值传递，但是切片是引用类型，因此我的处理方式是复制</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pseudoPalindromicPaths</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>	nums, res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span><br>	dfs(root, nums, &amp;res)<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node *TreeNode, nums []<span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>		nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>		m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>			m[nums[i]]++<br>		&#125;<br>		odd := <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>			<span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>				odd++<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> odd &lt; <span class="hljs-number">2</span> &#123;<br>			*res++<br>		&#125;<br><br>	&#125;<br>	<span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>		nums_new := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), nums...)<br>		nums_new = <span class="hljs-built_in">append</span>(nums_new, node.Val)<br>		dfs(node.Left, nums_new, res)<br>	&#125;<br>	<span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>		nums_new := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), nums...)<br>		nums_new = <span class="hljs-built_in">append</span>(nums_new, node.Val)<br>		dfs(node.Right, nums_new, res)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>于是优化了一下，结果TLE了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pseudoPalindromicPaths</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>	nums, res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span><br>	dfs(root, nums, &amp;res)<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node *TreeNode, nums []<span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>	<span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>		nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>		m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>			m[nums[i]]++<br>		&#125;<br>		odd := <span class="hljs-number">0</span><br>		<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>			<span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>				odd++<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> odd &lt; <span class="hljs-number">2</span> &#123;<br>			*res++<br>		&#125;<br>		nums = nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>		nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>		dfs(node.Left, nums, res)<br>		nums = nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>	&#125;<br>	<span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>		nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>		dfs(node.Right, nums, res)<br>		nums = nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从题解来看，问题在于对伪回文的判断上。</p>
</li>
</ul>
</li>
<li>
<p>官解</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pseudoPalindromicPaths</span> <span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    counter := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> dfs(root, counter)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, counter []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    counter[root.Val]++<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> isPseudoPalindrome(counter) &#123;<br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res = dfs(root.Left, counter) + dfs(root.Right, counter)<br>    &#125;<br>    counter[root.Val]--<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPseudoPalindrome</span><span class="hljs-params">(counter []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    odd := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> counter &#123;<br>        <span class="hljs-keyword">if</span> value % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            odd++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> odd &lt;= <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>res = dfs(root.Left, counter) + dfs(root.Right, counter)</code>这句比较难理解，重点在于res仍是只在叶子节点才会进行判断增加。</p>
</li>
</ul>
<h2 id="828-统计子串中的唯一字符"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">828. 统计子串中的唯一字符</a></h2>
<blockquote>
<p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p>
<p>例如：<code>s = &quot;LEETCODE&quot;</code> ，则其中 <code>&quot;L&quot;</code>, <code>&quot;T&quot;</code>,<code>&quot;C&quot;</code>,<code>&quot;O&quot;</code>,<code>&quot;D&quot;</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p>
<p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为 32 位整数。</p>
<p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>考虑一个全是不重复字母组成的字符串<code>s</code>，其长度为<code>n</code>,那么他的<code>countUniqueChars(s)</code>应为<code>1*n+2*(n-1)+3*(n-2)+...+n*1</code></p>
<p>考虑已经有一个长度为<code>n</code>的字符串<code>str</code>，在其后新增一个字母，假设为<code>a</code>，那么他将为新的字符串贡献以它结尾的<code>n+1</code>个子字符串（本身也是一个子字符串）。这样思路，这些新的子字符串是通过它向前遍历得来的，期间维护一个变量<code>unique_num</code>，统计当前新子字符串中的唯一字符数量，每遍历一个就加一次。</p>
<p>TLE</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniqueLetterString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	res := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>		m, unique_num := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;s[i]: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">1</span><br>		res++<br>		<span class="hljs-keyword">for</span> j := i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>			<span class="hljs-keyword">if</span> m[s[j]] == <span class="hljs-number">0</span> &#123;<br>				unique_num++<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m[s[j]] == <span class="hljs-number">1</span> &#123;<br>				unique_num--<br>			&#125;<br>			m[s[j]]++<br>			res += unique_num<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<p>s优化：不用向前遍历统计唯一字符数量，可以一开始就维护一张表，记录<code>unique_num</code>在这个位置是增加还是减少。嘶，写不出来</p>
</li>
<li>
<p>官解</p>
<p>思路不一样，官解是针对到每一个字符，统计它能产生多少个只包含一个该字符的子串，假设该字符现在在第<code>i</code>位，记作<code>ci</code>，上一次出现的字符记作<code>cj</code>，下一次出现的字符为<code>ck</code>，则只包含i位置上的c能产生的子串有<code>(cj-ci)*(ci-ck)</code>个。</p>
<p><code>arr = append(append([]int&#123;-1&#125;, arr...), len(s))</code>的作用是在数组前加了一个<code>-1</code>，最后加了一个数组的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniqueLetterString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    idx := <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;<br>        idx[c] = <span class="hljs-built_in">append</span>(idx[c], i)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, arr := <span class="hljs-keyword">range</span> idx &#123;<br>        arr = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, arr...), <span class="hljs-built_in">len</span>(s))<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123;<br>            ans += (arr[i] - arr[i<span class="hljs-number">-1</span>]) * (arr[i+<span class="hljs-number">1</span>] - arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="907-子数组的最小值之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></h2>
<blockquote>
<p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p>
<p>由于答案可能很大，因此 <strong>返回答案模 <code>10^9 + 7</code></strong> 。</p>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>和上一题思考角度类似。考虑最小值能产生多少贡献，嘶，那第二最小值得在没有这个最小值的子串中去考虑，是个递归？</p>
<p>回到上一题的自己个人思路，考虑每一个增加的数能产生多少贡献。从后往前记录数值下降的数</p>
<p>第73个样例WA了，这怎么查。</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231127122859159.png" srcset="/img/loading.gif" lazyload alt="image-20231127122859159"></p>
<p>观察结果，大于<code>10^9+7</code>，发现是模出错了。</p>
<p>AC</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	MOD := <span class="hljs-type">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>	res, now_min, idx := arr[<span class="hljs-number">0</span>], <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(arr)), <span class="hljs-number">0</span><br>	now_min[<span class="hljs-number">0</span>] = [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;arr[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;<br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>		j := idx<br>		<span class="hljs-keyword">for</span> ; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>			<span class="hljs-keyword">if</span> arr[i] &gt;= now_min[j][<span class="hljs-number">0</span>] &#123;<br>				<span class="hljs-keyword">break</span><br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> j != <span class="hljs-number">-1</span> &amp;&amp; now_min[i][<span class="hljs-number">0</span>] == arr[i] &#123;<br>			idx = j<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			idx = j + <span class="hljs-number">1</span><br>		&#125;<br>		now_min[idx] = [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;arr[i], i&#125;<br>		<span class="hljs-keyword">for</span> j = idx; j &gt; <span class="hljs-number">0</span>; j-- &#123;<br>			res += now_min[j][<span class="hljs-number">0</span>] * (now_min[j][<span class="hljs-number">1</span>] - now_min[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]) % MOD<br>		&#125;<br>		res += now_min[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * (now_min[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) % MOD<br>		<span class="hljs-comment">// fmt.Println(i)</span><br>		<span class="hljs-comment">// fmt.Println(now_min)</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> res % MOD<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>单调栈</p>
<p>有关单调栈，有点复杂，之后再看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">const</span> mod <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br>    n := <span class="hljs-built_in">len</span>(arr)<br>    left := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    right := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    monoStack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= arr[monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]] &#123;<br>            monoStack = monoStack[:<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) == <span class="hljs-number">0</span> &#123;<br>            left[i] = i + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left[i] = i - monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        monoStack = <span class="hljs-built_in">append</span>(monoStack, i)<br>    &#125;<br>    monoStack = []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i] &lt; arr[monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]] &#123;<br>            monoStack = monoStack[:<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) == <span class="hljs-number">0</span> &#123;<br>            right[i] = n - i<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right[i] = monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>] - i<br>        &#125;<br>        monoStack = <span class="hljs-built_in">append</span>(monoStack, i)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> arr &#123;<br>        ans = (ans + left[i]*right[i]*x) % mod<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>dp</p>
<p>思路和我类似，感觉是换了一个形式输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">const</span> mod <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br>    n := <span class="hljs-built_in">len</span>(arr)<br>    monoStack := []<span class="hljs-type">int</span>&#123;&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &amp;&amp; arr[monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]] &gt; x &#123;<br>            monoStack = monoStack[:<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        k := i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &#123;<br>            k = i - monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        dp[i] = k * x<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &#123;<br>            dp[i] += dp[i-k]<br>        &#125;<br>        ans = (ans + dp[i]) % mod<br>        monoStack = <span class="hljs-built_in">append</span>(monoStack, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="1670-设计前中后队列"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a></h2>
<blockquote>
<p>请你设计一个队列，支持在前，中，后三个位置的 <code>push</code> 和 <code>pop</code> 操作。</p>
<p>请你完成 <code>FrontMiddleBack</code> 类：</p>
<ul>
<li><code>FrontMiddleBack()</code> 初始化队列。</li>
<li><code>void pushFront(int val)</code> 将 <code>val</code> 添加到队列的 <strong>最前面</strong> 。</li>
<li><code>void pushMiddle(int val)</code> 将 <code>val</code> 添加到队列的 <strong>正中间</strong> 。</li>
<li><code>void pushBack(int val)</code> 将 <code>val</code> 添加到队里的 <strong>最后面</strong> 。</li>
<li><code>int popFront()</code> 将 <strong>最前面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>
<li><code>int popMiddle()</code> 将 <strong>正中间</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>
<li><code>int popBack()</code> 将 <strong>最后面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li>
</ul>
<p>请注意当有 <strong>两个</strong> 中间位置的时候，选择靠前面的位置进行操作。比方说：</p>
<ul>
<li>将 <code>6</code> 添加到 <code>[1, 2, 3, 4, 5]</code> 的中间位置，结果数组为 <code>[1, 2, **6**, 3, 4, 5]</code> 。</li>
<li>从 <code>[1, 2, **3**, 4, 5, 6]</code> 的中间位置弹出元素，返回 <code>3</code> ，数组变为 <code>[1, 2, 4, 5, 6]</code> 。</li>
</ul>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<p>阿巴阿巴</p>
</li>
<li>
<p>官解</p>
<ul>
<li>
<p>双端队列</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FrontMiddleBackQueue <span class="hljs-keyword">struct</span> &#123;<br>    left *list.List<br>    right *list.List<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> FrontMiddleBackQueue &#123;<br>    <span class="hljs-keyword">return</span> FrontMiddleBackQueue&#123;<br>        left: list.New(), <br>        right: list.New(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PushFront(val <span class="hljs-type">int</span>)  &#123;<br>    this.left.PushFront(val)<br>    <span class="hljs-keyword">if</span> this.left.Len() == this.right.Len() + <span class="hljs-number">2</span> &#123;<br>        this.right.PushFront(this.left.Back().Value.(<span class="hljs-type">int</span>))<br>        this.left.Remove(this.left.Back())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PushMiddle(val <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == this.right.Len() + <span class="hljs-number">1</span> &#123;<br>        this.right.PushFront(this.left.Back().Value.(<span class="hljs-type">int</span>))<br>        this.left.Remove(this.left.Back())<br>    &#125;<br>    this.left.PushBack(val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PushBack(val <span class="hljs-type">int</span>)  &#123;<br>    this.right.PushBack(val)<br>    <span class="hljs-keyword">if</span> this.left.Len() + <span class="hljs-number">1</span> == this.right.Len() &#123;<br>        this.left.PushBack(this.right.Front().Value.(<span class="hljs-type">int</span>))<br>        this.right.Remove(this.right.Front())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PopFront() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    val := this.left.Front().Value.(<span class="hljs-type">int</span>)<br>    this.left.Remove(this.left.Front())<br>    <span class="hljs-keyword">if</span> this.left.Len() + <span class="hljs-number">1</span> == this.right.Len() &#123;<br>        this.left.PushBack(this.right.Front().Value.(<span class="hljs-type">int</span>))<br>        this.right.Remove(this.right.Front())<br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PopMiddle() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    val := this.left.Back().Value.(<span class="hljs-type">int</span>)<br>    this.left.Remove(this.left.Back())<br>    <span class="hljs-keyword">if</span> this.left.Len() + <span class="hljs-number">1</span> == this.right.Len() &#123;<br>        this.left.PushBack(this.right.Front().Value.(<span class="hljs-type">int</span>))<br>        this.right.Remove(this.right.Front())<br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PopBack() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.right.Len() == <span class="hljs-number">0</span> &#123;<br>        val := this.left.Back().Value.(<span class="hljs-type">int</span>)<br>        this.left.Remove(this.left.Back())<br>        <span class="hljs-keyword">return</span> val<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        val := this.right.Back().Value.(<span class="hljs-type">int</span>)<br>        this.right.Remove(this.right.Back())<br>        <span class="hljs-keyword">if</span> this.left.Len() == this.right.Len() + <span class="hljs-number">2</span> &#123;<br>            this.right.PushFront(this.left.Back().Value.(<span class="hljs-type">int</span>))<br>            this.left.Remove(this.left.Back())<br>        &#125;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="2336-无限集中的最小数字"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-number-in-infinite-set/">2336. 无限集中的最小数字</a></h2>
<blockquote>
<p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code> 。</p>
<p>实现 <code>SmallestInfiniteSet</code> 类：</p>
<ul>
<li><code>SmallestInfiniteSet()</code> 初始化 <strong>SmallestInfiniteSet</strong> 对象以包含 <strong>所有</strong> 正整数。</li>
<li><code>int popSmallest()</code> <strong>移除</strong> 并返回该无限集中的最小整数。</li>
<li><code>void addBack(int num)</code> 如果正整数 <code>num</code> <strong>不</strong> 存在于无限集中，则将一个 <code>num</code> <strong>添加</strong> 到该无限集中。</li>
</ul>
</blockquote>
<ul>
<li>
<p>个人思路</p>
<ul>
<li>
<p>独家秘诀（大概</p>
<p><code>arr_next[i]=j</code>用于记录<code>i</code>后的下一个最小的数为<code>j</code>，若为<code>-1</code>则表示该数不在集合中；<code>minp</code>用于记录最小的数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SmallestInfiniteSet <span class="hljs-keyword">struct</span> &#123;<br>	arr_next []<span class="hljs-type">int</span><br>	minp     <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> SmallestInfiniteSet &#123;<br>	arr_next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1005</span>, <span class="hljs-number">1005</span>)<br>	minp := <span class="hljs-number">1</span><br>	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1002</span>; i++ &#123;<br>		arr_next[i] = i + <span class="hljs-number">1</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> SmallestInfiniteSet&#123;arr_next: arr_next, minp: minp&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> PopSmallest() <span class="hljs-type">int</span> &#123;<br>	res := this.minp<br>	this.minp = this.arr_next[res]<br>	this.arr_next[res] = <span class="hljs-number">-1</span><br>	<span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> AddBack(num <span class="hljs-type">int</span>) &#123;<br>	<span class="hljs-keyword">if</span> this.arr_next[num] == <span class="hljs-number">-1</span> &#123;<br>		<span class="hljs-keyword">if</span> this.minp &gt; num &#123;<br>			this.arr_next[num] = this.minp<br>			this.minp = num<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">for</span> i := num - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br>				<span class="hljs-keyword">if</span> this.arr_next[i] != <span class="hljs-number">-1</span> &#123;<br>					this.arr_next[num] = this.arr_next[i]<br>					this.arr_next[i] = num<br>					<span class="hljs-keyword">break</span><br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>官解</p>
<p>卑鄙的官解使用库函数，而且利用了题目中操作不会大于1000的条件，这样才可以使用<code>thres</code>记录最小值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SmallestInfiniteSet <span class="hljs-keyword">struct</span> &#123;<br>    thres <span class="hljs-type">int</span><br>    s *treeset.Set<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> SmallestInfiniteSet &#123;<br>    <span class="hljs-keyword">return</span> SmallestInfiniteSet&#123;<br>        thres:<span class="hljs-number">1</span>,<br>        s:treeset.NewWithIntComparator(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> PopSmallest() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.s.Empty() &#123;<br>        ans := this.thres<br>        this.thres++<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br>    it := this.s.Iterator()<br>    it.Next()<br>    ans := it.Value().(<span class="hljs-type">int</span>)<br>    this.s.Remove(ans)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> AddBack(num <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> num &lt; this.thres &#123;<br>        this.s.Add(num)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1657-确定两个字符串是否接近"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/determine-if-two-strings-are-close/">1657. 确定两个字符串是否接近</a></h2>
<blockquote>
<p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p>
<ul>
<li>
<p>操作 1：交换任意两个</p>
<p>现有</p>
<p>字符。</p>
<ul>
<li>例如，<code>a**b**cd**e** -&gt; a**e**cd**b**</code></li>
</ul>
</li>
<li>
<p>操作 2：将一个</p>
<p>现有</p>
<p>字符的每次出现转换为另一个</p>
<p>现有</p>
<p>字符，并对另一个字符执行相同的操作。</p>
<ul>
<li>例如，<code>**aa**c**abb** -&gt; **bb**c**baa**</code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li>
</ul>
</li>
</ul>
<p>你可以根据需要对任意一个字符串多次使用这两种操作。</p>
<p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果 <code>word1</code> 和 <code>word2</code> <strong>接近</strong> ，就返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<ul>
<li>
<p>官解</p>
<p><img src="/2023/11/01/leetcode23-11/image-20231130100552783.png" srcset="/img/loading.gif" lazyload alt="image-20231130100552783"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closeStrings</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count1, count2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> word1 &#123;<br>        count1[c - <span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> word2 &#123;<br>        count2[c - <span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> count1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count2[i] == <span class="hljs-number">0</span> || count1[i] == <span class="hljs-number">0</span> &amp;&amp; count2[i] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    sort.Ints(count1)<br>    sort.Ints(count2)<br>    <span class="hljs-keyword">return</span> reflect.DeepEqual(count1, count2)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/" class="category-chain-item">算法编程</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/leetcode/" class="category-chain-item">leetcode</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
        <a href="/tags/leetcode/" class="print-no-link">#leetcode</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>leetcode23-11</div>
      <div>https://codenum137.github.io/codenum137.github.io/2023/11/01/leetcode23-11/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>hey137</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/" title="GNS3部署SONIC路由器并与真机互通">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">GNS3部署SONIC路由器并与真机互通</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/" title="Go高性能省流版">
                        <span class="hidden-mobile">Go高性能省流版</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"VUZA7v64z7VyTAP8IacQddb3-gzGzoHsz","appKey":"s9nmj2bQKMeENVBm24I948wx","path":"window.location.pathname","placeholder":"欢迎评论交流=v=","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://vuza7v64.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="/js/code-collapse.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
