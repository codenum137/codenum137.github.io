<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Marscode刷题</title>
    <link href="/2025/01/07/Marscode%E5%88%B7%E9%A2%98/"/>
    <url>/2025/01/07/Marscode%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>Marscode刷题</h1><h2 id="算法分类">算法分类</h2><h3 id="前缀和">前缀和</h3><ul><li>利用前缀和解决连续子序列问题。[88 - 连续子串和的整除问题](### 88 - 连续子串和的整除问题)</li></ul><h2 id="简单题">简单题</h2><h3 id="88-连续子串和的整除问题">88 - 连续子串和的整除问题</h3><blockquote><blockquote><p>小M是一个五年级的小学生，今天他学习了整除的知识，想通过一些练习来巩固自己的理解。他写下了一个长度为 <code>n</code> 的正整数序列 <code>a_0, a_1, ..., a_&#123;n-1&#125;</code>，然后想知道有多少个连续子序列的和能够被一个给定的正整数 <code>b</code> 整除。你能帮小M解决这个问题吗？</p><p><em><strong>样例1：</strong></em></p><blockquote><p>输入：<code>n = 3,b = 3,sequence = [1, 2, 3]</code><br>输出：<code>3</code></p></blockquote></blockquote></blockquote><p><strong>解题思路</strong></p><p>遍历正整数序列计算前缀和，并对前缀和模<code>b</code>的结果计数。现在考虑前缀和模<code>b</code>意味着什么？假设当前前缀和模<code>b</code>结果为<code>x</code>，最后要返回的答案为<code>result</code>，<code>x</code>会有两种情况：</p><ul><li><code>x</code>的计数为0，说明之前的前缀和中从来没有出现这个结果，那么计数加1即可</li><li><code>x</code>的计数为<code>y</code>，说明之前总有<code>y</code>段前缀和出现了<code>x</code>，那么我们将当前前缀和剪去这<code>y</code>段前缀和，则可得到<code>y</code>段连续子序列被<code>b</code>整除。由于这些连续子序列都包含正整数序列最新的元素，所以这种方式的不重不漏的。故<code>result+=y</code>，然后计数加1即可。</li></ul><p>需要特殊注意的是，我们需要将<code>x</code>为0的计数初始化为1，因为0也是一个前缀和（什么元素都没有），这样才能计算正确。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">solution</span>(<span class="hljs-params">n, b, sequence</span>):<br>    <span class="hljs-comment"># 初始化一个哈希表来记录模结果出现的次数</span><br>    mod_count = &#123;&#125;<br>    <span class="hljs-comment"># 初始化前缀和为0，并且模结果为0的次数为1（因为前缀和为0的情况也算一种）</span><br>    prefix_sum = <span class="hljs-number">0</span><br>    mod_count[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    result = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> sequence:<br>        <span class="hljs-comment"># 更新前缀和</span><br>        prefix_sum += num<br>        <span class="hljs-comment"># 计算当前前缀和的模结果</span><br>        current_mod = prefix_sum % b<br>        <br>        <span class="hljs-comment"># 如果当前模结果已经在哈希表中，说明存在一些子序列的和是b的倍数</span><br>        <span class="hljs-keyword">if</span> current_mod <span class="hljs-keyword">in</span> mod_count:<br>            result += mod_count[current_mod]<br>            <span class="hljs-comment"># 更新哈希表中当前模结果的次数</span><br>            mod_count[current_mod] += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前模结果不在哈希表中，初始化其次数为1</span><br>            mod_count[current_mod] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>Marscode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word使用心得</title>
    <link href="/2025/01/07/word%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/2025/01/07/word%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1>word使用心得</h1><h2 id="样式设置">样式设置</h2><p><img src="/2025/01/07/word%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/image-20250107103436481.png" alt="image-20250107103436481"></p><ul><li><p>样式类型：这一栏有个链接的段落和字符，意思就是只会应用到你选中的文字上。</p></li><li><p>样式基准：用作基准的样式。新样式使用某个样式作为基准，且新样式未对某个属性作出修改时，基准样式的属性修改会影响新样式（似乎也可以取消自动更新这个选项来解决）。只有当新样式作出新的属性修改时，这个属性才会独立，不受基准样式的影响。</p><ul><li>一般都是正文，这儿的正文是word内置的样式，所以一般不修改这个样式，否则会出现修改正文样式导致所有样式都出现排版错误的情况。</li></ul></li><li><p>后续段落样式：就是说这个样式之后的内容采用什么样式。</p></li></ul><h2 id="标题序号自动排列">标题序号自动排列</h2><p><img src="/2025/01/07/word%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/image-20250107104246454.png" alt="image-20250107104246454"></p><p><img src="/2025/01/07/word%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/image-20250107104340188.png" alt="image-20250107104340188"></p><p>注意红框内容，应该就懂了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>word</tag>
      
      <tag>排版</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo迁移到新设备</title>
    <link href="/2024/09/18/hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E8%AE%BE%E5%A4%87/"/>
    <url>/2024/09/18/hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E8%AE%BE%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<h1>hexo迁移到新设备</h1><ol><li><p>安装git。<a href="https://git-scm.com/">Git (git-scm.com)</a></p></li><li><p>绑定github。</p><ol><li><p>新设备上生成密钥。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure></li><li><p>进入默认文件夹，复制公钥<code>id_rsa.pub</code>的内容。注意，git中的复制粘贴是<code>Ctrl+insert</code>和<code>Shift+insert</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">Linux 系统：~/.ssh<br>Mac 系统：~/.ssh<br>Windows 10 ：C:/Users/ASUS/.ssh<br><span class="hljs-built_in">cat</span> id_rsa.pub<br></code></pre></td></tr></table></figure></li><li><p>进入github网站，个人头像:arrow_right:settings :arrow_right: SSH and GPG keys :arrow_right: New SSH key。添加复制的公钥。</p></li><li><p>使用以下命令进行检验。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>出现以下情况即为绑定成功。</p><p><img src="/2024/09/18/hexo%E8%BF%81%E7%A7%BB%E5%88%B0%E6%96%B0%E8%AE%BE%E5%A4%87/v2-3915b3e46e40010d3d911f84d4e8b0ff_r.jpg" alt="img"></p></li></ol></li><li><p>设置git个人用户名和邮箱</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name <span class="hljs-string">&quot;FocusNow&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;3261575578@qq.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>安装nodejs。<a href="https://link.zhihu.com/?target=https%3A//nodejs.org/en/">node.js官网</a></p></li><li><p>设置npm在安装全局模块时的路径和环境变量。参考<a href="https://blog.csdn.net/qingbo_2920249511/article/details/120869161">npm intasll 安装报错 Error: EPERM: operation not permitted, mkdir ‘C:\Program Files\nodejs\node_cache__npm err! error: eperm: operation not permitted, mk-CSDN博客</a>方法一。</p></li><li><p>将旧设备的<code>Blog</code>文件夹直接拷到新设备即可。</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>个人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python工具箱</title>
    <link href="/2024/09/13/python%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <url>/2024/09/13/python%E5%B7%A5%E5%85%B7%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1>python工具箱</h1><h2 id="更新下载源">更新下载源</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">python -m pip install --upgrade pip<br>pip config <span class="hljs-built_in">set</span> <span class="hljs-keyword">global</span>.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模-建模手学习记录</title>
    <link href="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>数学建模-建模手学习记录</h1><h2 id="华为杯数学建模介绍">华为杯数学建模介绍</h2><p><a href="https://zhuanlan.zhihu.com/p/215274409">“华为杯”——中国研究生数学建模大赛相关解读（最全） - 知乎 (zhihu.com)</a></p><blockquote><blockquote><p>1、建模</p><p>工作内容：提供对问题的解决思路、方法。</p><p>备赛准备：数学能力，了解常用<a href="https://zhida.zhihu.com/search?q=%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B&amp;zhida_source=entity&amp;is_preview=1">数学模型</a>的适用范围，大致的思想方法以及实现步骤，做到比赛的时候能够迅速地知道能用什么模型来做，以及大概需要多少时间来搞定。如果不提前了解都有什么数学模型的话，很容易走入死胡同难以自拔却不自知。推荐书籍：<a href="https://zhida.zhihu.com/search?q=%E5%8F%B8%E5%AE%88%E5%A5%8E&amp;zhida_source=entity&amp;is_preview=1">司守奎</a>的《<a href="https://zhida.zhihu.com/search?q=%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95%E4%B8%8E%E5%BA%94%E7%94%A8&amp;zhida_source=entity&amp;is_preview=1">数学建模算法与应用</a>》，这本书的作者领导队伍拿过2还是3次高教社杯，编著的书籍也应该非常有参考价值。</p><p>2、编程</p><p>工作内容：编程能力，参与实现模型或者求解模型，要求能熟练的通过各种软件对模型进行模拟、求解、检验。</p><p>模型求解软件：Matlab/Mathematica/Python/Octave/SPSS/Minitab/R/Lingo，使用MATLAB的居多。</p><p>3、写作</p><p>工作内容：写作能力，清晰把握团队的前进方向，通过准确的文字、图标对模型进行展示。</p><p>论文写作软件：Word/LaTex</p><p><a href="https://zhida.zhihu.com/search?q=%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%99%A8&amp;zhida_source=entity&amp;is_preview=1">公式编辑器</a>：MathType/mindject/PowerPoint</p></blockquote></blockquote><p>不推荐使用的模型：层次分析法（决策主观成分大），模糊综合评价（隶属函数主观成分大），灰色预测算法（只适用于小样本的中短期预测），BP神经网络模型（不能提供解析表达式，同时需要大量训练样本）。</p><h2 id="评价决策类">评价决策类</h2><h3 id="层次分析法">层次分析法</h3><p><strong>模型原理</strong></p><p>将问题条理化，层次化，可分为三层：</p><ul><li>最高层：预定目标或理想结果。</li><li>中间层：目标涉及的中间环节，如各项指标。</li><li>最底层：可供选择的各种措施和决策方案，如评价对象。</li></ul><p><strong>基本步骤</strong></p><ul><li><p>建立三层结构模型。</p></li><li><p>构建中间层的判断矩阵。</p></li><li><p>对判断矩阵的一致性检验。</p><ul><li><p>求判断矩阵的最大特征值，得<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">CI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908140831268.png" alt="image-20240908140831268"></p></li><li><p>查表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">RI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908141035120.png" alt="image-20240908141035120"></p></li><li><p>求<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">CR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">CR</span></span></span></span>。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908141057759.png" alt="image-20240908141057759"></p></li></ul></li><li><p>求权重后评分。</p><p>有三种方法求权重：</p><ul><li><p>算术平均。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240907102810465.png" alt="image-20240907102810465"></p></li><li><p>几何平均。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240907102930906.png" alt="image-20240907102930906"></p></li><li><p>特征值。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240907103201458.png" alt="image-20240907103201458"></p></li></ul></li></ul><h3 id="topsis法">topsis法</h3><p><strong>基本概念</strong></p><p>TOPSIS也称优劣解距离法。求最接近理想解，同时远离负理想解的方案。</p><p><strong>基本步骤</strong></p><ol><li><p>将原始矩阵正向化。原始矩阵是各种指标数据所组成的矩阵。</p><ul><li><p>不同类型指标</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908141715603.png" alt="image-20240908141715603"></p></li><li><p>转化为极大型指标，即正向化。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908141851986.png" alt="image-20240908141851986"></p></li></ul></li><li><p>正向矩阵标准化并确定权重。</p><p><strong>标准化是为了消除量纲的影响。</strong></p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908142010441.png" alt="image-20240908142010441"></p></li><li><p>计算得分并归一化。</p><p>距离实际上就是空间中两点之间的距离公式。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908142123836.png" alt="image-20240908142123836"></p></li></ol><h3 id="熵权法">熵权法</h3><p><strong>基本概念</strong></p><p>熵权法是一种<strong>客观的赋权方法</strong>，依靠数据本身得出权重。指标的离散程度越大，所反映的信息越多，权值越高。</p><p><strong>基本步骤</strong></p><ol><li><p>数据标准化</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908142629560.png" alt="image-20240908142629560"></p></li><li><p>计算概率矩阵P</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908142721896.png" alt="image-20240908142721896"></p></li><li><p>计算熵权</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908142735404.png" alt="image-20240908142735404"></p></li></ol><h3 id="模糊评价">模糊评价</h3><p>隶属函数刻画某一事物对模糊集的隶属程度。</p><p>隶属函数的确定方法：</p><ul><li><p>模糊统计法，即问卷调查。</p></li><li><p>借助已有尺度，如使用1-恩格尔系数来衡量小康家庭这个模糊集。</p></li><li><p>指派法，主观意愿来指派隶属函数</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908151930615.png" alt="image-20240908151930615"></p></li></ul><p><strong>一级模糊综合评价模型</strong></p><ol><li>确定因素集，评判的指标，如：工作业绩、工作态度、工作能力…。</li><li>确定评语集，评判的结果，如：优秀、良好、一般…。</li><li>确定各因素权重，可使用层次分析法和熵权法来确定权重。</li><li>确定模糊综合判断矩阵，横坐标是评语集，纵坐标是因素集，填数据。</li><li>模糊综合评判。矩阵乘法，权重乘综合判断矩阵。</li></ol><p>多级模糊综合评价就是对某一因素进行一级模糊综合评价后的结果替换成本级的模糊综合判断矩阵的一行。</p><p>模糊综合评价可以采用SPSSPRO。</p><h3 id="灰色关联分析">灰色关联分析</h3><p><strong>基本思想</strong></p><p>根据序列曲线几何形状的相似程度来判断其联系是否紧密。</p><p><strong>关联分析步骤</strong></p><ol><li><p>确定母系列。</p></li><li><p>确定子系列。</p></li><li><p>数据预处理，采用除以均值的办法去量纲。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908155457464.png" alt="image-20240908155457464"></p></li><li><p>计算灰色关联度。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908155524200.png" alt="image-20240908155524200"></p></li><li><p>计算关联度。取均值。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908155617571.png" alt="image-20240908155617571"></p></li></ol><p><strong>灰色关联综合评价基本步骤</strong></p><ol><li>数据正向化处理</li><li>数据预处理。除均值。</li><li>构造母序列。取最大值。</li><li>计算关联系数。</li><li>计算关联度。</li><li>计算指标权重。将关联度归一化。</li><li>计算得分并归一化。</li></ol><h3 id="主成分分析">主成分分析</h3><p><strong>基本原理</strong></p><p>主成分分析是对于原先提出的所有变量，将重复的变量删除，并建立尽可能少的新变量，使新变量两两不相关，且新变量在反映课题信息方面尽可能保持原有的信息。是一种<strong>数据降维</strong>的方法。</p><p>由于对新变量的解释比较困难且有争议，故不建议使用。</p><p><strong>降维的几何意义可以理解为旋转坐标系，取前k个轴作为新特征。</strong></p><p><strong>基本步骤</strong></p><ol><li><p>标准化处理。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908173038177.png" alt="image-20240908173038177"></p></li><li><p>计算协方差矩阵。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908173107315.png" alt="image-20240908173107315"></p></li><li><p>计算R的特征值和特征向量。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908173135348.png" alt="image-20240908173135348"></p></li><li><p>计算主成分贡献率以及累计贡献率。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908173223858.png" alt="image-20240908173223858"></p></li><li><p>写出主成分。</p><p><img src="/2024/09/06/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1-%E5%BB%BA%E6%A8%A1%E6%89%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240908173245263.png" alt="image-20240908173245263"></p></li><li><p>分析主成分意义</p></li><li><p>进行后续分析</p><ul><li>主成分得分，即综合评价。</li><li>聚类分析。</li><li>回归分析。</li></ul></li></ol><h2 id="运筹优化">运筹优化</h2><h3 id="线性规划">线性规划</h3><p><strong>三要素</strong></p><ul><li>决策变量</li><li>目标函数</li><li>约束条件</li></ul><p><strong>建立步骤</strong></p><ol><li>找到决策变量。</li><li>确定目标函数。</li><li>确定约束条件，需要注意变量定义域这种隐藏约束条件。</li></ol><h3 id="蒙特卡罗法">蒙特卡罗法</h3><p><strong>定义</strong></p><p>又称统计模拟法，是一种随机模拟方法。原理：由大数定理可知，当样本容量足够大时，事件的发生频率即为其概率。</p><p>这里我们要学习其<strong>思想</strong>：只要求解的问题与概率模型有关联，就可以采用蒙特卡洛法。</p><h3 id="非线性规划">非线性规划</h3><p>含非线性函数的目标规划问题</p><h3 id="整数和01规划">整数和01规划</h3><p>解是整数的情况，01规划是特殊的整数规划。采用matlab的intlinprog求解。</p><h3 id="最大最小化规划">最大最小化规划</h3><p>使某个最大值最小的策略，如供应中心选址，目的不是为了到达所有需供应点的距离之和最短，不然可能出现离某个需供应点的距离很长，目的是为了到达所有需供应点的距离最大值最小。</p><p>采用matlab的fminimax函数求解。</p><h3 id="多目标规划">多目标规划</h3><p>常用的解决方法</p><ul><li>线性加权法：给不同目标赋权，化为单目标规划。<ul><li>线性加权需要将多个目标函数统一为最大化和最小化，并且标准化。</li><li>敏感度分析是加分点。</li></ul></li><li>约束法：将其中的目标转化为约束条件，化为单目标规划。</li><li>理想点法：以每个单目标的最优值为该目标的理想值，使每个目标函数值与理想值的差的加权平方和最小。</li><li>优先级法</li></ul><h3 id="动态规划">动态规划</h3><h3 id="图论">图论</h3><ul><li>邻接矩阵</li></ul><h3 id="最短路径">最短路径</h3><ul><li>dijkstra算法（单源）：找最近的点。</li><li>floyd算法（任意两点）：三层循环，动态规划遍历。</li></ul><h3 id="最小生成树">最小生成树</h3><ul><li>prim算法（适合边多点少）：从邻接的边中找能连接新点的最小的边。</li><li>kruskal算法（适合点多边少）：有一个边集，找全局最小的边且加入边集不形成回路。</li></ul><h2 id="启发式算法">启发式算法</h2><p>求NP-hard组合优化的可行解。</p><h3 id="模拟退火算法">模拟退火算法</h3><p><strong>基本思想</strong></p><blockquote><p>统计力学表明材料中粒子的不同结构对应于粒子的不同能量水平。在高温条件下，粒子的能量较高，可以自由运动和重新排列。在低温条件下，粒子能量较低。<br>如果从高温开始，非常缓慢地降温（这个过程被称为退火），粒子就可以在每个温度下达到热平衡。当系统完全被冷却时，最终形成处于低能状态的晶体。</p></blockquote><p>为了不被局部最优解困住，需要以一定概率跳出当前位置，暂时接受一个不太好的解。在搜索最优解的过程中逐渐降温，初期跳出去的概率比较大，进行广泛搜索；后期跳出去的概率比较小，尽量收敛到较优解。</p><p><strong>基本步骤</strong></p><ol><li>随机生成一个初始解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>，设定一个初始温度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>。</li><li>生成新解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，对比新解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和旧解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>。<ul><li>若新解更好，则接受。</li><li>若新解更差，则以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><mi>f</mi><mo stretchy="false">(</mo><msup><mi>x</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mi>T</mi></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">e^{-\frac{f(x&#x27;)-f(x)}{T}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1942em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1942em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1875em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span style="top:-3.2255em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.5021em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9596em;"><span style="top:-2.9596em;margin-right:0.1em;"><span class="pstrut" style="height:2.5556em;"></span><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span>概率接受。</li></ul></li><li>降温（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>减少）并重复以上步骤，直至迭代一定次数。</li></ol><p><strong>重点</strong></p><ul><li>初始解的生成。</li><li>初始温度，降温方式的选择。</li><li>新解的构造。</li></ul><h3 id="遗传算法">遗传算法</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode刷题笔记</title>
    <link href="/2024/04/17/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/04/17/leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV13g41157hK?p=1">出圈了！讲课之外我们来聊聊算法和数据结构！以及未来！_哔哩哔哩_bilibili</a></p><h1>leetcode刷题笔记</h1><h2 id="复杂度和简单排序">复杂度和简单排序</h2><h3 id="复杂度">复杂度</h3><ul><li>运行时间与数据量无关的操作叫做常数操作。如：数据索引，比较操作，交换操作，乘法操作，位运算等。但常数操作的时间也可能不同，乘法操作的时间就会大于位运算时间。</li><li>时间复杂度关注最高阶，因为当数据量足够大时，低阶可以忽视，高阶才是瓶颈。</li><li>评估算法流程，先看时间复杂度，再看实际运行时间。</li></ul><h3 id="简单排序（O-N-2-）">简单排序（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>）</h3><ul><li><p>选择排序：每次循环找到最大的数，置于数组尾部。</p></li><li><p>冒泡排序：每次比较相邻的两个数，一次循环将本次循环最大的数排到数组尾。</p></li><li><p>异或</p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>⊕</mo><mi>N</mi><mo>=</mo><mi>N</mi><mo separator="true">;</mo><mi>N</mi><mo>⊕</mo><mi>N</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0\oplus N=N ;N\oplus N=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo separator="true">;</mo><mi>a</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>b</mi><mo>⊕</mo><mi>c</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊕</mo><mi>b</mi><mo stretchy="false">)</mo><mo>⊕</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a\oplus b=b \oplus a;a \oplus (b \oplus c)=(a \oplus b) \oplus c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></p></li><li><p>同一堆数异或的结果相同，与异或的先后顺序无关。</p></li><li><pre><code class="language-java">//swap a,ba=a^b;b=a^b;a=a^b;<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs gams"><br>    **注意**：这种写法比较取巧，如果a和b的值相同，那么a和b都会变成<span class="hljs-number">0</span>了。若要使用这个交换，必须保证<span class="hljs-symbol">$</span>a<span class="hljs-symbol">$</span>和<span class="hljs-symbol">$</span>b<span class="hljs-symbol">$</span>不一样。<br><br><span class="hljs-comment">* 面试题:star:</span><br><br>  <span class="hljs-number">1.</span> 有n个数，其中只有一种数出现了奇数次，其余数字都出现了偶数次，如何寻找这种数。<br><br>     全部异或得出的结果则是出现奇数次的数。<br><br>  <span class="hljs-number">2.</span> 有n个数，其中有两种数字出现了奇数次，其余数字都出现了偶数次，如何寻找这两种数。:red_circle:<br><br>     ~~把每种数字n映射为<span class="hljs-number">1</span>&lt;&lt;n，再全部异或，得到的数是一个含两个<span class="hljs-number">1</span>的二进制数~~<br><br>     假设这两种数是a和b，全部异或的结果<span class="hljs-symbol">$</span>eor=a \oplus b<span class="hljs-symbol">$</span>不等于<span class="hljs-number">0</span>，则<span class="hljs-symbol">$</span>eor<span class="hljs-symbol">$</span>上至少有一位不为<span class="hljs-number">0</span>，这一位要么是<span class="hljs-symbol">$</span>a<span class="hljs-symbol">$</span>提供的，要么是<span class="hljs-symbol">$</span>b<span class="hljs-symbol">$</span>提供的，由此可将这堆数分为两类：该位是<span class="hljs-number">0</span>和该位是<span class="hljs-number">1</span>（相当于把a和b分开了）。这样就变成了第一个问题，分别对这两类全部异或即得<span class="hljs-symbol">$</span>a<span class="hljs-symbol">$</span>和<span class="hljs-symbol">$</span>b<span class="hljs-symbol">$</span>。<br><br>     ```java<br>     int eor =<span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> ( int i =<span class="hljs-number">0</span> ; i &lt; arr.length;i++)&#123;<br>         eor ^=arr[i];<br>     &#125;<br>     <span class="hljs-comment">//我自己想到 int rightOne = eor &amp; (eor - 1) ^ eor ;</span><br>     int rightOne = eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取最右边的1,~eor + 1 是补码</span><br>     <br>     int onlyOne = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (int cur: arr)&#123;<br>         <span class="hljs-keyword">if</span> ((cur &amp; rightOne)==<span class="hljs-number">1</span>)&#123;<br>             onlyOne^=cur;<br>         &#125;<br>     &#125;<br>     <br>     <span class="hljs-keyword">System</span>.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span>+ (eor ^ onlyOne));<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>插入排序：类似打牌时摸牌的时候，将新加入的牌放入有序的牌中的一个位置就可以。</p><ul><li>插入排序的耗时与数据状态有关，进行的常数操作有可能多，有可能少。而选择排序和冒泡排序与数据状态无关，进行的常数操作是一样的。</li><li>但仍插入排序的时间复杂度仍算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，我们算法上按最差来看。</li></ul></li></ul><h4 id="二分法的详解与扩展">二分法的详解与扩展</h4><ol><li><p>有序数组中寻找某一个数是否存在。</p><p>二分！时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，就是N除以多少次2变成1(考虑最差情况)。</p></li><li><p>在一个有序数组中，找大于等于某个数最左侧的位置</p><p>如数组是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1,2,2,2,3,3,3,3,4,4,4,4,5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span></span></span></span>，找&gt;=num的最左侧数字的位置。每次循环，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>+</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">mid=(left+right)/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mord">/2</span></span></span></span></p><ul><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">arr[mid]&gt;=num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">rr</span><span class="mopen">[</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">right=mid-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">arr[mid]&lt;num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">rr</span><span class="mopen">[</span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">left=mid+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">mi</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li><li>left&gt;right时，跳出循环</li></ul><p>最后的mid值就是所求位置。</p></li><li><p>局部最小值问题：数组无序，任何两个相邻的数一定不相等，寻找任意一个局部最小值（可证明一定存在一个局部最小值），时间复杂度优于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p><p>二分思路，找一个谷底，上坡就往左边走，下坡就往右边走。</p></li></ol><h3 id="对数器">对数器</h3><p>就是对拍，用一个暴力的，复杂度高的算法来求解，用自己写的优化算法求解正确答案。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode24-04</title>
    <link href="/2024/04/01/leetcode24-04/"/>
    <url>/2024/04/01/leetcode24-04/</url>
    
    <content type="html"><![CDATA[<h1>leetcode24-04</h1><h2 id="2810-故障键盘"><a href="https://leetcode.cn/problems/faulty-keyboard/">2810. 故障键盘</a></h2><blockquote><p>你的笔记本键盘存在故障，每当你在上面输入字符 <code>'i'</code> 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。</p><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，请你用故障键盘依次输入每个字符。</p><p>返回最终笔记本屏幕上输出的字符串。</p></blockquote><ul><li><p>个人思路</p><p>很直白</p></li><li><p>官解</p><ul><li><p>双端队列</p><p>翻转可以看作是原本是从左往右变成从右往左了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">finalString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    q := []<span class="hljs-type">rune</span>&#123;&#125;<br>head := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> ch != <span class="hljs-string">&#x27;i&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> head &#123;<br>q = <span class="hljs-built_in">append</span>([]<span class="hljs-type">rune</span>&#123;ch&#125;, q...)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, ch)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>head = !head<br>&#125;<br>&#125;<br>    <span class="hljs-keyword">if</span> head &#123;<br>        reverse(q)<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(q)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(arr []<span class="hljs-type">rune</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>; i &lt; j; i, j = i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span> &#123;<br>        arr[i], arr[j] = arr[j], arr[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习笔记</title>
    <link href="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>机器学习笔记</h1><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">fengdu78/Coursera-ML-AndrewNg-Notes: 吴恩达老师的机器学习课程个人笔记 (github.com)</a></p><h2 id="引言">引言</h2><ul><li>让机器自己学习怎么来解决问题。</li><li>应用背景：几乎各个领域<ul><li>大量web点击流数据，推荐算法</li><li>AI领域：自然语言处理，计算机视觉</li><li>计算生物学，基因工程</li></ul></li></ul><h3 id="机器学习是什么？">机器学习是什么？</h3><ul><li>samuel定义：进行特定的编程，让计算机拥有学习能力。</li><li>Tom Mitchell定义：个程序被认为能从经验<strong>E</strong>中学习，解决任务<strong>T</strong>，达到性能度量值<strong>P</strong>，当且仅当，有了经验<strong>E</strong>后，经过<strong>P</strong>评判，程序在处理T时的性能有所提升。</li><li>主要分为<strong>监督学习</strong>和<strong>无监督学习</strong>。简单来说，监督学习中我们会教计算机如何去完成任务，而在无监督学习中，我们打算让他自己学习。</li></ul><h3 id="监督学习">监督学习</h3><blockquote><p>前阵子，一个学生从波特兰俄勒冈州的研究所收集了一些房价的数据。你把这些数据画出来，看起来是这个样子：横轴表示房子的面积，单位是平方英尺，纵轴表示房价，单位是千美元。那基于这组数据，假如你有一个朋友，他有一套750平方英尺房子，现在他希望把房子卖掉，他想知道这房子能卖多少钱。<img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2d99281dfc992452c9d32e022ce71161.png" alt="img"></p></blockquote><ul><li><p>可以通过寻找一根直线或者二次方程去拟合数据。</p></li><li><p>回归问题：推测出一个连续值的结果。这里即房子的价格。</p></li><li><p>分类问题：判断目标的类别。</p></li><li><p>训练集的特征数（维数）可以是无限的，理论上越多对训练结果越好，但如何存储无限多维数的数据呢，内存不是无限的，需要用到一个技术：<strong>支持向量机</strong>。</p></li><li><p>监督学习：每个样本都有相应的正确答案，根据这些样本做出预测。</p></li></ul><h3 id="无监督学习">无监督学习</h3><ul><li>无监督学习中没有标签，研究聚类问题。<ul><li>可应用于特定基因的查找。</li><li>大数据推送，将人群分类。利于市场分割，更高效的推送广告。</li></ul></li></ul><h2 id="单变量线性回归">单变量线性回归</h2><h3 id="模型展示">模型展示</h3><blockquote><p>预测住房价格的，我们要使用一个数据集，数据集包含俄勒冈州波特兰市的住房价格。在这里，我要根据不同房屋尺寸所售出的价格，画出我的数据集。比方说，如果你朋友的房子是1250平方尺大小，你要告诉他们这房子能卖多少钱。那么，你可以做的一件事就是构建一个模型，也许是条直线，从这个数据模型上来看，也许你可以告诉你的朋友，他能以大约220000(美元)左右的价格卖掉这个房子。</p></blockquote><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331190951081.png" alt="image-20240331190951081"></p><h3 id="代价函数">代价函数</h3><ul><li>即损失函数，模型训练中要使损失函数的值越小越好。</li></ul><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331191301600.png" alt="image-20240331191301600"></p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331191325858.png" alt="image-20240331191325858"></p><h3 id="梯度下降">梯度下降</h3><ul><li><p>用于计算使损失函数最小的算法。</p></li><li><p><strong>梯度下降背后的思想</strong>是：开始时我们随机选择一个参数的组合，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到到到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331191533757.png" alt="image-20240331191533757"></p></li><li><p>学习率决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大。在<strong>批量梯度下降</strong>（公式如下）中，我们每一次都同时让所有的参数减去学习速率乘以代价函数的导数。</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331191735249.png" alt="image-20240331191735249"></p><ul><li>学习率太小会导致需要很多次才能到达全局最低点。</li><li>学习率太大会导致可能越过最低点，无法收敛。</li></ul></li><li><p>可以想象，合适的学习率将使代价函数达到局部最低点，在最低点处，偏导的值为0，故不会改变参数的值，保持在局部最低点。</p></li></ul><h3 id="梯度下降的线性回归">梯度下降的线性回归</h3><ul><li><strong>批量梯度下降</strong>：指每次梯度下降中，我们用到了所有的训练样本。</li><li><strong>正规方程</strong>：使用线性代数的方式计算损失函数的最小值。</li></ul><h2 id="线性代数回顾">线性代数回顾</h2><h3 id="矩阵乘法的性质">矩阵乘法的性质</h3><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331200114921.png" alt="image-20240331200114921"></p><h2 id="多变量线性回归">多变量线性回归</h2><h3 id="多维特征">多维特征</h3><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331200831893.png" alt="image-20240331200831893"></p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331200902595.png" alt="image-20240331200902595"></p><h3 id="多变量梯度下降">多变量梯度下降</h3><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331200934906.png" alt="image-20240331200934906"></p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331200958064.png" alt="image-20240331200958064"></p><h3 id="梯度下降实践-特征缩放">梯度下降实践-特征缩放</h3><ul><li><p>保证特征具体相近的尺度，令梯度下降算法更快的收敛。</p></li><li><p>一种简单的方法：</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331201146995.png" alt="image-20240331201146995"></p></li></ul><h3 id="梯度下降法实践-学习率">梯度下降法实践-学习率</h3><ul><li>过小，迭代次数过多；过大，可能无法收敛。</li></ul><h3 id="特征和多项式回归">特征和多项式回归</h3><ul><li><p>即假设函数的设置上采用多项式曲线，如：</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331201622158.png" alt="image-20240331201622158"></p></li></ul><h3 id="正规方程">正规方程</h3><ul><li><p>解出偏导为0的点，解特征方程，特征矩阵那些。</p></li><li><p>当特征变量的数目不大时（小于10000），标准方程是一个很好的代替梯度下降的方法。</p></li></ul><h3 id="正规方程及不可逆性">正规方程及不可逆性</h3><h2 id="Octave教程">Octave教程</h2><h2 id="逻辑回归">逻辑回归</h2><h3 id="分类问题">分类问题</h3><ul><li>二元分类：正向类（值为1）和负向类（值为0）。</li></ul><h3 id="假说表示">假说表示</h3><ul><li><p>假设函数的预测值应在0到1之间。</p></li><li><p>sigmoid函数：计算的结果表示x是正向类的概率。</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240331202729783.png" alt="image-20240331202729783"></p></li></ul><h3 id="判定边界">判定边界</h3><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410135940857.png" alt="image-20240410135940857"></p><h3 id="代价函数-2">代价函数</h3><ul><li><p>在线性回归模型中，我们定义的代价函数是所有模型误差的平方和。而逻辑回归模型沿用这个代价函数时，将是一个非凸函数（non-convex）。</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410140336643.png" alt="image-20240410140336643"></p><p>这意味着许多局部最小值，将影响梯度下降算法寻找全局最小值。</p><blockquote><p>线性回归和逻辑回归都是机器学习中常用的回归分析模型，但它们之间存在一些关键的区别。</p><p><strong>1. 因变量类型</strong></p><p>线性回归用于预测连续的因变量，例如房价、身高、体重等。而逻辑回归用于预测离散的因变量，例如是否患病、是否点击广告等。</p><p><strong>2. 模型函数</strong></p><p>线性回归模型的函数形式为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">y = <span class="hljs-keyword">b0 </span>+ <span class="hljs-keyword">b1x1 </span>+ <span class="hljs-keyword">b2x2 </span>+ ... + <span class="hljs-keyword">bnxn</span><br></code></pre></td></tr></table></figure><p>其中，y是因变量，x1、x2、…、xn是自变量，b0、b1、…、bn是模型参数。</p><p>逻辑回归模型的函数形式为：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">p = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + exp(<span class="hljs-name">-</span>(<span class="hljs-name">b0</span> + b1x1 + b2x2 + ... + bnxn)))<br></code></pre></td></tr></table></figure><p>其中，p是因变量的概率，x1、x2、…、xn是自变量，b0、b1、…、bn是模型参数。</p><p>从模型函数可以看出，线性回归是自变量和因变量之间的线性关系，而逻辑回归是自变量和因变量之间的非线性关系。</p><p><strong>3. 参数估计方法</strong></p><p>线性回归的参数估计方法是<strong>最小二乘法</strong>，通过最小化误差平方和来求解参数值。</p><p>逻辑回归的参数估计方法是<strong>最大似然法</strong>，通过最大化似然函数来求解参数值。</p><p><strong>4. 应用场景</strong></p><p>线性回归常用于预测、拟合等场景，例如预测房价、拟合曲线等。</p><p>逻辑回归常用于分类、判别等场景，例如判断是否患病、判断是否点击广告等。</p><p><strong>总结</strong></p><p>线性回归和逻辑回归都是机器学习中常用的回归分析模型，它们的区别主要体现在因变量类型、模型函数、参数估计方法和应用场景等方面。</p></blockquote><p>也就是说，线性回归的y值是任意值，而逻辑回归的y值是离散的（0或1）。</p></li><li><p>逻辑回归的代价函数可以这样定义</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410140925572.png" alt="image-20240410140925572"></p><p>进一步化简，得</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410140958825.png" alt="image-20240410140958825"></p></li><li><p>除了梯度下降算法，还有共轭梯度，局部优化法等等。</p></li></ul><h3 id="简化的成本函数和梯度下降">简化的成本函数和梯度下降</h3><ul><li><p>线性回归的假设函数</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410141333487.png" alt="image-20240410141333487"></p><p>逻辑函数的假设函数</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410141350551.png" alt="image-20240410141350551"></p></li><li><p>但两者的梯度下降都是</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410141419482.png" alt="image-20240410141419482"></p></li></ul><h3 id="高级优化">高级优化</h3><ul><li><strong>共轭梯度法 BFGS</strong> (<strong>变尺度法</strong>) 和<strong>L-BFGS</strong> (<strong>限制变尺度法</strong>)可以通过线性搜索来自动尝试不同的学习速率，令梯度下降收敛更快。</li></ul><h3 id="多类别分类">多类别分类</h3><ul><li><p>类别有多个，训练方法：可以创建新的“训练集”，令类型1为正样本，其他样本为负样本。</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410142134344.png" alt="image-20240410142134344"></p><p>然后训练出一个分类器。类似的以此将不同类别作正样本，其他类别作负样本来训练，可得到不同的模型。</p><p>最后，当我们需要预测时，可以将x输入到不同的分类器模型中，取其中得分（预测概率）最高的就可以认为是那个模型的正样本类别。比如上图我们可得到三角形分类模型（指三角形作为正样本）、叉形分类模型、正方形分类模型，当需要预测新的数据时，看这三个模型谁的得分高就是谁。</p></li></ul><h2 id="正则化">正则化</h2><h3 id="过拟合问题">过拟合问题</h3><ul><li><p>如价格预测问题中</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410143024332.png" alt="image-20240410143024332"></p><p>第一个模型是线性模型，欠拟合；第二个模型比较符合价格规模；第三个模型则过拟合了（观察最右端，size越大price反而下降，这显然不合理）。</p><p>也就是训练效果很好，但预测效果很差时，就可能发生过拟合问题了。</p></li><li><p>分类问题也存在过拟合</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410143309809.png" alt="image-20240410143309809"></p></li><li><p>两种处理思路</p><ul><li>丢弃极端数据，可以手工去除，也可以使用一些模型选择的算法（如PCA）</li><li>正则化。保留所有特征，但减少参数大小</li></ul></li></ul><h3 id="代价函数-3">代价函数</h3><ul><li><p>如回归问题中我们的模型是四次函数，可以发现是高次项导致了过拟合，所以我们要让这些高次项的系数接近于0，对他们设置惩罚，这就是正则化。如设置代价函数如下，</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410143702439.png" alt="image-20240410143702439"></p></li><li><p>当我们有许多特征时，不知道要惩罚哪些特性，那就全部惩罚一遍，让代价函数最优化来选择不同特征的惩罚程度，如</p><p><img src="/2024/03/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240410144123424.png" alt="image-20240410144123424"></p></li></ul><h3 id="正则化线性回归">正则化线性回归</h3><h3 id="正则化逻辑回归">正则化逻辑回归</h3><h2 id="神经网络">神经网络</h2><h3 id="非线性假设">非线性假设</h3><ul><li><p>非线性的假设有时能产生更好的效果，但特征很多时，即使是两两组合也是十分庞大的数据量。</p></li><li><p>有的特征数量会很大，比如将图片上的每个像素RGB，饱和度或者亮度作为特征，普通的逻辑回归模型不能有效处理这么多的特征，需要<strong>神经网络</strong>。</p></li></ul><h3 id="神经元和大脑">神经元和大脑</h3><ul><li>神经重接实验：将从眼睛到视神经的信号传到听觉皮层，动物的听觉皮层也会学会“看”。可以猜想，存在一种学习算法，可以学习任何事物，而不是对不同事物编写不同的学习程序。</li><li>BrainPort：在前额上带一个灰度摄像头，面朝前，它就能获取你面前事物的低分辨率的灰度图像。你连一根线到舌头上安装的电极阵列上，那么每个像素都被映射到你舌头的某个位置上，可能电压值高的点对应一个暗像素电压值低的点。对应于亮像素，即使依靠它现在的功能，使用这种系统就能让你我在几十分钟里就学会用我们的舌头“看”东西。</li><li>大脑的神奇：没有眼球的人可以通过打响指的回声来判断与物体的距离；通过一种触觉皮带，面朝北时就会触动，久而久之，可以使人拥有方向感（即使取下皮带），和鸟类一样；在青蛙身上插入第三只眼，青蛙也能使用第三只眼。</li></ul><h3 id="模型表示">模型表示</h3><ul><li><p>神经网络模型建立在很多神经元（也叫激活单元，<strong>activation unit</strong>）之上，每一个神经元就是一个个学习模型。</p></li><li><p>逻辑上可分为输入层，隐藏层，输出层。为每一层增加一个偏差单位。</p><blockquote><p>假设一个神经元的输入都是零，那么该神经元的输出也将为零。在这种情况下，神经元无法学习到任何与输入无关的信息。偏差单位的存在可以使神经元在不考虑任何输入的情况下输出一个非零值，从而使神经元能够学习到与输入无关的信息。</p></blockquote></li></ul><h3 id="特征和直观理解">特征和直观理解</h3><h3 id="多类分类">多类分类</h3><ul><li>假如有四个类别，可以令输出层有四个神经元用来表示4类，但这四个神经元中仅有一个值为1，其他均为0来表示类别的判断。</li></ul><h2 id="神经网络的学习">神经网络的学习</h2><h3 id="代价函数-4">代价函数</h3><h3 id="反向传播算法">反向传播算法</h3><h3 id="反向传播算法的直观理解">反向传播算法的直观理解</h3><h3 id="实现注意：展开参数">实现注意：展开参数</h3><h3 id="梯度检验">梯度检验</h3><h3 id="随机初始化">随机初始化</h3><h3 id="总结">总结</h3><p>训练神经网络：</p><ol><li>参数的随机初始化</li><li>利用正向传播方法计算所有的假设函数</li><li>编写计算代价函数的代码</li><li>利用反向传播方法计算所有偏导数</li><li>利用数值检验方法检验这些偏导数</li><li>使用优化算法来最小化代价函数</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>吴恩达</category>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>吴恩达</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode24-03</title>
    <link href="/2024/03/18/leetcode24-03/"/>
    <url>/2024/03/18/leetcode24-03/</url>
    
    <content type="html"><![CDATA[<h1>leetcode24-03刷题笔记</h1><h2 id="303-区域和检索-数组不可变"><a href="https://leetcode.cn/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h2><blockquote><p>给定一个整数数组  <code>nums</code>，处理以下类型的多个查询:</p><ol><li>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的 <strong>总和</strong> ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li></ul></blockquote><ul><li><p>个人思路</p><p>简简又单单，前缀和。但忘记怎么用go语言了。</p></li><li><p>官解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    sums []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> NumArray &#123;<br>    sums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sums[i+<span class="hljs-number">1</span>] = sums[i] + v<br>    &#125;<br>    <span class="hljs-keyword">return</span> NumArray&#123;sums&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(na *NumArray)</span></span> SumRange(i, j <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> na.sums[j+<span class="hljs-number">1</span>] - na.sums[i]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1969-数组元素的最小非零乘积"><a href="https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/">1969. 数组元素的最小非零乘积</a></h2><blockquote><p>给你一个正整数 <code>p</code> 。你有一个下标从 <strong>1</strong> 开始的数组 <code>nums</code> ，这个数组包含范围 <code>[1, 2p - 1]</code> 内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong> 次：</p><ul><li>从 <code>nums</code> 中选择两个元素 <code>x</code> 和 <code>y</code> 。</li><li>选择 <code>x</code> 中的一位与 <code>y</code> 对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong> 的二进制位。</li></ul><p>比方说，如果 <code>x = 1101</code> 且 <code>y = 0011</code> ，交换右边数起第 <code>2</code> 位后，我们得到 <code>x = 1111</code> 和 <code>y = 0001</code> 。</p><p>请你算出进行以上操作 <strong>任意次</strong> 以后，<code>nums</code> 能得到的 <strong>最小非零</strong> 乘积。将乘积对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p>**注意：**答案应为取余 <strong>之前</strong> 的最小值。</p></blockquote><ul><li><p>个人思路</p><p>让元素尽可能变成1？~~对应位置的交换可以看成两个数一加一减一个2的倍数的数。~~错误的，只能是对应位置交换，另一个数有4了就不能交换了。</p><p>直觉上来说，从大往小遍历奇数（奇数减偶数才有可能得1，不会减1的），并且加的数要加到小的数上去，这样才能让数均衡。</p></li><li><p>官解</p><ul><li><p>贪心</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minNonZeroProduct</span><span class="hljs-params">(p <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    mod := <span class="hljs-type">int64</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>    x := fastPow(<span class="hljs-number">2</span>, <span class="hljs-type">int64</span>(p), mod) - <span class="hljs-number">1</span><br>    y := <span class="hljs-type">int64</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-type">uint</span>(p - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(fastPow(x - <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>, mod) * x % mod)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fastPow</span><span class="hljs-params">(x, n, mod <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    res := <span class="hljs-type">int64</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> n &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br>            res = (res * x) % mod<br>        &#125;<br>        x = (x * x) % mod<br>        n &gt;&gt;= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="331-验证二叉树的前序序列化"><a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化</a></h2><blockquote><p>序列化二叉树的一种方法是使用 <strong>前序遍历</strong> 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><p><img src="/2024/03/18/leetcode24-03/pre-tree.jpg" alt="img"></p><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>'#'</code> 。</p><p>你可以认为输入格式总是有效的</p><ul><li>例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</li></ul><p>**注意：**不允许重建树。</p></blockquote><ul><li><p>个人思路</p><p>消消乐，顺序读入，当遇到两个连续的#号<code>##</code>时，就将<code>##</code>和之前的一个数字变成<code>#</code>（<code>##</code>前面一定是数字，不是则错误），最后看是否只剩一个<code>#</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>item := strings.Split(preorder, <span class="hljs-string">&quot;,&quot;</span>)<br>stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(item))<br>isSharp := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(item); i++ &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, item[i])<br><span class="hljs-comment">// fmt.Println(stack)</span><br><span class="hljs-keyword">for</span> slen := <span class="hljs-built_in">len</span>(stack); isSharp == <span class="hljs-literal">true</span> &amp;&amp; stack[slen<span class="hljs-number">-1</span>] == <span class="hljs-string">&quot;#&quot;</span>; slen = <span class="hljs-built_in">len</span>(stack) &#123;<br><span class="hljs-keyword">if</span> slen &lt; <span class="hljs-number">3</span> || stack[slen<span class="hljs-number">-3</span>] == <span class="hljs-string">&quot;#&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stack = stack[:slen<span class="hljs-number">-3</span>]<br>stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-string">&quot;#&quot;</span>)<br>slen = <span class="hljs-built_in">len</span>(stack)<br><span class="hljs-keyword">if</span> slen &gt; <span class="hljs-number">2</span> &amp;&amp; stack[slen<span class="hljs-number">-2</span>] == <span class="hljs-string">&quot;#&quot;</span> &#123;<br>isSharp = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>isSharp = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// fmt.Println(stack)</span><br>&#125;<br>&#125;<br>slen := <span class="hljs-built_in">len</span>(stack)<br><span class="hljs-keyword">if</span> stack[slen<span class="hljs-number">-1</span>] == <span class="hljs-string">&quot;#&quot;</span> &#123;<br>isSharp = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>isSharp = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">1</span> &amp;&amp; stack[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;#&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>栈</p><p>思路一样，但官解思路更优，用int数组处理，记录的是槽位</p><blockquote><p>我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p><p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p><p>如果遇到了空节点，则要消耗一个槽位；</p><p>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(preorder)<br>    stk := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>            stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]--<br>            <span class="hljs-keyword">if</span> stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                stk = stk[:<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]<br>            &#125;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读一个数字</span><br>            <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>                i++<br>            &#125;<br>            stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]--<br>            <span class="hljs-keyword">if</span> stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                stk = stk[:<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]<br>            &#125;<br>            stk = <span class="hljs-built_in">append</span>(stk, <span class="hljs-number">2</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stk) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计数</p><p>进一步优化，用一个变量表示槽位即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(preorder)<br>    slots := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br>        <span class="hljs-keyword">if</span> slots == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>            slots--<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读一个数字</span><br>            <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>                i++<br>            &#125;<br>            slots++ <span class="hljs-comment">// slots = slots - 1 + 2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slots == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于同态加密的行为生物特征认证机制研究学习记录</title>
    <link href="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>基于同态加密的行为生物特征认证机制研究学习记录</h1><h2 id="文献">文献</h2><h3 id="AuthentiSense-A-Scalable-Behavioral-Biometrics-Authentication-Scheme-using-Few-Shot-Learning-for-Mobile-Platforms"><strong>AuthentiSense: A Scalable Behavioral Biometrics Authentication Scheme using Few-Shot Learning for Mobile Platforms.</strong></h3><p><a href="https://dblp.org/rec/conf/ndss/FereidooniKRCGF23.html">dblp: AuthentiSense: A Scalable Behavioral Biometrics Authentication Scheme using Few-Shot Learning for Mobile Platforms.</a></p><h4 id="摘录">摘录</h4><ul><li>传统认证（指纹，脸部，虹膜）不安全，可被窃取复制，且不保护对底层设备的访问权限。</li><li>行为生物特征认证机制通过用户持续的与移动设备交互的特征来认证，但目前的认证机制有两点不足：<ul><li>用户有关性，即不能在无预训练的前提下进行认证。</li><li>不能进行大规模的用户认证。</li></ul></li><li>AuthentiSense（以下简称AS）是一个用户无关，高效的可大规模认证机制。</li><li>AS利用<strong>少样本</strong>（3次样本）学习技术，也称<strong>孪生网络</strong>，来实现大规模和用户无关性。</li></ul><h4 id="引言">引言</h4><ul><li>这篇论文中，我们利用的生物行为特性是motion sensor（加速度）。</li><li>现存生物特征认证的缺陷：<ul><li>用户有关性，需要大量训练数据来构建模型。</li><li>不可规模认证，仅能认证限制数量的。</li><li>每个用户都需要一个模型，这很需要资源。</li><li>需要长时间的交互来认证。</li></ul></li><li>AS的目的：<ul><li>高效，不需要特征提取（人工）的模型训练。</li><li>可规模化认证。</li><li>用户无关性，即用户动态变化时，不需要重训练。</li></ul></li><li>AS利用了少样本学习技术，即孪生神经网络。该技术已经被用于现有的生物特性认证，但并未解决规模化认证的问题。</li><li>AS的贡献可总结如下<ul><li>用户无关，大规模认证，少样本学习，不需要大量训练数据。</li><li>建立了端到端的神经网络架构，能够在不重训练的前提下动态处理用户变化。有97%的精准度，能1s完成认证。</li><li>提供了一种评估不同参数影响的可扩展的系统测量方法。</li></ul></li></ul><h4 id="背景知识">背景知识</h4><ul><li>少样本学习</li><li>指用尽量少的训练数据来生成足够精确的模型。</li><li>孪生网络<ul><li>一个孪生网络是两个给定的认证网络架构的串联，两个子网络共享相同的参数（权重和偏差），目的是为了在两个输入样本属于同类时提取相似特征，不属于同类时提取差异特征。</li></ul></li></ul><h4 id="系统和威胁模型">系统和威胁模型</h4><ul><li>我们作出以下假设：<ul><li>认证模型被服务器训练和保存，该服务器是可信任的，这也避免了模型污染。</li><li>攻击方能够威胁用户的移动设备。</li><li>传感器数据是可信任的，被硬件安全技术（ARM TrustZone）所保护。同样，生物认证模块也是被硬件安全技术保护。这意味着即使OS被破坏，攻击方仍无法获取传感器数据。</li><li>不考虑侧道攻击（side-channel attack)。</li><li>传输信道是安全的，由传输安全协议保护，如SSL/TLS。故中间人攻击和重放攻击是无效的。</li></ul></li><li>为了认证一个用户，AS会收集3个数量的注册样本。在初始化后，AS会比较注册样本和用户样本（这里注册样本enrollment理解为认证样本更好，用户样本指的应该是之前保存的样本）。如果两者属于同一个用户，AS会生成内嵌向量，令生成空间中两者的欧氏距离减少，AS还会生成二进制标志‘1’，表示成功。</li><li>当AS生物特征认证失败后，会采用消极认证方式（如密码）来保证安全。</li></ul><h4 id="AuthentiSense">AuthentiSense</h4><h5 id="总览">总览</h5><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240227171637720.png" alt="image-20240227171637720"></p><ul><li>孪生网络：共享权重的子网络，处理输入的用户样本。</li><li>距离函数：计算欧氏距离，可看做向量，增大不同用户的样本的向量距离，减少相同用户的样本所生成的向量距离。</li><li>决策网络：由全连接层组成，进行二元分类。样本属于相同用户则生成1，不同则生成0。</li></ul><h5 id="设计">设计</h5><ul><li>孪生网络：用于提取判别特征。令相同用户样本生成的向量靠近，不同用户样本生成的向量分离。由两个相同的子网络（CNN1D）组成，通过L2泛化将输入数据投射到半径为1的n维立体球上。</li><li>距离函数：计算向量距离，不同用户的距离大，相同用户的距离小。</li><li>决策网络：解决分类。这段文本描述了一个前馈神经网络的设计。该网络包括三个连续的稠密层，每一层的神经元数量逐渐减少，使用ReLU激活函数和L2范数作为核正则化器。前两层之后紧跟着一个批量归一化层，用于调节前一层的激活值，使其均值接近0，标准差接近1。最后一个稠密层之后是一个dropout层，丢失率为0.25，由一个具有sigmoid激活函数的单个单元组成，以保持与伯努利输出分布的一致性。</li><li>保留一部分数据不用于训练，用于测试。</li></ul><h5 id="实现">实现</h5><ul><li><p>样本制备：三元取样</p></li><li><p>模型建立</p><ul><li><p>AuthentiSense的深度学习部分利用了Siamese神经网络（NN）和决策网络。Siamese NN由两个子网络组成，通过组装层（例如Conv1D、Max Pooling1D、Flatten和Dense层）排列在Siamese架构中。然后，两个子网络的输出通过自定义的距离函数（使用Lambda层）传递，如图3所示。最后，我们将决策网络附加到Siamese网络，并通过堆叠全连接的Dense层构建我们的分类器。</p></li><li><p>Siamese NN使用三个连续的卷积层，其滤波器数量逐渐增加（从64到256），从而在深度上扩展数据。最后一层的内核大小减小（从5到3），以进行更精细的计算。由于处理的是非归一化数据，因此在每个卷积层后添加批量标准化层，以规范化输入，从而稳定学习过程并显著减少训练Siamese网络所需的训练周期。此外，每个卷积层都包括一个内核正则化器（L2-范数），其值为10^-3，以防止过拟合。</p></li><li><p>在卷积层之后，使用1维最大池化层对输入表示进行降采样，通过在指定大小的空间窗口上取最大值来实现。然后，将卷积块的输出展平，并传递给最后一个全连接（即密集）层，不使用激活函数，负责生成输入的嵌入表示，作为固定大小的数组（长度为32x1）。</p></li></ul></li><li><p>训练策略</p><ul><li><p>训练过程取决于样本生成策略（即成对或三元组）。对于成对训练，使用对比损失（参见附录A），而对于三元组训练则使用三元组损失。三元组损失同时学习正负距离，并更注重难以区分的负样本，从而减少易于区分的负样本数量。与成对训练相比，这有助于降低过拟合的风险。我们选择三元组训练，因此我们使用三元组损失来训练我们的Siamese网络。三元组损失的目标是确保具有相同标签的两个样本在嵌入空间中彼此靠近，而具有不同标签的两个样本的嵌入则彼此远离。</p></li><li><p>为了训练网络，我们抽样所需批量大小的三元组。顾名思义，需要三个输入样本，分别是：i）锚点，即样本输入数据，ii）正样本，只是锚点的另一个变化，iii）负样本，与上述两个样本不同。这有助于我们的模型学习与锚点样本的不同之处。正样本和负样本分别传递给Siamese网络，因为三元组是在线挖掘的。正如图4所示，网络学习减少锚点和正样本之间的距离，同时增加锚点和负样本之间的距离，以使两个距离的差达到预定义的超参数Alpha α（方程1）。方程1中的alpha参数旨在确保锚点-正样本距离（d(a,p)）和锚点-负样本距离（d(a,n)）的差至少与Alpha相等，以防止模型崩溃到满足方程1的平凡解，其中f(a) = f(p) = f(n)。</p><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240303200145099-17094673061391.png" alt="image-20240303200145099"></p></li><li><p>三元组损失定义如下</p><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240303200231420.png" alt="image-20240303200231420"></p></li><li><p>理论来说，使用困难或中等难度的三元组会使模型训练效果更好，但困难三元组会使模型损坏，坍缩为平凡解。<strong>因此使用中等难度三元组训练。</strong></p></li><li><p>在定义了嵌入三元组的损失并观察到一些三元组比其他三元组更有用，即它们的损失值有助于网络进行更好的权重优化之后，我们选择在线三元组挖掘方法来挖掘三元组。与离线三元组挖掘不同，离线三元组挖掘中数据作为三元组形式的输入传递给网络，而在线三元组挖掘在训练过程中在每个数据批次中计算三元组。**在线挖掘的思想是动态地在每个数据批次中计算有用的三元组。给定一个包含B个样本的批次，它计算B个嵌入，然后可以找到最多B3个三元组，并选择用于训练的半困难三元组。**正如已经描述的，我们使用半困难三元组挖掘来训练网络，因为半困难三元组不像困难三元组那样难以学习，但仍然提供有用的信息。我们采用的挖掘策略是在从随机抽取的样本批次中在线计算三元组，因此无法预先确定三元组的数量。</p></li></ul></li><li><p>端到端模型参数优化</p><p>“端到端模型参数优化”是指在机器学习或深度学习模型中，以统一和整体的方式优化所有参数的过程，从输入层到输出层。这涉及同时调整模型的所有参数，以改善其整体性能，而不是单独优化各个组件。</p><p>在这种方法中，整个模型被视为单个系统，优化过程旨在找到最佳参数组合，以最小化损失函数或最大化奖励函数。这可能涉及使用梯度下降、反向传播或其他优化算法来调整模型的参数。</p><p>端到端参数优化通常用于具有多个相互关联组件的复杂模型，例如深度神经网络。通过优化整个模型的参数，目的是让模型学习为其设计的整个任务的最佳参数组合，考虑模型不同部分之间的交互。这种方法旨在实现更好的性能和整体泛化。</p><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240303201151507.png" alt="image-20240303201151507"></p><ul><li>包含以下步骤：首先，Siamese网络的权重被冻结（它被用作特征提取器），然后完全连接的决策网络被附加到Siamese网络，并使用二元交叉熵损失函数进行训练，以优化网络的权重。</li></ul></li><li><p>超参数微调和网络配置</p><p>在构建模型架构之后，我们采用网格搜索方法并循环遍历预定义的超参数，如表I和表II所示，以选择一组最佳超参数，以最大化模型性能。具体来说，我们调查了关于优化器的选择、学习率、批量大小以及半困难三元组损失函数的边缘值（Alpha）的多个选项。最终，我们选择了最佳性能参数，以最大化模型的性能，如表III和表IV所示，并将它们用于训练我们的网络。</p></li></ul><h4 id="评估">评估</h4><h5 id="数据集">数据集</h5><p>为了进行我们的实验，我们使用了<strong>DAKOTA数据集</strong>[40]，更具体地说，是记录了45个用户在使用手机银行应用时的运动传感器数值（即加速度计、陀螺仪和磁力计）。在这45个用户中，我们随机选择了35个用户进行训练，3个用户作为验证数据以确定分类阈值，还有7个用户用于测试。对每个用户在坐姿、站姿和手机放在桌子上的5种姿势下都进行了数据记录。因此，训练集中的每个用户都有15个90秒长的会话。因此，只需要很少的志愿者用户来训练特征提取器。此外，我们主要关注的是在系统部署后，对新加入的用户提供一种少样本学习的解决方案。我们可以要求志愿者提供我们想要的大量数据。然而，对于真实世界的用户，我们只能期望收集到少量样本（见表V）。由于原始数据的采样频率不是恒定的，每个传感器的起始和结束时间戳也不一致，因此我们对每个会话的传感器数据进行了重新采样，采样率为5毫秒，在数据降采样的区域取平均值，在数据升采样的区域进行线性插值。为了获得样本池，我们对每个记录的会话数据运行了一个固定长度的滑动窗口（1、3、5、10和15秒），步长等于其长度的1/10，并对其进行标记。对于每个窗口，每个运动传感器的每个轴的数值被连接起来形成一个一维数组，以后用于构建正负样本。窗口池然后被洗牌并分成批次，用于训练和测试集，用于Siamese网络。对于决策网络，随机采样了相同用户的窗口对（正样本）和不同用户的窗口对（负样本），生成了50000和10000对，然后分别进行批处理，用于训练和测试。</p><h5 id="评估指标">评估指标</h5><ul><li>FAR</li><li>FRR</li><li>F1-Score</li><li>AUC</li><li>EER</li></ul><h5 id="实验准备">实验准备</h5><h3 id="Challenges-and-Opportunities-of-Biometric-User-Authentication-in-the-Age-of-IoT-A-Survey">Challenges and Opportunities of Biometric User Authentication in the Age of IoT: A Survey.</h3><p>Beijing University of Posts and Telecommunications (BUPT)</p><h2 id="实践">实践</h2><h3 id="安装tensorflow">安装tensorflow</h3><ul><li><p><a href="https://tensorflow.google.cn/install/pip?hl=zh-cn">使用 pip 安装 TensorFlow (google.cn)</a></p></li><li><p>启用长路径无gpedit.msc <a href="https://zhuanlan.zhihu.com/p/403961135">找不到 gpedit.msc 的最优解决办法 - 知乎 (zhihu.com)</a></p><p>[Windows 启用长路径（文件名过长，路径过长）_长路径支持-CSDN博客](<a href="https://blog.csdn.net/weixin_46356818/article/details/121029550#:~:text=Windows">https://blog.csdn.net/weixin_46356818/article/details/121029550#:~:text=Windows</a> 启用长路径支持 1 找到并打开文件（本地组策略编辑器）gpedit.msc win%2Br%3A 输入gpedit.msc,注：若是发现找不到gpedit.msc，点此链接 2 依次点开 计算机配置&gt;管理模板&gt;系统&gt;文件系统，找到“启用win32长路径”并双击打开 选择“启用”选项，然后单击“确定” 退出，重启电脑)</p></li><li><p>windows下cd无法切换盘符</p><p>加<code>/d</code>，如</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /d d:\download\<br></code></pre></td></tr></table></figure></li><li><p>There was a problem confirming the ssl certificate: HTTPSConnectionPoold</p></li></ul><p>关闭vpn</p><p>总结</p><p><a href="https://tensorflow.google.cn/install/pip?hl=zh-cn">使用 pip 安装 TensorFlow (google.cn)</a></p><ol><li><p>安装anaconda</p></li><li><p>安装microsoft c++<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">下载 Visual Studio Tools - 免费安装 Windows、Mac、Linux (microsoft.com)</a></p></li><li><p>管理员打开anaconda prompt</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda create -n tf python=3.8<br>conda activate tf<br>pip install tensorflow-cpu==2.4.0 -i https://pypi.douban/simple<br></code></pre></td></tr></table></figure></li></ol><h3 id="Siamese-tf2-master">Siamese-tf2-master</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple<br>pip install protobuf==3.20.0 -i https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h3 id="AuthtiSense-Demo">AuthtiSense-Demo</h3><h4 id="代码梳理">代码梳理</h4><ul><li><p><code>nets/cnn.py</code></p><p>cnn网络的架构</p></li><li><p><code>nets/decision.py</code></p><p>几个全连接层，用于增大负样本之间的距离，减小正样本之间的距离</p></li><li><p><code>nets/siamese.py</code></p><p>结合cnn网络、距离函数、决策网络</p></li><li><p><code>utils/utils.py</code></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pre_deal_dataset</td><td>去除数据集中末尾的分号和逗号</td></tr><tr><td>feature_normalize</td><td>将数据标准化，减平均数后除以标准差</td></tr><tr><td>load_dataset</td><td>加载数据库，将清洗过后的数据库（去除分号和逗号的数据库）<br>中的数据标准化（使用feature_normalize函数），<br>最后调用segment_signal数据按90条的窗口生成新数据</td></tr><tr><td>windows</td><td>生成数据窗口的起点和终点。程序中按90条的大小半覆盖前进</td></tr><tr><td>segment_signal</td><td>90条数据生成一条新数据，维度是90x3</td></tr><tr><td>doubleGenerator</td><td>将segment_signal函数处理后的数据一正一负生成数据</td></tr><tr><td>devide_dataset</td><td>将数据集分为训练集、验证集和测试集</td></tr><tr><td>contrastive_loss</td><td>计算对比损失</td></tr></tbody></table><p>doubleGenerator产生的数据维数是 [2（样本对）, batch_size, 90, 3]，label</p></li></ul><h4 id="保存和重载模型权重">保存和重载模型权重</h4><p><a href="https://blog.csdn.net/weixin_44048809/article/details/105705272">Keras中使用ModelCheckpoint对训练完成的模型进行保存及载入_modelcheckpoint 保存模型结构-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#callback中使用ModelCheckpoint(filepath=save_dir,monitor=&quot;val_loss&quot;,save_best_only=True,save_weights_only=True,)来保存模型的权重</span><br><span class="hljs-comment"># 载入模型时需要自己构建网络架构，再载入权重</span><br>model=siamese(input_shape)<br>model.load_wights(<span class="hljs-string">&quot;model_data/model.h5&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="理论知识">理论知识</h2><h3 id="7-前向传播整体流程-哔哩哔哩-bilibili"><a href="https://www.bilibili.com/video/BV1FW4y1b7WM?p=10&amp;spm_id_from=pageDriver&amp;vd_source=c7b6824c61369ce64fcb831e5abaf88d">7-前向传播整体流程_哔哩哔哩_bilibili</a></h3><h4 id="损失函数">损失函数</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308101717069.png" alt="image-20240308101717069"></p><p>用于评估权重参数的效果如何，结果值趋向于0表示损失较小。上图是简单的损失函数，用不是该类别的值减去该类别的值再加1,1的值是可以微调的，用于防范两者差别很小导致的错误。</p></li><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308102203668.png" alt="image-20240308102203668"></p><p>上图两个模型产生的值一样，但我们更倾向于模型B，更稳定。因为模型A只关注了局部，是一个过拟合的结果。</p></li></ul><h4 id="正则化惩罚项">正则化惩罚项</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308110846178.png" alt="image-20240308110846178"></p><p>权重各值的平方和再乘一个惩罚系数，这样局部数值高的模型损失值会变高，得分会变低。</p></li></ul><h4 id="前向传播">前向传播</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308111324488.png" alt="image-20240308111324488"></p><p>前向传播=得分函数+损失函数+正则化惩罚项</p></li></ul><h4 id="softmax-分类器">softmax 分类器</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308111505134.png" alt="image-20240308111505134"></p><p>这个函数的输出是一个0到1的值。</p></li><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308111544934.png" alt="image-20240308111544934"></p><ul><li><p>下标k是属于该类别的，下标j是不属于该类别的。</p></li><li><p>先做指数幂扩大差异，再归一化计算概率。</p></li><li><p>概率越小说明这个模型越差，由于我们需要的是一个损失值，最后需要做一个对数运算再取负值。</p></li></ul></li></ul><h4 id="反向传播">反向传播</h4><p>计算出损失值后，我们需要更新W（这就是训练模型），如何更新W呢，需要反向传播。</p><ul><li><p>链式法则</p><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308113305183.png" alt="image-20240308113305183"></p></li></ul><p>目的是为了求不同参数对损失值变化的影响，梯度求偏导。</p><h4 id="整体架构">整体架构</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308114009292.png" alt="image-20240308114009292"></p><ul><li><p>圆圈是特征的意思，模型在训练过程中可能会把特征给提取出来。</p></li><li><p>全连接如上图，那些线就是一个矩阵W，上图input到hidden1就是一个3x4的矩阵W。训练也是指训练这些东西。</p></li><li><p>所以上图就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><msub><mi>W</mi><mn>1</mn></msub><msub><mi>W</mi><mn>2</mn></msub><msub><mi>W</mi><mn>3</mn></msub><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">xW_1W_2W_3=y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>，那是否能够用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mn>4</mn></msub><mo>=</mo><msub><mi>W</mi><mn>1</mn></msub><msub><mi>W</mi><mn>2</mn></msub><msub><mi>W</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">W_4=W_1W_2W_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>呢，不行，因为层与层之间还有一个非线性函数用于做数值变换，就像之前的归一化一样。</p></li><li><p>神经元数量（特征数量）不是越大越好，会产生过拟合的问题。</p><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308133133147.png" alt="image-20240308133133147"></p></li></ul></li><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308124345679.png" alt="image-20240308124345679"></p><ul><li>max就是这里的非线性函数。</li></ul></li></ul><h4 id="正则化的作用">正则化的作用</h4><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308132926132.png" alt="image-20240308132926132"></p><p>惩罚力度越小，对训练集的效果越好。但过小又会产生过拟合的问题，还是要看测试集的效果。</p><h4 id="激活函数">激活函数</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308133251957.png" alt="image-20240308133251957"></p><p>常见的非线性网络，即激活函数</p></li><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308133343626.png" alt="image-20240308133343626"></p><p>sigmoid用的较少，因为数值过大或过小的时候，会导致梯度为0，梯度消失。</p><p>Relu函数用的较多，梯度为1。</p></li></ul><h4 id="过拟合解决方法">过拟合解决方法</h4><ul><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308133642848.png" alt="image-20240308133642848"></p><p>标准化，正则化。</p></li><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308133734165.png" alt="image-20240308133734165"></p><p>W矩阵的初始化。</p></li><li><p><img src="/2024/02/23/%E5%9F%BA%E4%BA%8E%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%94%9F%E7%89%A9%E7%89%B9%E5%BE%81%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240308133856466.png" alt="image-20240308133856466"></p><p>每次训练时随机不使用某一层的神经元。</p></li></ul><h4 id="卷积网络">卷积网络</h4><ul><li>4个参数<ul><li>filter 输出个数</li><li>kernel_size 卷积核大小</li><li>strides 步长，卷积核一次移动的距离</li><li>padding 是否填充边缘</li></ul></li></ul><h3 id="同态加密">同态加密</h3><h4 id="公钥和私钥">公钥和私钥</h4><p>如果使用对称加密算法，加解密使用同一个密钥，除了自己保存外，对方也要知道这个密钥，才能对数据进行解密。如果你把密钥也一起传过去，就存在密码泄漏的可能。所以我们使用<strong>非对称算法</strong>，过程如下：</p><ol><li>首先 接收方 生成一对密钥，即私钥和公钥；</li><li>然后，接收方 将公钥发送给 发送方；</li><li>发送方用收到的公钥对数据加密，再发送给接收方；</li><li>接收方收到数据后，使用自己的私钥解密。</li></ol><p>由于在非对称算法中，公钥加密的数据必须用对应的私钥才能解密，而私钥又只有接收方自己知道，这样就保证了数据传输的安全性。</p><p>总结：</p><ul><li>每个用户都有一对私钥和公钥。</li></ul><ul><li>私钥用来进行解密和签名，是给自己用的。</li><li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li><li>当该用户发送文件时，用私钥签名，别人用他给的公钥解密，可以保证该信息是由他发送的。即数字签名。</li></ul><ul><li>当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他看到。即安全传输。</li></ul><p>重点在于与对称加密中，加密和解密使用相同密码不同（使用相同密码如何保证密码的传输安全性），而非对称加密中，公钥是用来加密的，私钥是用来解密的，因此公钥是可以公开的，不怕被窃取；私钥用于解密，不需要传播。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>大学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同态加密</tag>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建sonic的testbed测试环境</title>
    <link href="/2024/01/23/%E6%90%AD%E5%BB%BAsonic%E7%9A%84testbed%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    <url>/2024/01/23/%E6%90%AD%E5%BB%BAsonic%E7%9A%84testbed%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1>搭建sonic的testbed测试环境</h1><h2 id="随记">随记</h2><h3 id="linux终端添加代理">linux终端添加代理</h3><p>clash的端口号是7890。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> http_proxy=<span class="hljs-string">&#x27;http://localhost:7890&#x27;</span><br><span class="hljs-built_in">export</span> https_proxy=<span class="hljs-string">&#x27;http://localhost:7890&#x27;</span><br><br><span class="hljs-comment"># 更优雅的方式设置/取消终端代理，执行下面两行代码后，可以直接在终端使用 proxy/unproxy 来设置/取消 终端代理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias proxy=&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias unproxy=&quot;unset http_proxy;unset https_proxy&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><h3 id="ubuntu安装clash">ubuntu安装clash</h3><p><a href="https://www.joeyne.cool/http/proxy/ubuntu-%E5%AE%89%E8%A3%85clash%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8/">Ubuntu 配置clash的四种方式 – 日拱一卒 (joeyne.cool)</a></p><p>经测试，第一种方式有效。</p><p>clash-linux，用上面网站的第二个方法。（上面网站已经删库跑路）</p><hr><p>[Ubuntu 22.04 安装 Clash | EagleBear2002 的博客](<a href="https://eaglebear2002.github.io/%E6%8A%80%E6%9C%AF%E7%A7%91%E6%99%AE/Ubuntu">https://eaglebear2002.github.io/技术科普/Ubuntu</a> 22.04 安装 Clash/)</p><p><a href="https://github.com/doreamon-design/clash/releases">https://github.com/doreamon-design/clash/releases</a> 下载clash</p><h4 id="安装">安装</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -xzvf clash_2.0.24_linux_amd64.tar.gz<br><span class="hljs-built_in">chmod</span> +x clash<br><span class="hljs-built_in">mv</span> clash /usr/local/bin/clash<br>clash -v<br></code></pre></td></tr></table></figure><h4 id="设置代理">设置代理</h4><p>clash设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">clash<br><span class="hljs-built_in">cd</span> ~/.config/clash/<br><span class="hljs-comment"># wget -O config.yaml xxx[订阅地址]  # 把现有的配置复制粘贴到这里</span><br><span class="hljs-comment"># 更优雅的方式设置/取消终端代理，执行下面两行代码后，可以直接在终端使用 proxy/unproxy 来设置/取消 终端代理</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias proxy=&quot;export http_proxy=http://127.0.0.1:7890;export https_proxy=http://127.0.0.1:7890&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;alias unproxy=&quot;unset http_proxy;unset https_proxy&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br><span class="hljs-comment">#在需要代理的终端输入命令 proxy</span><br></code></pre></td></tr></table></figure><p>ubuntu设置</p><p><img src="/2024/01/23/%E6%90%AD%E5%BB%BAsonic%E7%9A%84testbed%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/image-20241022110810351.png" alt="image-20241022110810351"></p><h4 id="开机自启动">开机自启动</h4><p>编辑<code>~/.bashrc</code>，末尾添加以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Check if Clash is already running</span><br><span class="hljs-keyword">if</span> ! pgrep -x <span class="hljs-string">&quot;clash&quot;</span> &gt; /dev/null; <span class="hljs-keyword">then</span><br>    /usr/local/bin/clash<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="docker安装">docker安装</h3><p><a href="https://blog.csdn.net/qq_26164609/article/details/106881060">Ubunto20.04 sudo apt-get update 出现目标被重置多次！_ubuntu目标被配置了多次-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/526303968">ubuntu20 上安装 docker 踩坑之路 - 知乎 (zhihu.com)</a>-》</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">E: 仓库 “https://download.docker.com/linux/ubuntu focal Release” 没有 Release 文件。<br>N: 无法安全地用该源进行更新，所以默认禁用该源。<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/xietingfeng321/p/18451170">解决docker镜像仓库下载慢或Error response from daemon: Get “https://registry-1.docker.io/v2/”: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) - 谢墨尘 - 博客园 (cnblogs.com)</a>-》无法拉取镜像</p><h2 id="sonic-mgmt-docs-testbed-README-testbed-VsSetup-md-at-master-·-sonic-net-sonic-mgmt-github-com"><a href="https://github.com/sonic-net/sonic-mgmt/blob/master/docs/testbed/README.testbed.VsSetup.md">sonic-mgmt/docs/testbed/README.testbed.VsSetup.md at master · sonic-net/sonic-mgmt (github.com)</a></h2><h3 id="libvirt无权限">libvirt无权限</h3><p>[<a href="https://digitalixy.com/linux/512188.html">Solved] 无法访问存储文件，KVM Libvirt 中的权限被拒绝错误 – Digitalixy.com</a></p><h3 id="the-libvirt-module-is-not-importable">the libvirt module is not importable</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get install libvirt-dev<br>python -m pip install libvirt-python<br>sudo apt-get install libxml2-dev libxslt-dev python-dev zlib1g-dev<br>sudo pip install lxml<br><br>apt -y install libvirt-dev<br>apt -y install libvirt-daemon-system <br>apt -y install libvirt-clients<br>apt -y install virtinst <br>apt -y install virt-manager<br><br><span class="hljs-comment">## qemu+kvm</span><br><br>apt -y install qemu-kvm<br><span class="hljs-comment">##网桥工具</span><br>apt -y install bridge-utils<br></code></pre></td></tr></table></figure><h3 id="运行setup-container报错">运行<code>setup-container</code>报错</h3><p>ERROR: missing Jinja2 templates support: make sure j2cli package is installed 但其实已安装，是路径出了问题</p><p><img src="/2024/01/23/%E6%90%AD%E5%BB%BAsonic%E7%9A%84testbed%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/image-20241022120658615.png" alt="image-20241022120658615"></p><p><a href="https://blog.csdn.net/qq_33659001/article/details/109438291">解决pip3 install waring ‘The script xxx is installed in ‘/home/xxx/bin‘ which is not on PATH‘_the script is installed in-CSDN博客</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=/home/bupt/.local/bin:$PATH&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br>pip uninstall j2cli<br>pip install j2cli<br></code></pre></td></tr></table></figure><h3 id="docker连接报错">docker连接报错</h3><p>运行./testbed-cli.sh -m veos_vtb -n 4 -k vsonic start-vms server_1 password.txt报错，需要给ansible设置代理，编辑<code>sonic-mgmt/ansible</code>目录下的<code>inventory</code>文件，添加以下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">all:</span><br>  <span class="hljs-attr">vars:</span><br>    <span class="hljs-attr">proxy_env:</span><br>      <span class="hljs-attr">HTTP_PROXY:</span> <span class="hljs-string">&quot;http://proxyserver:port&quot;</span><br>      <span class="hljs-attr">HTTPS_PROXY:</span> <span class="hljs-string">&quot;http://proxyserver:port&quot;</span><br></code></pre></td></tr></table></figure><h2 id="pytest">pytest</h2><h3 id="sonic-mgmt-spytest-containers-README-md-at-master-·-sonic-net-sonic-mgmt-github-com"><a href="https://github.com/sonic-net/sonic-mgmt/blob/master/spytest/containers/README.md">sonic-mgmt/spytest/containers/README.md at master · sonic-net/sonic-mgmt (github.com)</a></h3><h4 id="解决Docker构建时pip下载超时问题-百度开发者中心-baidu-com"><a href="https://developer.baidu.com/article/details/2799355">解决Docker构建时pip下载超时问题-百度开发者中心 (baidu.com)</a></h4><p>在Dockerfile中添加python国内源</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>路由标识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sonic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sonic路由配置nat</title>
    <link href="/2024/01/09/sonic%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEnat/"/>
    <url>/2024/01/09/sonic%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEnat/</url>
    
    <content type="html"><![CDATA[<h1>sonic路由配置nat</h1><h2 id="配置环境">配置环境</h2><ul><li>GNS 2.2.38</li><li>sonic路由器</li></ul><h2 id="配置步骤">配置步骤</h2><p>简单测试拓扑如下，目的是R1能通过R2联网。</p><p><img src="/2024/01/09/sonic%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEnat/image-20240109105748586.png" alt="image-20240109105748586"></p><h3 id="配置R2联网">配置R2联网</h3><p>这里通过e0来连接nat，也可以直接使用eth0管理口来连接，那样一连接上就可以直接联网，eth0开启了dhcp服务，可自动分配192.168.122.1/24网段的ip地址。这里通过e0普通端口连接，让我们更清楚计算机联网的过程。</p><ol><li><p>前提是知道NAT的网关ip是多少，gns3中默认是192.168.122.1。若其他网络环境可以通过eth0的dhcp服务自动分配一次，然后使用<code>show arp -a</code>来查看。</p></li><li><p>配置R2的e0端口ip地址。配置完成应能够ping通192.168.122.1。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config int ip remove Ethernet0 10.0.0.0/31<br>sudo config int ip add Ethernet0 192.168.122.2/24<br><span class="hljs-comment"># ping 192.168.122.1</span><br></code></pre></td></tr></table></figure></li><li><p>配置R2的默认网关为192.168.122.1。配置完成应能够ping通8.8.8.8（google的dns服务器）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config route add prefix 0.0.0.0/0 nexthop 192.168.122.1<br>sudo config save -y<br><span class="hljs-comment"># ping 8.8.8.8</span><br></code></pre></td></tr></table></figure></li><li><p>配置R2的dns服务器，用于解析域名。配置完成即可联网，通过<code>ping baidu.com</code>来测试。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/resolv.conf<br><span class="hljs-comment"># 增加内容</span><br><span class="hljs-comment"># nameserver 192.168.122.1</span><br><span class="hljs-comment"># nameserver 8.8.8.8</span><br>sudo systemctl restart networking.service<br></code></pre></td></tr></table></figure></li></ol><p>与第2步类似，可将R2的e1端口和R1的e0端口的ip配置完成。与第2、3步类似，可将R1的默认网关和dns服务器配置完成，命令如下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># R2</span><br><span class="hljs-comment"># sonic路由器映射关系为en &lt;-&gt; Ethernet(4*n),故e1是Ethernet4</span><br>sudo config int ip remove Ethernet4 10.0.0.2/31<br>sudo config int ip add Ethernet4 10.1.2.2/24<br><br><span class="hljs-comment"># R1</span><br>sudo config int ip remove Ethernet0 10.0.0.0/31<br>sudo config int ip add Ethernet0 10.1.2.1/24<br>sudo config route add prefix 0.0.0.0/0 nexthop 10.1.2.2<br>sudo vim /etc/resolv.conf<br><span class="hljs-comment"># 增加内容</span><br><span class="hljs-comment"># nameserver 10.1.2.2</span><br><span class="hljs-comment"># nameserver 8.8.8.8</span><br>sudo systemctl restart networking.service<br>sudo config save -y<br></code></pre></td></tr></table></figure><h3 id="配置R2的NAT">配置R2的NAT</h3><ol><li><p>通过以下命令打开nat。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config feature state nat enabled<br>sudo config nat feature <span class="hljs-built_in">enable</span><br><span class="hljs-comment"># sudo show feature config</span><br></code></pre></td></tr></table></figure></li><li><p>配置R2的ACL规则，将R2的e1收到的报文作划分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># config acl add table [OPTIONS] &lt;table_name&gt; &lt;table_type&gt; [-d &lt;description&gt;] [-p &lt;ports&gt;] [-s (ingress | egress)]</span><br>sudo config acl add table acl1 L3 -p Ethernet4 -s ingress<br></code></pre></td></tr></table></figure></li><li><p>配置R2的nat pool。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># config nat add pool (pool-name) (global-ip-range) (global-port-range)</span><br>sudo config nat add pool pool1 192.168.122.2<br></code></pre></td></tr></table></figure></li><li><p>将pool和acl绑定。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># config nat add binding (binding-name) [(pool-name)] [(acl-name)] [-nat_type &#123;snat | dnat&#125;] [-twice_nat_id (value)]</span><br>sudo config nat add binding bind1 pool1 acl1<br></code></pre></td></tr></table></figure></li><li><p>配置完毕，R1应能够联网，保存配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config save -y<br></code></pre></td></tr></table></figure></li></ol><h2 id="持久化配置">持久化配置</h2><p>上述步骤中，对dns服务器和路由的配置不是永久的，在路由器重启后会失效。</p><h3 id="dns服务器">dns服务器</h3><p>注：若是v7及以上版本的sonic路由器，可通过<code>sudo config dns nameserver add [OPTIONS] &lt;ip_address&gt;</code>命令添加，再通过<code>sudo config save -y</code>来保存配置。</p><p><img src="/2024/01/09/sonic%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AEnat/image-20240109115455705.png" alt="image-20240109115455705"></p><ol><li><p>写保护锁定 resolv.conf 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -f /etc/resolv.conf<br></code></pre></td></tr></table></figure></li><li><p>创建并编辑 resolv.conf 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">editor /etc/resolv.conf<br>nameserver 10.1.2.2<br>nameserver 8.8.8.8<br></code></pre></td></tr></table></figure></li><li><p>设置写保护锁定 resolv.conf 文件</p></li></ol>   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">chattr +i /etc/resolv.conf<br></code></pre></td></tr></table></figure><ol start="4"><li><p>若想解锁，运行下述命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">chattr -i /etc/resolv.conf<br></code></pre></td></tr></table></figure></li></ol><h2 id="疑问">疑问</h2><ol><li>是否能够使用静态nat来完成配置？</li></ol><h2 id="参考">参考</h2><ul><li><a href="https://www.vdj.me/archives/252.html">Debian 11 永久修改 DNS - 青枫博客 (vdj.me)</a></li><li><a href="https://github.com/sonic-net/sonic-utilities/blob/master/doc/Command-Reference.md#configuring-management-interface">sonic-utilities/doc/Command-Reference.md at master · sonic-net/sonic-utilities (github.com)</a></li><li><a href="https://github.com/sonic-net/SONiC/blob/master/doc/nat/nat_design_spec.md#revision">SONiC/doc/nat/nat_design_spec.md at master · sonic-net/SONiC (github.com)</a></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>路由标识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sonic</tag>
      
      <tag>nat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode24-01</title>
    <link href="/2024/01/03/leetcode24-01/"/>
    <url>/2024/01/03/leetcode24-01/</url>
    
    <content type="html"><![CDATA[<h1>leetcode24-01刷题笔记</h1><h2 id="1599-经营摩天轮的最大利润"><a href="https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/">1599. 经营摩天轮的最大利润</a></h2><blockquote><p>你正在经营一座摩天轮，该摩天轮共有 <strong>4 个座舱</strong> ，每个座舱 <strong>最多可以容纳 4 位游客</strong> 。你可以 <strong>逆时针</strong> 轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 1 / 4 周。</p><p>给你一个长度为 <code>n</code> 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 <code>i</code> 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 <strong>在服务所有游客之前</strong> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，<strong>将免费进行所有后续轮转</strong> 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <strong>下一次轮转</strong> 。</p><p>返回最大化利润所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p></blockquote><ul><li><p>个人思路</p><p>题目看半天，停下摩天轮的意思是之后再也没有顾客了，也没有钱赚了，所以停下摩天轮来免费进行所有后续轮转，以便游客下车。那所有游客都会上摩天轮，这里面没有调度可言，模拟即可？貌似4个座舱这个数据也是没有用的。</p><p>直接模拟，WA</p><p><img src="/2024/01/03/leetcode24-01/image-20240103163714984.png" alt="image-20240103163714984"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minOperationsMaxProfit</span><span class="hljs-params">(customers []<span class="hljs-type">int</span>, boardingCost <span class="hljs-type">int</span>, runningCost <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>wait, profit, cnt := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(customers)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cnt; i++ &#123;<br>wait += customers[i]<br><span class="hljs-keyword">if</span> wait &gt; <span class="hljs-number">4</span> &#123;<br>profit += <span class="hljs-number">4</span> * boardingCost<br>wait -= <span class="hljs-number">4</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>profit += wait * boardingCost<br>wait = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>profit += wait * boardingCost<br>cost := cnt * runningCost<br><span class="hljs-keyword">if</span> wait%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;<br>cnt += wait / <span class="hljs-number">4</span><br>cost += cnt * runningCost<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cnt += (wait/<span class="hljs-number">4</span> + <span class="hljs-number">1</span>)<br>cost += cnt * runningCost<br>&#125;<br><span class="hljs-keyword">if</span> profit-cost &lt; <span class="hljs-number">0</span> &#123;<br>cnt = <span class="hljs-number">-1</span><br>&#125;<br><span class="hljs-keyword">return</span> cnt<br>&#125;<br></code></pre></td></tr></table></figure><p>所以不是所有游客都可以上摩天轮，唯一的调度在于是否要暂停服务，还是模拟</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minOperationsMaxProfit</span><span class="hljs-params">(customers []<span class="hljs-type">int</span>, boardingCost <span class="hljs-type">int</span>, runningCost <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>wait, profit, cnt, max_profit, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> cnt &lt; <span class="hljs-built_in">len</span>(customers) || wait &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> cnt &lt; <span class="hljs-built_in">len</span>(customers) &#123;<br>wait += customers[cnt]<br>&#125;<br><span class="hljs-keyword">if</span> wait &gt; <span class="hljs-number">4</span> &#123;<br>profit += <span class="hljs-number">4</span> * boardingCost<br>wait -= <span class="hljs-number">4</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>profit += wait * boardingCost<br>wait = <span class="hljs-number">0</span><br>&#125;<br>profit -= runningCost<br>cnt++<br><span class="hljs-keyword">if</span> profit &gt; max_profit &#123;<br>max_profit = profit<br>res = cnt<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>也是模拟</p></li></ul><h2 id="466-统计重复个数"><a href="https://leetcode.cn/problems/count-the-repetitions/">466. 统计重复个数</a></h2><blockquote><p>定义 <code>str = [s, n]</code> 表示 <code>str</code> 由 <code>n</code> 个字符串 <code>s</code> 连接构成。</p><ul><li>例如，<code>str == [&quot;abc&quot;, 3] ==&quot;abcabcabc&quot;</code> 。</li></ul><p>如果可以从 <code>s2</code> 中删除某些字符使其变为 <code>s1</code>，则称字符串 <code>s1</code> 可以从字符串 <code>s2</code> 获得。</p><ul><li>例如，根据定义，<code>s1 = &quot;abc&quot;</code> 可以从 <code>s2 = &quot;ab***dbe***c&quot;</code> 获得，仅需要删除加粗且用斜体标识的字符。</li></ul><p>现在给你两个字符串 <code>s1</code> 和 <code>s2</code> 和两个整数 <code>n1</code> 和 <code>n2</code> 。由此构造得到两个字符串，其中 <code>str1 = [s1, n1]</code>、<code>str2 = [s2, n2]</code> 。</p><p>请你找出一个最大整数 <code>m</code> ，以满足 <code>str = [str2, m]</code> 可以从 <code>str1</code> 获得。</p></blockquote><ul><li>个人思路</li></ul><h2 id="2487-从链表中移除节点"><a href="https://leetcode.cn/problems/remove-nodes-from-linked-list/">2487. 从链表中移除节点</a></h2><blockquote><p>给你一个链表的头节点 <code>head</code> 。</p><p>移除每个右侧有一个更大数值的节点。</p><p>返回修改后链表的头节点 <code>head</code> 。</p></blockquote><ul><li><p>个人思路</p><p>单调栈，使用一个结构体记录节点的值和指针，用一个单调栈来确保右侧的数值一定比自身小。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyNode <span class="hljs-keyword">struct</span> &#123;<br>Val   <span class="hljs-type">int</span><br>Point *ListNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNodes</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>stack := []MyNode&#123;&#125;<br><span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>top := <span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> top &gt;= <span class="hljs-number">0</span> &amp;&amp; stack[top].Val &lt; head.Val &#123;<br>top--<br>&#125;<br>stack = stack[:top+<span class="hljs-number">1</span>]<br>stack = <span class="hljs-built_in">append</span>(stack, MyNode&#123;Val: head.Val, Point: head&#125;)<br>head = head.Next<br>&#125;<br>pre := stack[<span class="hljs-number">0</span>].Point<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(stack); i++ &#123;<br>pre.Next = stack[i].Point<br>pre = pre.Next<br>&#125;<br><span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>].Point<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNodes</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    head.Next = removeNodes(head.Next)<br>    <span class="hljs-keyword">if</span> (head.Next != <span class="hljs-literal">nil</span> &amp;&amp; head.Val &lt; head.Next.Val) &#123;<br>        <span class="hljs-keyword">return</span> head.Next<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNodes</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> st []*ListNode<br>    <span class="hljs-keyword">for</span> ; head != <span class="hljs-literal">nil</span>; head = head.Next &#123;<br>        st = <span class="hljs-built_in">append</span>(st, head)<br>    &#125;<br>    <span class="hljs-keyword">for</span> ; <span class="hljs-built_in">len</span>(st) &gt; <span class="hljs-number">0</span>; st = st[:<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>] &#123;<br>        <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || st[<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>].Val &gt;= head.Val &#123;<br>            st[<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>].Next = head<br>            head = st[<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>反转链表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        p := head<br>        head = head.Next<br>        p.Next = dummy.Next<br>        dummy.Next = p<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNodes</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    head = reverse(head)<br>    <span class="hljs-keyword">for</span> p := head; p.Next != <span class="hljs-literal">nil</span>; &#123;<br>        <span class="hljs-keyword">if</span> p.Val &gt; p.Next.Val &#123;<br>            p.Next = p.Next.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p = p.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> reverse(head)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2397-被列覆盖的最多行数"><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">2397. 被列覆盖的最多行数</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的二进制矩阵 <code>matrix</code> ；另给你一个整数 <code>numSelect</code>，表示你必须从 <code>matrix</code> 中选择的 <strong>不同</strong> 列的数量。</p><p>如果一行中所有的 <code>1</code> 都被你选中的列所覆盖，则认为这一行被 <strong>覆盖</strong> 了。</p><p><strong>形式上</strong>，假设 <code>s = &#123;c1, c2, ...., cnumSelect&#125;</code> 是你选择的列的集合。对于矩阵中的某一行 <code>row</code> ，如果满足下述条件，则认为这一行被集合 <code>s</code> <strong>覆盖</strong>：</p><ul><li>对于满足 <code>matrix[row][col] == 1</code> 的每个单元格 <code>matrix[row][col]</code>（<code>0 &lt;= col &lt;= n - 1</code>），<code>col</code> 均存在于 <code>s</code> 中，或者</li><li><code>row</code> 中 <strong>不存在</strong> 值为 <code>1</code> 的单元格。</li></ul><p>你需要从矩阵中选出 <code>numSelect</code> 个列，使集合覆盖的行数最大化。</p><p>返回一个整数，表示可以由 <code>numSelect</code> 列构成的集合 <strong>覆盖</strong> 的 <strong>最大行数</strong> 。</p></blockquote><ul><li><p>个人思路</p><p>首先，如果一行值为<code>1</code>的单元格超过了<code>numSelect</code>个，则可以直接去除，因为不可能被覆盖。放弃，思考不出。</p></li><li><p>官解</p><ul><li><p>枚举</p><p>mask是一行的单元格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumRows</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, numSelect <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    mask := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            mask[i] += matrix[i][j] &lt;&lt; (n - j - <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    res, limit := <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &lt;&lt; n<br>    <span class="hljs-keyword">for</span> cur := <span class="hljs-number">1</span>; cur &lt; limit; cur++ &#123;<br>        <span class="hljs-keyword">if</span> bits.OnesCount(<span class="hljs-type">uint</span>(cur)) != numSelect &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        t := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> (mask[j] &amp; cur) == mask[j] &#123;<br>                t++<br>            &#125;<br>        &#125;<br>        res = max(res, t)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二进制枚举的 Gosper’s Hack 优化</p><p><img src="/2024/01/03/leetcode24-01/image-20240104141742661.png" alt="image-20240104141742661"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumRows</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, numSelect <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    mask := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            mask[i] += matrix[i][j] &lt;&lt; (n - j - <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    res, limit := <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &lt;&lt; n<br>    <span class="hljs-keyword">for</span> cur := (<span class="hljs-number">1</span> &lt;&lt; numSelect) - <span class="hljs-number">1</span>; cur &lt; limit; &#123;<br>        t := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> (mask[j] &amp; cur) == mask[j] &#123;<br>                t++<br>            &#125;<br>        &#125;<br>        res = max(res, t)<br>        lb := cur &amp; -cur<br>        r := cur + lb<br>        cur = ((r ^ cur) &gt;&gt; (bits.TrailingZeros(<span class="hljs-type">uint</span>(lb)) + <span class="hljs-number">2</span>)) | r<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="1944-队列中可以看到的人数"><a href="https://leetcode.cn/problems/number-of-visible-people-in-a-queue/">1944. 队列中可以看到的人数</a></h2><blockquote><p>有 <code>n</code> 个人排成一个队列，<strong>从左到右</strong> 编号为 <code>0</code> 到 <code>n - 1</code> 。给你以一个整数数组 <code>heights</code> ，每个整数 <strong>互不相同</strong>，<code>heights[i]</code> 表示第 <code>i</code> 个人的高度。</p><p>一个人能 <strong>看到</strong> 他右边另一个人的条件是这两人之间的所有人都比他们两人 <strong>矮</strong> 。更正式的，第 <code>i</code> 个人能看到第 <code>j</code> 个人的条件是 <code>i &lt; j</code> 且 <code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code> 。</p><p>请你返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个人在他右侧队列中能 <strong>看到</strong> 的 <strong>人数</strong> 。</p></blockquote><ul><li><p>个人思路</p><p>就是寻找右侧第一个比你大的数的位置。可用单调栈解决，用一个数据结构将数值和下标绑定，遍历队列，三种情况</p><ul><li>栈空，入栈</li><li>当前元素小于栈顶元素，入栈</li><li>当前元素大于栈顶元素，出栈，并与下一个栈顶元素比较。出栈的具体操作是将当前元素的下标减去栈顶元素下标填到栈顶元素下标位置上，<s>表示栈顶元素能看到的人。</s></li></ul><p><img src="/2024/01/03/leetcode24-01/image-20240105094754063.png" alt="image-20240105094754063"></p><p>思路错误，不是寻找下一个更大的元素，这里的10能看见到是6,8,11，看不见5。</p><p>出栈的处理有问题，当前元素的下标减去栈顶元素下标填到栈顶元素下标位置上，表示的不是栈顶元素能看到的人，当前元素的下标表示的是栈顶元素能看到的最后一个人。故做出修改</p><ul><li>栈空，入栈</li><li>当前元素小于栈顶元素，<code>res[栈顶元素下标]+1</code>，入栈，</li><li>当前元素大于栈顶元素，<code>res[栈顶元素下标]+1</code>，出栈，并与下一个栈顶元素比较。</li></ul><p>注意，出栈的元素因为视线（想象他们的视线是水平的）被当前元素阻挡，故无法再看见任何人。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>heights <span class="hljs-type">int</span><br>index   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canSeePersonsCount</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>stack := []Person&#123;&#125;<br>person_num := <span class="hljs-built_in">len</span>(heights)<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, person_num)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; person_num; i++ &#123;<br>top := <span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> top &lt; <span class="hljs-number">0</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, Person&#123;heights: heights[i], index: i&#125;)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> top &gt;= <span class="hljs-number">0</span> &amp;&amp; stack[top].heights &lt; heights[i] &#123;<br>res[stack[top].index]++<br>stack = stack[:top]<br>top--<br>&#125;<br><span class="hljs-keyword">if</span> top &gt;= <span class="hljs-number">0</span> &#123;<br>res[stack[top].index]++<br>&#125;<br>stack = <span class="hljs-built_in">append</span>(stack, Person&#123;heights: heights[i], index: i&#125;)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>单调栈</p><p>思路一致，但官解从末尾开始遍历，就不用记录下标了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canSeePersonsCount</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(heights)<br>stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><br><span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>h := heights[i]<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] &lt;= h &#123;<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            res[i] += <span class="hljs-number">1</span>;<br>&#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>            res[i] += <span class="hljs-number">1</span>;<br>        &#125;<br>stack = <span class="hljs-built_in">append</span>(stack, h)<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2807-在链表中插入最大公约数"><a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/">2807. 在链表中插入最大公约数</a></h2><blockquote><p>给你一个链表的头 <code>head</code> ，每个结点包含一个整数值。</p><p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong> 。</p><p>请你返回插入之后的链表。</p><p>两个数的 <strong>最大公约数</strong> 是可以被两个数字整除的最大正整数。</p></blockquote><ul><li><p>个人思路</p><p>递归？</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getGCD</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// fmt.Printf(&quot;%d,%d&quot;, a, b)</span><br><span class="hljs-keyword">for</span> c := a % b; c != <span class="hljs-number">0</span>; c = a % b &#123;<br>a = b<br>b = c<br>&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;,%d\n&quot;, b)</span><br><span class="hljs-keyword">return</span> b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertGreatestCommonDivisors</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>gcd := getGCD(head.Val, head.Next.Val)<br>new_node := ListNode&#123;Val: gcd, Next: head.Next&#125;<br>head.Next = &amp;new_node<br>new_node.Next = insertGreatestCommonDivisors(new_node.Next)<br><span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li>模拟</li></ul><p>EZ</p></li></ul><h2 id="383-赎金信"><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h2><blockquote><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p></blockquote><ul><li><p>个人思路</p><p>EZAC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(ransomNote <span class="hljs-type">string</span>, magazine <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>rset, mset := [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;, [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(ransomNote); i++ &#123;<br>rset[ransomNote[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(magazine); i++ &#123;<br>mset[magazine[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br><span class="hljs-keyword">if</span> rset[i] &gt; mset[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>优化一点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(ransomNote, magazine <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ransomNote) &gt; <span class="hljs-built_in">len</span>(magazine) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    cnt := [<span class="hljs-number">26</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> magazine &#123;<br>        cnt[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> ransomNote &#123;<br>        cnt[ch-<span class="hljs-string">&#x27;a&#x27;</span>]--<br>        <span class="hljs-keyword">if</span> cnt[ch-<span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="447-回旋镖的数量"><a href="https://leetcode.cn/problems/number-of-boomerangs/">447. 回旋镖的数量</a></h2><blockquote><p>给定平面上 <code>n</code> 对 <strong>互不相同</strong> 的点 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 。<strong>回旋镖</strong> 是由点 <code>(i, j, k)</code> 表示的元组 ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的欧式距离相等（<strong>需要考虑元组的顺序</strong>）。</p><p>返回平面上所有回旋镖的数量。</p></blockquote><ul><li><p>个人思路</p><p>可以遍历每一个点作为回旋镖的顶点，即<code>(i,j,k)</code>的<code>i</code>，看相同距离的有多少（可以用一个哈希表存储），然后<code>A(n,2)</code>，与顺序有关。对距离的判断使用平方和即可。</p><p>AC，注意<code>dist_map</code>的声明要两步</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDis</span><span class="hljs-params">(a, b []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x, y := a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]-b[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">return</span> x*x + y*y<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>points_num, res := <span class="hljs-built_in">len</span>(points), <span class="hljs-number">0</span><br>dist_map := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>, points_num)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; points_num; i++ &#123;<br>dist_map[i] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; points_num; i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; points_num; j++ &#123;<br>dist := getDis(points[i], points[j])<br>dist_map[i][dist]++<br>dist_map[j][dist]++<br>&#125;<br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> dist_map[i] &#123;<br>res += val * (val - <span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>枚举+哈希</p><p>和我类似，只不过我少一半的遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(points [][]<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> points &#123;<br>        cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, q := <span class="hljs-keyword">range</span> points &#123;<br>            dis := (p[<span class="hljs-number">0</span>]-q[<span class="hljs-number">0</span>])*(p[<span class="hljs-number">0</span>]-q[<span class="hljs-number">0</span>]) + (p[<span class="hljs-number">1</span>]-q[<span class="hljs-number">1</span>])*(p[<span class="hljs-number">1</span>]-q[<span class="hljs-number">1</span>])<br>            cnt[dis]++<br>        &#125;<br>        <span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> cnt &#123;<br>            ans += m * (m - <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2707-字符串中的额外字符"><a href="https://leetcode.cn/problems/extra-characters-in-a-string/">2707. 字符串中的额外字符</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和一个单词字典 <code>dictionary</code> 。你需要将 <code>s</code> 分割成若干个 <strong>互不重叠</strong> 的子字符串，每个子字符串都在 <code>dictionary</code> 中出现过。<code>s</code> 中可能会有一些 <strong>额外的字符</strong> 不在任何子字符串中。</p><p>请你采取最优策略分割 <code>s</code> ，使剩下的字符 <strong>最少</strong> 。</p></blockquote><ul><li><p>官解</p><p><img src="/2024/01/03/leetcode24-01/image-20240110093759531.png" alt="image-20240110093759531"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minExtraChar</span><span class="hljs-params">(s <span class="hljs-type">string</span>, dictionary []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    d := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        d[i] = math.MaxInt<br>    &#125;<br>    mp := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> dictionary &#123;<br>        mp[e]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        d[i] = d[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> _, ok := mp[s[j:i]]; ok &#123;<br>                d[i] = min(d[i], d[j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n]<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="2696-删除子串后的字符串最小长度"><a href="https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/">2696. 删除子串后的字符串最小长度</a></h2><blockquote><p>给你一个仅由 <strong>大写</strong> 英文字符组成的字符串 <code>s</code> 。</p><p>你可以对此字符串执行一些操作，在每一步操作中，你可以从 <code>s</code> 中删除 <strong>任一个</strong> <code>&quot;AB&quot;</code> 或 <code>&quot;CD&quot;</code> 子字符串。</p><p>通过执行操作，删除所有 <code>&quot;AB&quot;</code> 和 <code>&quot;CD&quot;</code> 子串，返回可获得的最终字符串的 <strong>最小</strong> 可能长度。</p><p><strong>注意</strong>，删除子串后，重新连接出的字符串可能会产生新的 <code>&quot;AB&quot;</code> 或 <code>&quot;CD&quot;</code> 子串。</p></blockquote><ul><li><p>个人思路</p><p>EZAC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minLength</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); &#123;<br><span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; ((s[i] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span>) || (s[i] == <span class="hljs-string">&#x27;C&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;D&#x27;</span>)) &#123;<br><span class="hljs-keyword">var</span> builder strings.Builder<br>builder.WriteString(s[:i])<br><span class="hljs-keyword">if</span> i+<span class="hljs-number">2</span> &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>builder.WriteString(s[i+<span class="hljs-number">2</span>:])<br>&#125;<br>s = builder.String()<br><span class="hljs-comment">//fmt.Println(s)</span><br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>i--<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>栈</p><p>消消乐</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minLength</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">var</span> stack []<span class="hljs-type">byte</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br>        stack = <span class="hljs-built_in">append</span>(stack, s[i])<br>        m := <span class="hljs-built_in">len</span>(stack)<br>        <span class="hljs-keyword">if</span> m &gt;= <span class="hljs-number">2</span> &amp;&amp; (<span class="hljs-type">string</span>(stack[m<span class="hljs-number">-2</span>:]) == <span class="hljs-string">&quot;AB&quot;</span> || <span class="hljs-type">string</span>(stack[m - <span class="hljs-number">2</span>:]) == <span class="hljs-string">&quot;CD&quot;</span>) &#123;<br>            stack = stack[:m<span class="hljs-number">-2</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2645-构造有效字符串的最少插入数"><a href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/">2645. 构造有效字符串的最少插入数</a></h2><blockquote><p>给你一个字符串 <code>word</code> ，你可以向其中任何位置插入 “a”、“b” 或 “c” 任意次，返回使 <code>word</code> <strong>有效</strong> 需要插入的最少字母数。</p><p>如果字符串可以由 “abc” 串联多次得到，则认为该字符串 <strong>有效</strong> 。</p></blockquote><ul><li><p>个人思路</p><p>用栈的角度思考，玩消消乐。遍历读入字符</p><ul><li>a，入栈。</li><li>b，入栈。检查前面的字符是否是a，不是则添加一个字符’a’。</li><li>c，入栈。检查前面的字符顺序是否是b(b的前面必然有a），是则直接消去；不是则检查是否是a，是则添加b消去，不是则添加ab，消去。</li></ul><p>遍历完成，最后<strong>退栈</strong>添加相应字母将栈中元素全部消除（不能简单的判断有多少a多少b。栈中元素不会有c</p><ul><li>a，添加b、c，消去。</li><li>b，添加c，消去。</li></ul><p>期间统计插入字符数，即为最少字母数。</p><p>WA</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addMinimum</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>stack, res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(word)), <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br><span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;a&#x27;</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-string">&#x27;a&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;b&#x27;</span> &#123;<br>top := <span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> top &lt; <span class="hljs-number">0</span> || stack[top] != <span class="hljs-string">&#x27;a&#x27;</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-string">&#x27;a&#x27;</span>)<br>res++<br>&#125;<br>stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-string">&#x27;b&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>top := <span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> top &gt;= <span class="hljs-number">0</span> &amp;&amp; stack[top] == <span class="hljs-string">&#x27;b&#x27;</span> &#123;<br>stack = stack[:top<span class="hljs-number">-1</span>]<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> top &gt;= <span class="hljs-number">0</span> &#123;<br>stack = stack[:top]<br>res++ <span class="hljs-comment">//add &#x27;b&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res += <span class="hljs-number">2</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> top := <span class="hljs-built_in">len</span>(stack) - <span class="hljs-number">1</span>; top &gt;= <span class="hljs-number">0</span>; &#123;<br><span class="hljs-keyword">if</span> stack[top] == <span class="hljs-string">&#x27;b&#x27;</span> &#123;<br>res++<br>top -= <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res += <span class="hljs-number">2</span><br>top--<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>错误的，这题不是消消乐。例如 aabcc，需要添加4个字母成abcabcabc才符合题目，不是把中间的消了加个b就行。那一次遍历判断该加加，不就得了？</p><p>用state去标识状态。AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addMinimum</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>state, res := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-comment">//state : 0 - nil,1 - a,2 - ab</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br><span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;a&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> state == <span class="hljs-number">1</span> &#123;<br>res += <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == <span class="hljs-number">2</span> &#123;<br>res++<br>&#125;<br>state = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ch == <span class="hljs-string">&#x27;b&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> state == <span class="hljs-number">0</span> &#123;<br>res++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == <span class="hljs-number">2</span> &#123;<br>res += <span class="hljs-number">2</span><br>&#125;<br>state = <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> state == <span class="hljs-number">0</span> &#123;<br>res += <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == <span class="hljs-number">1</span> &#123;<br>res++<br>&#125;<br>state = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> state == <span class="hljs-number">1</span> &#123;<br>res += <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> state == <span class="hljs-number">2</span> &#123;<br>res++<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>有点高手</p><ul><li><p>动态规划</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addMinimum</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(word)<br>    d := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        d[i] = d[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">1</span> &amp;&amp; word[i - <span class="hljs-number">1</span>] &gt; word[i - <span class="hljs-number">2</span>] &#123;<br>            d[i] = d[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接拼接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addMinimum</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(word)<br>    res := <span class="hljs-type">int</span>(word[<span class="hljs-number">0</span>] - word[n - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        res += <span class="hljs-type">int</span>(word[i] - word[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>) % <span class="hljs-number">3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算组数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> addMinimum(<span class="hljs-type">string</span> word) &#123;<br>        <span class="hljs-type">int</span> n = word.size(), cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (word[i] &lt;= word[i - <span class="hljs-number">1</span>]) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt * <span class="hljs-number">3</span> - n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2085-统计出现过一次的公共字符串"><a href="https://leetcode.cn/problems/count-common-words-with-one-occurrence/">2085. 统计出现过一次的公共字符串</a></h2><blockquote><p>给你两个字符串数组 <code>words1</code> 和 <code>words2</code> ，请你返回在两个字符串数组中 <strong>都恰好出现一次</strong> 的字符串的数目。</p></blockquote><ul><li><p>个人思路</p><p>EZAC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countWords</span><span class="hljs-params">(words1 []<span class="hljs-type">string</span>, words2 []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br>wordCnt1, wordCnt2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words1); i++ &#123;<br>wordCnt1[words1[i]]++<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words2); i++ &#123;<br>wordCnt2[words2[i]]++<br>&#125;<br><span class="hljs-keyword">for</span> key, val := <span class="hljs-keyword">range</span> wordCnt1 &#123;<br><span class="hljs-keyword">if</span> val == <span class="hljs-number">1</span> &amp;&amp; val == wordCnt2[key] &#123;<br>res++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>一模一样。</p></li></ul><h2 id="2182-构造限制重复的字符串"><a href="https://leetcode.cn/problems/construct-string-with-repeat-limit/">2182. 构造限制重复的字符串</a></h2><h2 id="83-删除排序链表中的重复元素"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><h2 id="82-删除排序链表中的重复元素-II"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><blockquote><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除原始链表中所有重复数字的节点，只留下不同的数字</em> 。返回 <em>已排序的链表</em> 。</p><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围 <code>[0, 300]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li>题目数据保证链表已经按升序 <strong>排列</strong></li></ul></blockquote><ul><li><p>个人思路</p><p>从链表头遍历，用一个指针记录当前确定数值不重复的节点（最右边），若该节点下一个节点和下两个节点的值一样，则继续遍历到下一个确定数值不重复的节点。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br><span class="hljs-keyword">var</span> p, h *ListNode<br>h = <span class="hljs-literal">nil</span><br>p = h<br><span class="hljs-keyword">for</span> node := head; node != <span class="hljs-literal">nil</span>; node = node.Next &#123;<br><span class="hljs-keyword">if</span> node.Next != <span class="hljs-literal">nil</span> &amp;&amp; node.Val == node.Next.Val &#123;<br><span class="hljs-keyword">for</span> node.Next != <span class="hljs-literal">nil</span> &amp;&amp; node.Val == node.Next.Val &#123;<br>node = node.Next<br>&#125;<br><span class="hljs-keyword">if</span> node.Next == <span class="hljs-literal">nil</span> &amp;&amp; h != <span class="hljs-literal">nil</span> &#123;<br>p.Next = <span class="hljs-literal">nil</span><br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>h = node<br>p = h<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>p.Next = node<br>p = node<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>一样思路，但直接<code>cur.Next = cur.Next.Next</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    cur := dummy<br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;<br>            x := cur.Next.Val<br>            <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Val == x &#123;<br>                cur.Next = cur.Next.Next<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2744-最大字符串配对数目"><a href="https://leetcode.cn/problems/find-maximum-number-of-string-pairs/">2744. 最大字符串配对数目</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>words</code> ，数组中包含 <strong>互不相同</strong> 的字符串。</p><p>如果字符串 <code>words[i]</code> 与字符串 <code>words[j]</code> 满足以下条件，我们称它们可以匹配：</p><ul><li>字符串 <code>words[i]</code> 等于 <code>words[j]</code> 的反转字符串。</li><li><code>0 &lt;= i &lt; j &lt; words.length</code></li></ul><p>请你返回数组 <code>words</code> 中的 <strong>最大</strong> 匹配数目。</p><p>注意，每个字符串最多匹配一次。</p></blockquote><ul><li><p>个人思路</p><p>EZAC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>res, index := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(word)), <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>res[index] = word[i]<br>index++<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(res)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumNumberOfStringPairs</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>visited, ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(words)), <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words); i++ &#123;<br>res_word := reverseString(words[i])<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(words); j++ &#123;<br><span class="hljs-keyword">if</span> visited[j] == <span class="hljs-number">0</span> &amp;&amp; words[j] == res_word &#123;<br>ans++<br>visited[j] = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2171-拿出最少数目的魔法豆"><a href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/">2171. 拿出最少数目的魔法豆</a></h2><blockquote><p>给定一个 <strong>正整数</strong> 数组 <code>beans</code> ，其中每个整数表示一个袋子里装的魔法豆的数目。</p><p>请你从每个袋子中 <strong>拿出</strong> 一些豆子（也可以 <strong>不拿出</strong>），使得剩下的 <strong>非空</strong> 袋子中（即 <strong>至少还有一颗</strong> 魔法豆的袋子）魔法豆的数目 <strong>相等</strong>。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。</p><p>请返回你需要拿出魔法豆的 <strong>最少数目</strong>。</p></blockquote><ul><li><p>个人思路</p><p>拿豆使非空袋子的数量相等。</p></li><li><p>官解</p><p>遍历豆子数来计算最少数目。</p><p><img src="/2024/01/03/leetcode24-01/image-20240118101445771.png" alt="image-20240118101445771"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumRemoval</span><span class="hljs-params">(beans []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(beans)<br>    sort.Ints(beans)<br>    total := <span class="hljs-type">int64</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 豆子总数</span><br>    <span class="hljs-keyword">for</span> _, bean := <span class="hljs-keyword">range</span> beans &#123;<br>        total += <span class="hljs-type">int64</span>(bean)<br>    &#125;<br>    res := total <span class="hljs-comment">// 最少需要移除的豆子数</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        res = min(res, total - <span class="hljs-type">int64</span>(beans[i]) * <span class="hljs-type">int64</span>(n - i))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2865-美丽塔-I"><a href="https://leetcode.cn/problems/beautiful-towers-i/">2865. 美丽塔 I</a></h2><blockquote><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>maxHeights</code> 。</p><p>你的任务是在坐标轴上建 <code>n</code> 座塔。第 <code>i</code> 座塔的下标为 <code>i</code> ，高度为 <code>heights[i]</code> 。</p><p>如果以下条件满足，我们称这些塔是 <strong>美丽</strong> 的：</p><ol><li><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code></li><li><code>heights</code> 是一个 <strong>山脉</strong> 数组。</li></ol><p>如果存在下标 <code>i</code> 满足以下条件，那么我们称数组 <code>heights</code> 是一个 <strong>山脉</strong> 数组：</p><ul><li>对于所有 <code>0 &lt; j &lt;= i</code> ，都有 <code>heights[j - 1] &lt;= heights[j]</code></li><li>对于所有 <code>i &lt;= k &lt; n - 1</code> ，都有 <code>heights[k + 1] &lt;= heights[k]</code></li></ul><p>请你返回满足 <strong>美丽塔</strong> 要求的方案中，<strong>高度和的最大值</strong> 。</p></blockquote><ul><li><p>个人思路</p></li><li><p>官解</p><p>枚举每个山峰</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumSumOfHeights</span><span class="hljs-params">(maxHeights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(maxHeights)<br>    res := <span class="hljs-type">int64</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        pre, psum := maxHeights[i], <span class="hljs-type">int64</span>(maxHeights[i])<br>        <span class="hljs-keyword">for</span> j := i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            pre = min(pre, maxHeights[j])<br>            psum += <span class="hljs-type">int64</span>(pre)<br>        &#125;<br>        suf := maxHeights[i]<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            suf = min(suf, maxHeights[j])<br>            psum += <span class="hljs-type">int64</span>(suf)<br>        &#125;<br>        res = max(res, psum)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2859-计算-K-置位下标对应元素的和"><a href="https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits/">2859. 计算 K 置位下标对应元素的和</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>请你用整数形式返回 <code>nums</code> 中的特定元素之 <strong>和</strong> ，这些特定元素满足：其对应下标的二进制表示中恰存在 <code>k</code> 个置位。</p><p>整数的二进制表示中的 1 就是这个整数的 <strong>置位</strong> 。</p><p>例如，<code>21</code> 的二进制表示为 <code>10101</code> ，其中有 <code>3</code> 个置位。</p></blockquote><ul><li><p>个人思路</p></li><li><p>官解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumIndicesWithKSetBits</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ans := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">if</span> bitCount(i) == k &#123;<br>ans += nums[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>cnt := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &#123;<br>cnt += (x % <span class="hljs-number">2</span>)<br>x /= <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">return</span> cnt<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows重装ubuntu单系统</title>
    <link href="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1>windows重装ubuntu单系统</h1><h2 id="制作系统镜像启动安装盘">制作系统镜像启动安装盘</h2><ol><li>Ubuntu官网<a href="https://cn.ubuntu.com/download">https://cn.ubuntu.com/download</a> 下载系统镜像（.iso）文件。</li><li>UltralSO官网：<a href="https://filehippo.com/download_ultra-iso/%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%85%8D%E8%B4%B9%E8%AF%95%E7%94%A8%E7%89%88%E6%9C%AC%E3%80%82">https://filehippo.com/download_ultra-iso/直接下载免费试用版本。</a></li><li>制作启动盘<ol><li>UltraISO中打开之前下载好的Ubuntu镜像</li><li>启动-&gt;写入硬盘映像</li><li>写入方式-&gt; USB-HDD+</li><li>便捷启动——&gt;写入新的硬盘引导记录(MBR)——&gt;USB-HDD+</li><li>格式化</li><li>写入</li></ol></li></ol><h2 id="安装Ubuntu">安装Ubuntu</h2><ol><li><p>战神笔记本重启，按<code>F2</code>进入BIOS。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/CDCE28EAD22B39F996D4DC2EFF6EF405.jpg" alt="img"></p></li><li><p>Boot Manager-&gt;Linpus lite(Flash)</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/97AD853BC443D68D8E5AE96B6B5F2F46.jpg" alt="img"></p></li><li><p>选中Ubuntu（safe graphics），按e，不要按enter。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/5F257005A144FAA28695D11FE175B2CD.jpg" alt="img"></p></li><li><p>在<code>quiet splash</code>后增加<code>nomodeset</code>。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/BD899F4A12A0746978097F8D0B93CC62.jpg" alt="img"></p></li><li><p>按<code>F10</code>，进入ubuntu安装界面。正常安装即可。</p></li></ol><p>随便记录一下，校园网登录信息类型是受保护的EAP（PEAP）</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/image-20231222115359007.png" alt="image-20231222115359007"></p><h2 id="Ubuntu自定义分区">Ubuntu自定义分区</h2><p>感觉这块比较重要，单独分出来记录。</p><ol><li><p>安装类型这里选择其他选项</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/B79AE3D037A15F085E1B3D23EFBB2F45.jpg" alt="img"></p></li><li><p>将原有分区全部删除（选择分区，点击左下角的<code>-</code>号）。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/2443062DAA7A719E8C1B81BAC81EDDB6.jpg" alt="img"></p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/45A61C6AD6F20765BAA2DDFE0E72B66F.jpg" alt="img"></p></li><li><p>选择空闲，点击<code>+</code>号，用于选择<code>EFI系统分区</code>，分配330MB，主分区，空间起始位置，<code>EFI系统分区</code>。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/BD4EE859FF46B3D4ABB390AA3B25D4DF.jpg" alt="img"></p></li><li><p><code>/boot</code>，1G，逻辑分区，空间起始位置，Ext4</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/76CA24B5F47E3794BC842E853D6E07C0.jpg" alt="img"></p></li><li><p><code>/swap</code>，16G（16384MB），逻辑分区，空间起始位置，交换空间。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/BE1C6FEAD8CFEF45ACC2D6CC7E0CF8D7.jpg" alt="img"></p></li><li><p><code>/</code>，根目录，160G(163840MB)，主分区，空间起始位置，Ext4，挂载点<code>/</code>。</p></li><li><p><code>/tmp</code>，存放临时文件，5G（5120MB），逻辑分区，空间起始位置，Ext4，挂载点<code>/tmp</code>。</p></li><li><p><code>/home</code>，尽可能大，剩余空间，逻辑分区，空间起始位置，Ext4，挂载点<code>/home</code>。</p></li><li><p>最终截图，引导器选择<code>EFI系统分区</code>，这里是<code>/dev/sda1</code>继续则完成。</p><p><img src="/2023/12/22/windows%E9%87%8D%E8%A3%85ubuntu%E5%8D%95%E7%B3%BB%E7%BB%9F/3E4DBB41B77811FAA95EEE96D6FE6807.jpg" alt="img"></p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>bios</tag>
      
      <tag>神舟战神</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法笔记</title>
    <link href="/2023/12/12/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/12/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>算法笔记</h1><h2 id="单调栈">单调栈</h2><p>单调栈用于寻找比当前元素大的下一个元素。</p><h3 id="用途及例题">用途及例题</h3><p><a href="/2023/12/08/leetcode23-12/#2454-下一个更大元素-IV">2454. 下一个更大元素 IV</a></p><p><a href="/2024/01/03/leetcode24-01/#1944-队列中可以看到的人数">1944. 队列中可以看到的人数</a></p><h2 id="二维前缀和">二维前缀和</h2><p>二维前缀和用于对二维区域求和。</p><h3 id="用途及例题-2">用途及例题</h3><ol><li><p>快速判断该区域是否全为0。</p><p><a href="/2023/12/08/leetcode23-12/#2132-用邮票贴满网格图">2132. 用邮票贴满网格图</a></p></li></ol><h2 id="二维差分">二维差分</h2><p>二维差分用于对二维区域进行加减操作。</p><p><a href="/2023/12/08/leetcode23-12/#2132-用邮票贴满网格图">2132. 用邮票贴满网格图</a></p><h2 id="珂朵莉树">珂朵莉树</h2><p><a href="https://zhuanlan.zhihu.com/p/106353082">算法学习笔记(15): 珂朵莉树 - 知乎 (zhihu.com)</a></p><h3 id="思想">思想</h3><p>适用于<strong>区间赋值</strong>，其思想是使用三元组<code>&lt;l,r,v&gt;</code>表示数组从<code>l</code>到<code>r</code>的数据都是<code>v</code>。</p><h3 id="例题">例题</h3><ul><li><p><a href="/2023/12/08/leetcode23-12/#2276-统计区间中的整数数目">2276. 统计区间中的整数数目</a></p><p>统计区间，用<code>&lt;l,r&gt;</code>表示区间<code>[left,right]</code></p></li></ul><h2 id="平衡树">平衡树</h2><p><a href="https://zhuanlan.zhihu.com/p/343216590">平衡二叉树 通俗易懂 - 知乎 (zhihu.com)</a></p><h3 id="思想-2">思想</h3><p>有两种实现方式，平衡二叉树和红黑树。重点是可以<strong>提高查询速率</strong>。</p><ol><li>平衡二叉树的两个条件，通过高度差控制平衡。<ol><li>是「二叉排序树」（即1.左子树&lt;根节点&lt;右子树2.左右子树均是二叉排序树）</li><li>任何一个节点的左子树或者右子树都是「平衡二叉树」（左右高度差小于等于 1）</li></ol></li><li>红黑树的条件，通过颜色控制<ol><li>每个节点是红色或者黑色；</li><li>根节点是黑色；</li><li>所有叶子节点都是黑色（叶子是NIL节点，也称为外节点）;</li><li>每个红色节点的子节点都是黑色（从每个叶子节点到根节点的所有路径上不能有两个连续的红色节点）；</li><li>从红黑树的任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点（包含黑色节点的数目称为该节点的黑高度）。</li></ol></li></ol><h3 id="例题-2">例题</h3><ul><li><p><a href="/2023/12/08/leetcode23-12/#2276-统计区间中的整数数目">2276. 统计区间中的整数数目</a></p><p>用平衡树统计区间，便于查找第一个被新加入区间覆盖的区间。算法实现上使用红黑树。</p></li></ul><h2 id="二分查找">二分查找</h2><h3 id="例题-3">例题</h3><ul><li><p><a href="/2023/12/08/leetcode23-12/#162-寻找峰值">162. 寻找峰值</a></p><p>比较特殊，数组不一定需要有序，根据答案的存在性而进行二分。</p></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>单调栈</tag>
      
      <tag>二维前缀和</tag>
      
      <tag>二维差分</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode23-12</title>
    <link href="/2023/12/08/leetcode23-12/"/>
    <url>/2023/12/08/leetcode23-12/</url>
    
    <content type="html"><![CDATA[<h1>leetcode23-12刷题笔记</h1><p>去西安，一晃已经8号了。</p><h2 id="2008-出租车的最大盈利"><a href="https://leetcode.cn/problems/maximum-earnings-from-taxi/">2008. 出租车的最大盈利</a></h2><blockquote><p>你驾驶出租车行驶在一条有 <code>n</code> 个地点的路上。这 <code>n</code> 个地点从近到远编号为 <code>1</code> 到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code> ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。</p><p>乘客信息用一个下标从 <strong>0</strong> 开始的二维数组 <code>rides</code> 表示，其中 <code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code> 前往 <code>endi</code> ，愿意支付 <code>tipi</code> 元的小费。</p><p><strong>每一位</strong> 你选择接单的乘客 <code>i</code> ，你可以 <strong>盈利</strong> <code>endi - starti + tipi</code> 元。你同时 <strong>最多</strong> 只能接一个订单。</p><p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 <strong>最多</strong> 多少元。</p><p>**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>dp</p><p>考虑<code>dp[n]</code>表示从地点<code>1</code>到地点<code>n</code>所能获得的最大利益。可以从小到大遍历计算<code>dp[i]</code>，其转移公式为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>n</mi><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><msub><mi>t</mi><mi>j</mi></msub><mo stretchy="false">]</mo><mo>+</mo><mi>e</mi><mi>n</mi><msub><mi>d</mi><mi>j</mi></msub><mo>−</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><msub><mi>t</mi><mi>j</mi></msub><mo>+</mo><mi>t</mi><mi>i</mi><msub><mi>p</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>e</mi><mi>n</mi><msub><mi>d</mi><mi>j</mi></msub><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">dp[i]=max(maxn,dp[start_j]+end_j-start_j+tip_j),end_j=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9012em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></span></p><p>意为若此时存在以<code>i</code>为目的地的订单，则计算选择该订单的收入和遍历过程中的最大值<code>maxn</code>相比较，保存最大值。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(n <span class="hljs-type">int</span>, rides [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>start, end, tip := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> maxn <span class="hljs-type">int64</span> = <span class="hljs-number">0</span><br>dp, rides_ptr := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, n+<span class="hljs-number">1</span>), <span class="hljs-number">0</span><br>sort.Slice(rides, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> rides[i][end] &lt; rides[j][end]<br>&#125;)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>dp[i] = maxn<br><span class="hljs-keyword">for</span> ; rides_ptr &lt; <span class="hljs-built_in">len</span>(rides) &amp;&amp; rides[rides_ptr][end] == i; rides_ptr++ &#123;<br>income := rides[rides_ptr][end] - rides[rides_ptr][start] + rides[rides_ptr][tip]<br>dp[i] = my_max(dp[i], dp[rides[rides_ptr][start]]+<span class="hljs-type">int64</span>(income))<br><span class="hljs-keyword">if</span> maxn &lt; dp[i] &#123;<br>maxn = dp[i]<br>&#125;<br>&#125;<br><span class="hljs-comment">//fmt.Printf(&quot;i:%d,dp[i]:%d\n&quot;, i, dp[i])</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><ul><li><p>dp+二分</p><p><code>maxn</code>是没必要的，<code>dp[i-1]</code>一定是遍历到<code>i</code>的最大值，<code>sort.Search</code>就是二分查找。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxTaxiEarnings</span><span class="hljs-params">(n <span class="hljs-type">int</span>, rides [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    sort.Slice(rides, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> rides[i][<span class="hljs-number">1</span>] &lt; rides[j][<span class="hljs-number">1</span>]<br>    &#125;)<br>    m := <span class="hljs-built_in">len</span>(rides)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        j := sort.Search(i + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> rides[k][<span class="hljs-number">1</span>] &gt; rides[i][<span class="hljs-number">0</span>]<br>        &#125;)<br>        dp[i + <span class="hljs-number">1</span>] = max(dp[i], dp[j] + <span class="hljs-type">int64</span>(rides[i][<span class="hljs-number">1</span>] - rides[i][<span class="hljs-number">0</span>] + rides[i][<span class="hljs-number">2</span>]))<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2048-下一个更大的数值平衡数"><a href="https://leetcode.cn/problems/next-greater-numerically-balanced-number/">2048. 下一个更大的数值平衡数</a></h2><blockquote><p>如果整数 <code>x</code> 满足：对于每个数位 <code>d</code> ，这个数位 <strong>恰好</strong> 在 <code>x</code> 中出现 <code>d</code> 次。那么整数 <code>x</code> 就是一个 <strong>数值平衡数</strong> 。</p><p>给你一个整数 <code>n</code> ，请你返回 <strong>严格大于</strong> <code>n</code> 的 <strong>最小数值平衡数</strong> 。</p></blockquote><ul><li><p>个人思路</p><p>烦人的细节题</p></li><li><p>官解</p><ul><li><p>枚举</p><p>竟然是直接枚举的，不是构造出来的。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalance</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">for</span> x &gt; <span class="hljs-number">0</span> &#123;<br>        count[x % <span class="hljs-number">10</span>]++<br>        x /= <span class="hljs-number">10</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> count[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count[i] != i &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> i := n + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1224444</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> isBalance(i) &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>打表</p><p>打表秒了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> balance = []<span class="hljs-type">int</span>&#123;<br><span class="hljs-number">1</span>, <span class="hljs-number">22</span>, <span class="hljs-number">122</span>, <span class="hljs-number">212</span>, <span class="hljs-number">221</span>, <span class="hljs-number">333</span>, <span class="hljs-number">1333</span>, <span class="hljs-number">3133</span>, <span class="hljs-number">3313</span>, <span class="hljs-number">3331</span>, <span class="hljs-number">4444</span>,<br><span class="hljs-number">14444</span>, <span class="hljs-number">22333</span>, <span class="hljs-number">23233</span>, <span class="hljs-number">23323</span>, <span class="hljs-number">23332</span>, <span class="hljs-number">32233</span>, <span class="hljs-number">32323</span>, <span class="hljs-number">32332</span>,<br><span class="hljs-number">33223</span>, <span class="hljs-number">33232</span>, <span class="hljs-number">33322</span>, <span class="hljs-number">41444</span>, <span class="hljs-number">44144</span>, <span class="hljs-number">44414</span>, <span class="hljs-number">44441</span>, <span class="hljs-number">55555</span>,<br><span class="hljs-number">122333</span>, <span class="hljs-number">123233</span>, <span class="hljs-number">123323</span>, <span class="hljs-number">123332</span>, <span class="hljs-number">132233</span>, <span class="hljs-number">132323</span>, <span class="hljs-number">132332</span>,<br><span class="hljs-number">133223</span>, <span class="hljs-number">133232</span>, <span class="hljs-number">133322</span>, <span class="hljs-number">155555</span>, <span class="hljs-number">212333</span>, <span class="hljs-number">213233</span>, <span class="hljs-number">213323</span>,<br><span class="hljs-number">213332</span>, <span class="hljs-number">221333</span>, <span class="hljs-number">223133</span>, <span class="hljs-number">223313</span>, <span class="hljs-number">223331</span>, <span class="hljs-number">224444</span>, <span class="hljs-number">231233</span>,<br><span class="hljs-number">231323</span>, <span class="hljs-number">231332</span>, <span class="hljs-number">232133</span>, <span class="hljs-number">232313</span>, <span class="hljs-number">232331</span>, <span class="hljs-number">233123</span>, <span class="hljs-number">233132</span>,<br><span class="hljs-number">233213</span>, <span class="hljs-number">233231</span>, <span class="hljs-number">233312</span>, <span class="hljs-number">233321</span>, <span class="hljs-number">242444</span>, <span class="hljs-number">244244</span>, <span class="hljs-number">244424</span>,<br><span class="hljs-number">244442</span>, <span class="hljs-number">312233</span>, <span class="hljs-number">312323</span>, <span class="hljs-number">312332</span>, <span class="hljs-number">313223</span>, <span class="hljs-number">313232</span>, <span class="hljs-number">313322</span>,<br><span class="hljs-number">321233</span>, <span class="hljs-number">321323</span>, <span class="hljs-number">321332</span>, <span class="hljs-number">322133</span>, <span class="hljs-number">322313</span>, <span class="hljs-number">322331</span>, <span class="hljs-number">323123</span>,<br><span class="hljs-number">323132</span>, <span class="hljs-number">323213</span>, <span class="hljs-number">323231</span>, <span class="hljs-number">323312</span>, <span class="hljs-number">323321</span>, <span class="hljs-number">331223</span>, <span class="hljs-number">331232</span>,<br><span class="hljs-number">331322</span>, <span class="hljs-number">332123</span>, <span class="hljs-number">332132</span>, <span class="hljs-number">332213</span>, <span class="hljs-number">332231</span>, <span class="hljs-number">332312</span>, <span class="hljs-number">332321</span>,<br><span class="hljs-number">333122</span>, <span class="hljs-number">333212</span>, <span class="hljs-number">333221</span>, <span class="hljs-number">422444</span>, <span class="hljs-number">424244</span>, <span class="hljs-number">424424</span>, <span class="hljs-number">424442</span>,<br><span class="hljs-number">442244</span>, <span class="hljs-number">442424</span>, <span class="hljs-number">442442</span>, <span class="hljs-number">444224</span>, <span class="hljs-number">444242</span>, <span class="hljs-number">444422</span>, <span class="hljs-number">515555</span>,<br><span class="hljs-number">551555</span>, <span class="hljs-number">555155</span>, <span class="hljs-number">555515</span>, <span class="hljs-number">555551</span>, <span class="hljs-number">666666</span>, <span class="hljs-number">1224444</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextBeautifulNumber</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> balance[sort.SearchInts(balance, n+<span class="hljs-number">1</span>)]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="70-爬楼梯"><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><blockquote><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><ul><li><p>个人思路</p><ul><li><p>dp</p><p>好久不见的简单题，一眼dp。<code>dp[n]</code>表示爬到<code>n</code>阶有多少种方法，则<code>dp[n]=dp[n-1]+dp[n-1]</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)<br>dp[<span class="hljs-number">1</span>], dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt;= n; i++ &#123;<br>dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>&#125;<br><span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><ul><li>dp</li><li>矩阵快速幂</li><li>通项公式</li></ul></li></ul><h2 id="1631-最小体力消耗路径"><a href="https://leetcode.cn/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h2><blockquote><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>暴力dfs</p><p>直接超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> b - a<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(heights, vis [][]<span class="hljs-type">int</span>, x, y, h_diff <span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>row, col := <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">if</span> x == row<span class="hljs-number">-1</span> &amp;&amp; y == col<span class="hljs-number">-1</span> &amp;&amp; h_diff &lt; *res &#123;<br>*res = h_diff<br><span class="hljs-keyword">return</span><br>&#125;<br>direction := [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>nx, ny := x+direction[i][<span class="hljs-number">0</span>], y+direction[i][<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> nx &gt; <span class="hljs-number">-1</span> &amp;&amp; ny &gt; <span class="hljs-number">-1</span> &amp;&amp; nx &lt; row &amp;&amp; ny &lt; col &amp;&amp; vis[nx][ny] == <span class="hljs-number">0</span> &#123;<br>nh_diff := max(h_diff, abs(heights[x][y], heights[nx][ny]))<br>vis[nx][ny] = <span class="hljs-number">1</span><br>dfs(heights, vis, nx, ny, nh_diff, res)<br>vis[nx][ny] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(heights [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>h_diff, row, col := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span> = <span class="hljs-number">1e6</span> + <span class="hljs-number">1</span><br>vis := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, row)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; row; i++ &#123;<br>vis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, col)<br>&#125;<br>dfs(heights, vis, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, h_diff, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试优化</p><ul><li>当<code>nh_diff</code>大于<code>res</code>时，停止搜索。</li><li>用<code>diff</code>保存每个格子不同方向的高度差，减少重复计算次数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> direction = [<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a - b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> b - a<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(heights, vis [][]<span class="hljs-type">int</span>, diff [][][]<span class="hljs-type">int</span>, x, y, h_diff <span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br>row, col := <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">if</span> x == row<span class="hljs-number">-1</span> &amp;&amp; y == col<span class="hljs-number">-1</span> &amp;&amp; h_diff &lt; *res &#123;<br>*res = h_diff<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>nx, ny := x+direction[i][<span class="hljs-number">0</span>], y+direction[i][<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> diff[x][y][i] != <span class="hljs-number">-1</span> &amp;&amp; vis[nx][ny] == <span class="hljs-number">0</span> &#123;<br>nh_diff := max(h_diff, diff[x][y][i])<br><span class="hljs-keyword">if</span> nh_diff &lt; *res &#123;<br>vis[nx][ny] = <span class="hljs-number">1</span><br>dfs(heights, vis, diff, nx, ny, nh_diff, res)<br>vis[nx][ny] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(heights [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>h_diff, row, col := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">var</span> res <span class="hljs-type">int</span> = <span class="hljs-number">1e6</span> + <span class="hljs-number">1</span><br>vis := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, row)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; row; i++ &#123;<br>vis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, col)<br>&#125;<br>diff := <span class="hljs-built_in">make</span>([][][]<span class="hljs-type">int</span>, row)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; row; i++ &#123;<br>diff[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, col)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; col; j++ &#123;<br>diff[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">4</span>)<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++ &#123;<br>nx, ny := i+direction[k][<span class="hljs-number">0</span>], j+direction[k][<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> nx &gt; <span class="hljs-number">-1</span> &amp;&amp; ny &gt; <span class="hljs-number">-1</span> &amp;&amp; nx &lt; row &amp;&amp; ny &lt; col &#123;<br>diff[i][j][k] = abs(heights[i][j], heights[nx][ny])<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>diff[i][j][k] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>dfs(heights, vis, diff, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, h_diff, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>还是超时</p><p>Time Limit Exceeded</p><ul><li>15/75 cases passed (N/A)</li></ul></li><li><p>dp</p><p>不对，这是个dp，用<code>dp[x][y]</code>表示到<code>x,y</code>处的最小体力消耗值。不对，他可以四个方向走。</p></li></ul></li><li><p>官解</p><p>该题可以抽象为图论模型，每个格子都是一个点，边的权值是高度差。</p><ul><li><p>二分查找</p><p>我们可以将这个问题转化成一个「判定性」问题，即：</p><p>是否存在一条从左上角到右下角的路径，其经过的所有边权的最大值不超过 xxx？</p><p>这个判定性问题解决起来并不复杂，我们只要从左上角开始进行深度优先搜索或者广度优先搜索，在搜索的过程中只允许经过边权不超过 xxx 的边，搜索结束后判断是否能到达右下角即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;<br><span class="hljs-keyword">var</span> dirs = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(heights [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n, m := <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> sort.Search(<span class="hljs-number">1e6</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(maxHeightDiff <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        vis := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> vis &#123;<br>            vis[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, m)<br>        &#125;<br>        vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>        queue := []pair&#123;&#123;&#125;&#125;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>            p := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> p.x == n<span class="hljs-number">-1</span> &amp;&amp; p.y == m<span class="hljs-number">-1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>                x, y := p.x+d.x, p.y+d.y<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt; m &amp;&amp; !vis[x][y] &amp;&amp; abs(heights[x][y]-heights[p.x][p.y]) &lt;= maxHeightDiff &#123;<br>                    vis[x][y] = <span class="hljs-literal">true</span><br>                    queue = <span class="hljs-built_in">append</span>(queue, pair&#123;x, y&#125;)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>发现我的<code>abs</code>函数是乱写的。</p></li><li><p>并查集</p><p>我们将这 mn 个节点放入并查集中，实时维护它们的连通性。</p><p>由于我们需要找到从左上角到右下角的最短路径，因此我们可以将图中的所有边按照权值从小到大进行排序，并依次加入并查集中。当我们加入一条权值为 x 的边之后，如果左上角和右下角从非连通状态变为连通状态，那么 x 即为答案。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> unionFind <span class="hljs-keyword">struct</span> &#123;<br>    parent, size []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newUnionFind</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> *unionFind &#123;<br>    parent := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    size := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> parent &#123;<br>        parent[i] = i<br>        size[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;unionFind&#123;parent, size&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(uf *unionFind)</span></span> find(x <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> uf.parent[x] != x &#123;<br>        uf.parent[x] = uf.find(uf.parent[x])<br>    &#125;<br>    <span class="hljs-keyword">return</span> uf.parent[x]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(uf *unionFind)</span></span> union(x, y <span class="hljs-type">int</span>) &#123;<br>    fx, fy := uf.find(x), uf.find(y)<br>    <span class="hljs-keyword">if</span> fx == fy &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> uf.size[fx] &lt; uf.size[fy] &#123;<br>        fx, fy = fy, fx<br>    &#125;<br>    uf.size[fx] += uf.size[fy]<br>    uf.parent[fy] = fx<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(uf *unionFind)</span></span> inSameSet(x, y <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> uf.find(x) == uf.find(y)<br>&#125;<br><br><span class="hljs-keyword">type</span> edge <span class="hljs-keyword">struct</span> &#123;<br>    v, w, diff <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(heights [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n, m := <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>    edges := []edge&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> heights &#123;<br>        <span class="hljs-keyword">for</span> j, h := <span class="hljs-keyword">range</span> row &#123;<br>            id := i*m + j<br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>                edges = <span class="hljs-built_in">append</span>(edges, edge&#123;id - m, id, abs(h - heights[i<span class="hljs-number">-1</span>][j])&#125;)<br>            &#125;<br>            <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> &#123;<br>                edges = <span class="hljs-built_in">append</span>(edges, edge&#123;id - <span class="hljs-number">1</span>, id, abs(h - heights[i][j<span class="hljs-number">-1</span>])&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br>    sort.Slice(edges, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> edges[i].diff &lt; edges[j].diff &#125;)<br><br>    uf := newUnionFind(n * m)<br>    <span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> edges &#123;<br>        uf.union(e.v, e.w)<br>        <span class="hljs-keyword">if</span> uf.inSameSet(<span class="hljs-number">0</span>, n*m<span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> e.diff<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最短路</p><p><img src="/2023/12/08/leetcode23-12/image-20231211140811233.png" alt="image-20231211140811233"></p><p>妙啊，以及堆<code>heap</code>的使用，通过实现接口</p><p><a href="https://zhuanlan.zhihu.com/p/373074591">Go基础：heap的介绍与使用 - 知乎 (zhihu.com)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span>&#123; x, y, maxDiff <span class="hljs-type">int</span> &#125;<br><span class="hljs-keyword">type</span> hp []point<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Len() <span class="hljs-type">int</span>              &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span>    &#123; <span class="hljs-keyword">return</span> h[i].maxDiff &lt; h[j].maxDiff &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Swap(i, j <span class="hljs-type">int</span>)         &#123; h[i], h[j] = h[j], h[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;)   &#123; *h = <span class="hljs-built_in">append</span>(*h, v.(point)) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Pop() (v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; a := *h; *h, v = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>], a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]; <span class="hljs-keyword">return</span> &#125;<br><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;<br><span class="hljs-keyword">var</span> dir4 = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(heights [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n, m := <span class="hljs-built_in">len</span>(heights), <span class="hljs-built_in">len</span>(heights[<span class="hljs-number">0</span>])<br>    maxDiff := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> maxDiff &#123;<br>        maxDiff[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> maxDiff[i] &#123;<br>            maxDiff[i][j] = math.MaxInt64<br>        &#125;<br>    &#125;<br>    maxDiff[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    h := &amp;hp&#123;&#123;&#125;&#125;<br>    <span class="hljs-keyword">for</span> &#123;<br>        p := heap.Pop(h).(point)<br>        <span class="hljs-keyword">if</span> p.x == n<span class="hljs-number">-1</span> &amp;&amp; p.y == m<span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">return</span> p.maxDiff<br>        &#125;<br>        <span class="hljs-keyword">if</span> maxDiff[p.x][p.y] &lt; p.maxDiff &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dir4 &#123;<br>            <span class="hljs-keyword">if</span> x, y := p.x+d.x, p.y+d.y; <span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt; n &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt; m &#123;<br>                <span class="hljs-keyword">if</span> diff := max(p.maxDiff, abs(heights[x][y]-heights[p.x][p.y])); diff &lt; maxDiff[x][y] &#123;<br>                    maxDiff[x][y] = diff<br>                    heap.Push(h, point&#123;x, y, diff&#125;)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/QLeelq/article/details/113862917">【算法】路径规划中的Dijkstra(狄克斯特拉)与A星算法_dijkstra和a星算法的差异-CSDN博客</a></p></li></ul></li></ul><h2 id="2454-下一个更大元素-IV"><a href="https://leetcode.cn/problems/next-greater-element-iv/">2454. 下一个更大元素 IV</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的非负整数数组 <code>nums</code> 。对于 <code>nums</code> 中每一个整数，你必须找到对应元素的 <strong>第二大</strong> 整数。</p><p>如果 <code>nums[j]</code> 满足以下条件，那么我们称它为 <code>nums[i]</code> 的 <strong>第二大</strong> 整数：</p><ul><li><code>j &gt; i</code></li><li><code>nums[j] &gt; nums[i]</code></li><li>恰好存在 <strong>一个</strong> <code>k</code> 满足 <code>i &lt; k &lt; j</code> 且 <code>nums[k] &gt; nums[i]</code> 。</li></ul><p>如果不存在 <code>nums[j]</code> ，那么第二大整数为 <code>-1</code> 。</p><ul><li>比方说，数组 <code>[1, 2, 4, 3]</code> 中，<code>1</code> 的第二大整数是 <code>4</code> ，<code>2</code> 的第二大整数是 <code>3</code> ，<code>3</code> 和 <code>4</code> 的第二大整数是 <code>-1</code> 。</li></ul><p>请你返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code>是 <code>nums[i]</code> 的第二大整数。</p></blockquote><ul><li><p>个人思路</p><p>已知前面数的第二大整数对后面数没有帮助，无论后面数是大于前面数还是小于前面数，除非等于且在前面数和第一大整数之间。</p><p>倒是可以先排序成一个新数组，寻找更大元素，但如何保证是第二大呢。</p><p><img src="/2023/12/08/leetcode23-12/image-20231212103241027.png" alt="image-20231212103241027"></p><p>看不太懂，但是栈。考虑<code>n</code>个数，我们维护<code>n</code>个长度为3的栈（其实是数组）来记录第一二大的元素。遍历<code>nums</code>，如<code>nums[i]</code>，先将其置入<code>stack[i][0]</code>，然后遍历<code>stack[i]</code>之前的数组，大于<code>stack[i][0]</code>则<code>push</code>。嘶，这好像是暴力枚举，时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><blockquote><p>Time Limit Exceeded</p><ul><li>45/51 cases passed (N/A)</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">secondGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(nums)<br>s := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>s[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>s[i][<span class="hljs-number">0</span>] = nums[i]<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> nums[i] &gt; nums[j] &amp;&amp; <span class="hljs-built_in">len</span>(s[j]) &lt; <span class="hljs-number">3</span> &#123;<br>s[j] = <span class="hljs-built_in">append</span>(s[j], nums[i])<br>&#125;<br>&#125;<br>&#125;<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s[i]) &lt; <span class="hljs-number">3</span> &#123;<br>res[i] = <span class="hljs-number">-1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res[i] = s[i][<span class="hljs-number">2</span>]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>提示2中提到<code>an ordered data structure</code>，提示1的<code>non-increasing</code>是指数值还是栈的长度</p></li><li><p>官解</p><ul><li><p>单调栈（non-increasing stack)</p><blockquote><p>我们可以考虑将原始问题简化为计算数组中每个数字的下一个比它大的数字。为了解决这一问题，我们可以利用「单调栈」算法。该算法的核心思想是利用一个栈来存储数组元素的下标。在遍历数组时，对于每个元素，执行以下操作：如果当前元素大于栈顶元素对应的值，说明找到了栈顶元素的下一个更大的数字，将栈顶元素出栈，并更新结果数组。如果当前元素小于等于栈顶元素对应的值，将当前元素的下标压入栈中，保持栈的单调递减性质。这样，最终结果数组中存储的就是每个数字的下一个比它大的数字（如果存在的话），如果没有更大的数字，则对应位置的值为 -1。</p></blockquote><p>下面图解是将数值压入栈，而不是下标。</p><p><img src="/2023/12/08/leetcode23-12/image-20231212110319783.png" alt="image-20231212110319783"></p><p>这样，通过单调栈找到第一大元素。如何寻找第二大元素，类似单调栈，用堆记录从栈中出来的元素，即需要寻找第二大的元素。</p><p><img src="/2023/12/08/leetcode23-12/image-20231212110643288.png" alt="image-20231212110643288"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pair <span class="hljs-keyword">struct</span> &#123; <br>    first <span class="hljs-type">int</span><br>    second <span class="hljs-type">int</span> <br>&#125;<br><br><span class="hljs-keyword">type</span> hp []Pair<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Len() <span class="hljs-type">int</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <br>    a, b := h[i], h[j]<br>    <span class="hljs-keyword">return</span> a.first &lt; b.first || a.first == b.first &amp;&amp; a.second &lt; b.second <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; <br>    h[i], h[j] = h[j], h[i] <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <br>    *h = <span class="hljs-built_in">append</span>(*h, v.(Pair)) <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123; <br>    a := *h<br>    v := a[<span class="hljs-built_in">len</span>(a) - <span class="hljs-number">1</span>] <br>    *h = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> v <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">secondGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        res[i] = <span class="hljs-number">-1</span><br>    &#125;<br>    st := []<span class="hljs-type">int</span>&#123;&#125;<br>    q := hp&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &amp;&amp; q[<span class="hljs-number">0</span>].first &lt; nums[i] &#123;<br>            res[q[<span class="hljs-number">0</span>].second] = nums[i]<br>            heap.Pop(&amp;q)<br>        &#125;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(st) &gt; <span class="hljs-number">0</span> &amp;&amp; nums[st[<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>]] &lt; nums[i] &#123;<br>            heap.Push(&amp;q, Pair&#123;nums[st[<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>]], st[<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>]&#125;)<br>            st = st[:<span class="hljs-built_in">len</span>(st) - <span class="hljs-number">1</span>]<br>        &#125;<br>        st = <span class="hljs-built_in">append</span>(st, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>双单调栈</p><p>单调栈中的数据就是非递增的，故可以使用第二个单调栈代替最小堆。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">secondGreaterElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        res[i] = <span class="hljs-number">-1</span><br>    &#125;<br>    st1, st2 := []<span class="hljs-type">int</span>&#123;&#125;, []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        v := nums[i]<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(st2) &gt; <span class="hljs-number">0</span> &amp;&amp; nums[st2[<span class="hljs-built_in">len</span>(st2) - <span class="hljs-number">1</span>]] &lt; v &#123;<br>            res[st2[<span class="hljs-built_in">len</span>(st2) - <span class="hljs-number">1</span>]] = v<br>            st2 = st2[: <span class="hljs-built_in">len</span>(st2) - <span class="hljs-number">1</span>]<br>        &#125;<br>        pos := <span class="hljs-built_in">len</span>(st1) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> pos &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[st1[pos]] &lt; v &#123;<br>            pos--<br>        &#125;<br>        st2 = <span class="hljs-built_in">append</span>(st2, st1[pos + <span class="hljs-number">1</span>:]...)<br>        st1 = <span class="hljs-built_in">append</span>(st1[: pos + <span class="hljs-number">1</span>], i)<br>    &#125;   <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>上述题解之所以存的是下标是因为我们需要知道对应位置上的第二大元素是多少<code>res[st2[len(st2) - 1]] = v</code>。</p><p>此处使用数组模拟栈，故将st1的出栈元素按照st1的顺序加入的st2中（这样才是非递增的）较为简单。但若使用其他语言的stack的push和pop操作，可以使用第三个栈来做中转（栈可以调转顺序）。</p><p><img src="/2023/12/08/leetcode23-12/image-20231212113255727.png" alt="image-20231212113255727"></p></li></ul><h2 id="2697-字典序最小回文串"><a href="https://leetcode.cn/problems/lexicographically-smallest-palindrome/">2697. 字典序最小回文串</a></h2><blockquote><p>给你一个由 <strong>小写英文字母</strong> 组成的字符串 <code>s</code> ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 <strong>替换</strong> <code>s</code> 中的一个字符。</p><p>请你执行 <strong>尽可能少的操作</strong> ，使 <code>s</code> 变成一个 <strong>回文串</strong> 。如果执行 <strong>最少</strong> 操作次数的方案不止一种，则只需选取 <strong>字典序最小</strong> 的方案。</p><p>对于两个长度相同的字符串 <code>a</code> 和 <code>b</code> ，在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置，如果该位置上 <code>a</code> 中对应字母比 <code>b</code> 中对应字母在字母表中出现顺序更早，则认为 <code>a</code> 的字典序比 <code>b</code> 的字典序要小。</p><p>返回最终的回文字符串。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>双指针</p><p>左右指针遍历对称的字符，不一样则选择字典序小的那个变化，一样则不做处理。</p><p>AC，注意go中字符串不能通过索引去修改，需要转化成<code>byte[]</code>再修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSmallestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">for</span> left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; left &lt; right; left, right = left+<span class="hljs-number">1</span>, right<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">if</span> s[left] == s[right] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>temp := []<span class="hljs-type">byte</span>(s)<br><span class="hljs-keyword">if</span> s[left] &lt; s[right] &#123;<br>temp[right] = temp[left]<br>s = <span class="hljs-type">string</span>(temp)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>temp[left] = temp[right]<br>s = <span class="hljs-type">string</span>(temp)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><p>更优美且高效的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSmallestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    t := []<span class="hljs-type">byte</span>(s)<br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        <span class="hljs-keyword">if</span> s[left] != s[right] &#123;<br>            t[left] = min(s[left], s[right])<br>            t[right] = t[left]<br>        &#125;<br>        left++<br>        right--<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2132-用邮票贴满网格图"><a href="https://leetcode.cn/problems/stamping-the-grid/">2132. 用邮票贴满网格图</a></h2><blockquote><p>给你一个 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，每个格子要么为 <code>0</code> （空）要么为 <code>1</code> （被占据）。</p><p>给你邮票的尺寸为 <code>stampHeight x stampWidth</code> 。我们想将邮票贴进二进制矩阵中，且满足以下 <strong>限制</strong> 和 <strong>要求</strong> ：</p><ol><li>覆盖所有 <strong>空</strong> 格子。</li><li>不覆盖任何 <strong>被占据</strong> 的格子。</li><li>我们可以放入任意数目的邮票。</li><li>邮票可以相互有 <strong>重叠</strong> 部分。</li><li>邮票不允许 <strong>旋转</strong> 。</li><li>邮票必须完全在矩阵 <strong>内</strong> 。</li></ol><p>如果在满足上述要求的前提下，可以放入邮票，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p></blockquote><ul><li><p>个人思路</p><p>我直接学习！</p></li><li><p>官解</p><ul><li><p>二维前缀和和二维差分</p><p>今天的题解十分清晰。</p><p><a href="https://leetcode.cn/problems/stamping-the-grid/solutions/2562069/yong-you-piao-tie-man-wang-ge-tu-by-leet-kiaq/?envType=daily-question&amp;envId=2023-12-14">2132. 用邮票贴满网格图 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/stamping-the-grid/solutions/1199642/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/?envType=daily-question&amp;envId=2023-12-14">2132. 用邮票贴满网格图 - 力扣（LeetCode）</a></p><blockquote><p>题目要求使用固定尺寸的邮票贴进二进制矩阵中，由于邮票之间可以重叠，因此我们本着能放就放的原则，遍历每个空格作为邮票左上角，如果右下角形状为 stampHeight×stampWidth 的范围内都是空格子，那么就在这贴一个邮票。</p><p>最后，如果有空格子没有被邮票覆盖，则说明无法满足题目要求，返回 false\text{false}false，反之如果所有的空格子都被邮票覆盖，返回 true\text{true}true。</p><p>在这个算法中，我们需要解决两个问题：</p><ol><li>贴邮票时，如何快速判断右下角固定范围内不存在被占据的格子，而都是空格子呢？</li><li>最后做检查时，如何快速判断每个空格子都被邮票覆盖呢？</li></ol></blockquote><ul><li><p>对于第一个问题，采用二维前缀和，被占据的格子是1，未被占据的格子是0，如果该区域的前缀和是0，则说明该区域内不存在被占据的格子，该前缀和可以一开始就被计算出来。</p></li><li><p>对于第二个问题，我们首先要想清楚如何快速的把邮票放在格子中（即如何快速的给二维区域+1），所以使用二维差分。最后如何检查，需要对二维差分数组求前缀和，还原成表示格子的数组，再看是否还有为0的格子。</p><p><img src="/2023/12/08/leetcode23-12/image-20231214101716935.png" alt="image-20231214101716935"></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">possibleToStamp</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, stampHeight, stampWidth <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 1. 计算 grid 的二维前缀和</span><br>    s := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    s[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        s[i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j, v := <span class="hljs-keyword">range</span> row &#123;<br>            s[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = s[i+<span class="hljs-number">1</span>][j] + s[i][j+<span class="hljs-number">1</span>] - s[i][j] + v<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 计算二维差分</span><br>    <span class="hljs-comment">// 为方便第 3 步的计算，在 d 数组的最上面和最左边各加了一行（列），所以下标要 +1</span><br>    d := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> d &#123;<br>        d[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">2</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i2 := stampHeight; i2 &lt;= m; i2++ &#123;<br>        <span class="hljs-keyword">for</span> j2 := stampWidth; j2 &lt;= n; j2++ &#123;<br>            i1 := i2 - stampHeight + <span class="hljs-number">1</span><br>            j1 := j2 - stampWidth + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> s[i2][j2]-s[i2][j1<span class="hljs-number">-1</span>]-s[i1<span class="hljs-number">-1</span>][j2]+s[i1<span class="hljs-number">-1</span>][j1<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                d[i1][j1]++<br>                d[i1][j2+<span class="hljs-number">1</span>]--<br>                d[i2+<span class="hljs-number">1</span>][j1]--<br>                d[i2+<span class="hljs-number">1</span>][j2+<span class="hljs-number">1</span>]++<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 还原二维差分矩阵对应的计数矩阵（原地计算）</span><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, v := <span class="hljs-keyword">range</span> row &#123;<br>            d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] += d[i+<span class="hljs-number">1</span>][j] + d[i][j+<span class="hljs-number">1</span>] - d[i][j]<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &amp;&amp; d[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2415-反转二叉树的奇数层"><a href="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/">2415. 反转二叉树的奇数层</a></h2><blockquote><p>给你一棵 <strong>完美</strong> 二叉树的根节点 <code>root</code> ，请你反转这棵树中每个 <strong>奇数</strong> 层的节点值。</p><ul><li>例如，假设第 3 层的节点值是 <code>[2,1,3,4,7,11,29,18]</code> ，那么反转后它应该变成 <code>[18,29,11,7,4,3,1,2]</code> 。</li></ul><p>反转后，返回树的根节点。</p><p><strong>完美</strong> 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p><p>节点的 <strong>层数</strong> 等于该节点到根节点之间的边数。</p></blockquote><ul><li><p>个人思路</p><p>层序遍历，当到奇数层时，反转一下。</p><p>AC，注意结构体数组的写法，直接<code>queue:=[]*TreeNode&#123;root&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseOddLevels</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>level := <span class="hljs-number">0</span><br>queue := []*TreeNode&#123;root&#125;<br>next_queue := []*TreeNode&#123;&#125;<br><span class="hljs-keyword">var</span> node *TreeNode<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>level++<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>node, queue = queue[<span class="hljs-number">0</span>], queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>next_queue = <span class="hljs-built_in">append</span>(next_queue, node.Left)<br>next_queue = <span class="hljs-built_in">append</span>(next_queue, node.Right)<br>&#125;<br><span class="hljs-keyword">if</span> level%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>stack := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(next_queue))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(next_queue); i++ &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, next_queue[i].Val)<br>&#125;<br><br><span class="hljs-keyword">for</span> index := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span>; index++ &#123;<br><span class="hljs-keyword">var</span> val <span class="hljs-type">int</span><br>val, stack = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>], stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>next_queue[index].Val = val<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(next_queue) &gt; <span class="hljs-number">0</span> &#123;<br>node, next_queue = next_queue[<span class="hljs-number">0</span>], next_queue[<span class="hljs-number">1</span>:]<br>queue = <span class="hljs-built_in">append</span>(queue, node)<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>广搜</p><p>学一学原地倒序的写法，这样就不需要两个queue，再用一个stack来倒序了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseOddLevels</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    q := []*TreeNode&#123;root&#125;<br>    isOdd := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> isOdd != <span class="hljs-number">0</span> &#123;<br>            n := <span class="hljs-built_in">len</span>(q)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++ &#123;<br>                nodex, nodey := q[i], q[n - <span class="hljs-number">1</span> - i]<br>                nodex.Val, nodey.Val = nodey.Val, nodex.Val<br>            &#125;  <br>        &#125;<br>        tmp := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(q) * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span>(q) &#123;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, node.Left, node.Right)<br>            &#125;<br>        &#125;<br>        q = tmp<br>        isOdd ^= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>深搜</p><p>两层之间的奇偶性是相反的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root1 *TreeNode, root2 *TreeNode, isOdd <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> isOdd &#123;<br>        root1.Val, root2.Val = root2.Val, root1.Val<br>    &#125;<br>    dfs(root1.Left, root2.Right, !isOdd)<br>    dfs(root1.Right, root2.Left, !isOdd)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseOddLevels</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br>    dfs(root.Left, root.Right, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2276-统计区间中的整数数目"><a href="https://leetcode.cn/problems/count-integers-in-intervals/">2276. 统计区间中的整数数目</a></h2><blockquote><p>给你区间的 <strong>空</strong> 集，请你设计并实现满足要求的数据结构：</p><ul><li>**新增：**添加一个区间到这个区间集合中。</li><li>**统计：**计算出现在 <strong>至少一个</strong> 区间中的整数个数。</li></ul><p>实现 <code>CountIntervals</code> 类：</p><ul><li><code>CountIntervals()</code> 使用区间的空集初始化对象</li><li><code>void add(int left, int right)</code> 添加区间 <code>[left, right]</code> 到区间集合之中。</li><li><code>int count()</code> 返回出现在 <strong>至少一个</strong> 区间中的整数个数。</li></ul><p>**注意：**区间 <code>[left, right]</code> 表示满足 <code>left &lt;= x &lt;= right</code> 的所有整数 <code>x</code> 。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>差分</p><p>可以用差分数组模拟添加区间，<code>count()</code>的时候计算前缀和即可。</p></li></ul></li><li><p>官解</p><p><a href="https://leetcode.cn/problems/count-integers-in-intervals/solutions/1/by-endlesscheng-clk2/?envType=daily-question&amp;envId=2023-12-16">2276. 统计区间中的整数数目 - 力扣（LeetCode）</a></p><ul><li><p>珂朵莉树</p><p><img src="/2023/12/08/leetcode23-12/image-20231216101304894.png" alt="image-20231216101304894"></p><p>用<code>&lt;l,r&gt;</code>表示区间<code>[left,right]</code>，在新增一个区间<code>[left,right]</code>的时候，重点在于找到第一个被覆盖到的区间。go的红黑树中，key用于排序，value是与key对应的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CountIntervals <span class="hljs-keyword">struct</span> &#123;<br>*redblacktree.Tree<br>cnt <span class="hljs-type">int</span> <span class="hljs-comment">// 所有区间长度和</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> CountIntervals &#123;<br><span class="hljs-keyword">return</span> CountIntervals&#123;redblacktree.NewWithIntComparator(), <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *CountIntervals)</span></span> Add(left, right <span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">// 遍历所有被 [left,right] 覆盖到的区间（部分覆盖也算）</span><br><span class="hljs-keyword">for</span> node, _ := t.Ceiling(left); node != <span class="hljs-literal">nil</span> &amp;&amp; node.Value.(<span class="hljs-type">int</span>) &lt;= right; node, _ = t.Ceiling(left) &#123;<br>l, r := node.Value.(<span class="hljs-type">int</span>), node.Key.(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">if</span> l &lt; left &#123; left = l &#125;   <span class="hljs-comment">// 合并后的新区间，其左端点为所有被覆盖的区间的左端点的最小值</span><br><span class="hljs-keyword">if</span> r &gt; right &#123; right = r &#125; <span class="hljs-comment">// 合并后的新区间，其右端点为所有被覆盖的区间的右端点的最大值</span><br>t.cnt -= r - l + <span class="hljs-number">1</span><br>t.Remove(r)<br>&#125;<br>t.cnt += right - left + <span class="hljs-number">1</span><br>t.Put(right, left) <span class="hljs-comment">// 所有被覆盖到的区间与 [left,right] 合并成一个新区间</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *CountIntervals)</span></span> Count() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> t.cnt &#125;<br></code></pre></td></tr></table></figure></li><li><p>动态开点线段树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CountIntervals <span class="hljs-keyword">struct</span> &#123;<br>left, right *CountIntervals<br>l, r, cnt   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> CountIntervals &#123; <span class="hljs-keyword">return</span> CountIntervals&#123;l: <span class="hljs-number">1</span>, r: <span class="hljs-number">1e9</span>&#125; &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *CountIntervals)</span></span> Add(l, r <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> o.cnt == o.r-o.l+<span class="hljs-number">1</span> &#123; <span class="hljs-keyword">return</span> &#125; <span class="hljs-comment">// o 已被完整覆盖，无需执行任何操作</span><br><span class="hljs-keyword">if</span> l &lt;= o.l &amp;&amp; o.r &lt;= r &#123; <span class="hljs-comment">// 当前节点已被区间 [l,r] 完整覆盖，不再继续递归</span><br>o.cnt = o.r - o.l + <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span><br>&#125;<br>mid := (o.l + o.r) &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> o.left == <span class="hljs-literal">nil</span> &#123; o.left = &amp;CountIntervals&#123;l: o.l, r: mid&#125; &#125; <span class="hljs-comment">// 动态开点</span><br><span class="hljs-keyword">if</span> o.right == <span class="hljs-literal">nil</span> &#123; o.right = &amp;CountIntervals&#123;l: mid + <span class="hljs-number">1</span>, r: o.r&#125; &#125; <span class="hljs-comment">// 动态开点</span><br><span class="hljs-keyword">if</span> l &lt;= mid &#123; o.left.Add(l, r)&#125;<br><span class="hljs-keyword">if</span> mid &lt; r &#123; o.right.Add(l, r) &#125;<br>o.cnt = o.left.cnt + o.right.cnt<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *CountIntervals)</span></span> Count() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> o.cnt &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="746-使用最小花费爬楼梯"><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><blockquote><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>dp</p><p>一眼dp，用<code>dp[n]</code>表示上到第<code>n</code>阶阶梯所花费的最低价格，则</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[n]=min(dp[n-1]+cost[n-1],dp[n-2]+cost[n-2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">cos</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">])</span></span></span></span></p><p>AC，注意下标的对应关系</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(cost)<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>dp[i] = math.MaxInt<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>dp[i] = min(dp[i], dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>])<br>dp[i] = min(dp[i], dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>])<br>&#125;<br><span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><ul><li><p>dp</p><p>可进一步优化空间，因为<code>dp[i]</code>仅与<code>dp[i-1]</code>和<code>dp[i-2]</code>有关。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(cost []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(cost)<br>    pre, cur := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>        pre, cur = cur, min(cur+cost[i<span class="hljs-number">-1</span>], pre+cost[i<span class="hljs-number">-2</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="162-寻找峰值"><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2><blockquote><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li>对于所有有效的 <code>i</code> 都有 <code>nums[i] != nums[i + 1]</code></li></ul></blockquote><ul><li><p>个人思路</p><p>logn的算法。no idea</p></li><li><p>官解</p><p>logn就是二分呀。重点在于峰值一定存在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment">// 辅助函数，输入下标 i，返回 nums[i] 的值</span><br>    <span class="hljs-comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span><br>    get := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || i == n &#123;<br>            <span class="hljs-keyword">return</span> math.MinInt64<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i]<br>    &#125;<br><br>    left, right := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> get(mid<span class="hljs-number">-1</span>) &lt; get(mid) &amp;&amp; get(mid) &gt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-keyword">if</span> get(mid) &lt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1901-寻找峰值-II"><a href="https://leetcode.cn/problems/find-a-peak-element-ii/">1901. 寻找峰值 II</a></h2><blockquote><p>一个 2D 网格中的 <strong>峰值</strong> 是指那些 <strong>严格大于</strong> 其相邻格子(上、下、左、右)的元素。</p><p>给你一个 <strong>从 0 开始编号</strong> 的 <code>m x n</code> 矩阵 <code>mat</code> ，其中任意两个相邻格子的值都 <strong>不相同</strong> 。找出 <strong>任意一个 峰值</strong> <code>mat[i][j]</code> 并 <strong>返回其位置</strong> <code>[i,j]</code> 。</p><p>你可以假设整个矩阵周边环绕着一圈值为 <code>-1</code> 的格子。</p><p>要求必须写出时间复杂度为 <code>O(m log(n))</code> 或 <code>O(n log(m))</code> 的算法</p><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>1 &lt;= mat[i][j] &lt;= 105</code></li><li>任意两个相邻元素均不相等.</li></ul></blockquote><ul><li><p>个人思路</p><p><code>O(m log(n))</code> 或 <code>O(n log(m))</code>？那不是说明一次遍历，一次二分？</p><p>懒了</p></li><li><p>官解</p><p>确实如此，但要对答案的存在性有一定理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxElement</span><span class="hljs-params">(row []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> row &#123;<br>        <span class="hljs-keyword">if</span> row[i] &lt; row[j] &#123;<br>            i = j<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPeakGrid</span><span class="hljs-params">(mat [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(mat)<br>    low, high := <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> low &lt;= high &#123;<br>        i := (low + high) / <span class="hljs-number">2</span><br>        j := maxElement(mat[i])<br>        <span class="hljs-keyword">if</span> i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; mat[i][j] &lt; mat[i - <span class="hljs-number">1</span>][j] &#123;<br>            high = i - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> &lt; m &amp;&amp; mat[i][j] &lt; mat[i + <span class="hljs-number">1</span>][j] &#123;<br>            low = i + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, j&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// impossible</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2828-判别首字母缩略词"><a href="https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words/">2828. 判别首字母缩略词</a></h2><blockquote><p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>s</code> ，请你判断 <code>s</code> 是不是 <code>words</code> 的 <strong>首字母缩略词</strong> 。</p><p>如果可以按顺序串联 <code>words</code> 中每个字符串的第一个字符形成字符串 <code>s</code> ，则认为 <code>s</code> 是 <code>words</code> 的首字母缩略词。例如，<code>&quot;ab&quot;</code> 可以由 <code>[&quot;apple&quot;, &quot;banana&quot;]</code> 形成，但是无法从 <code>[&quot;bear&quot;, &quot;aardvark&quot;]</code> 形成。</p><p>如果 <code>s</code> 是 <code>words</code> 的首字母缩略词，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p></blockquote><ul><li><p>个人思路</p><p>EZ AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAcronym</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>acro := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words); i++ &#123;<br>acro += <span class="hljs-type">string</span>(words[i][<span class="hljs-number">0</span>])<br>&#125;<br><span class="hljs-keyword">if</span> acro == s &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>遍历的思路，有一开始检查长度的优化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    <span class="hljs-type">bool</span> isAcronym(vector&lt;<span class="hljs-type">string</span>&gt;&amp; words, <span class="hljs-type">string</span> s) &#123;<br>        <span class="hljs-keyword">if</span> (s.size() != words.size()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (words[i][<span class="hljs-number">0</span>] != s[i]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2866-美丽塔-II"><a href="https://leetcode.cn/problems/beautiful-towers-ii/">2866. 美丽塔 II</a></h2><blockquote><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>maxHeights</code> 。</p><p>你的任务是在坐标轴上建 <code>n</code> 座塔。第 <code>i</code> 座塔的下标为 <code>i</code> ，高度为 <code>heights[i]</code> 。</p><p>如果以下条件满足，我们称这些塔是 <strong>美丽</strong> 的：</p><ol><li><code>1 &lt;= heights[i] &lt;= maxHeights[i]</code></li><li><code>heights</code> 是一个 <strong>山脉</strong> 数组。</li></ol><p>如果存在下标 <code>i</code> 满足以下条件，那么我们称数组 <code>heights</code> 是一个 <strong>山脉</strong> 数组：</p><ul><li>对于所有 <code>0 &lt; j &lt;= i</code> ，都有 <code>heights[j - 1] &lt;= heights[j]</code></li><li>对于所有 <code>i &lt;= k &lt; n - 1</code> ，都有 <code>heights[k + 1] &lt;= heights[k]</code></li></ul><p>请你返回满足 <strong>美丽塔</strong> 要求的方案中，<strong>高度和的最大值</strong> 。</p></blockquote><ul><li><p>个人思路</p><p>就是说要为<code>maxHeights</code>做减法，令其成为山脉数组。暴力思路较为简单，选取每个山峰作为最高点，计算最大值，再取最大值。</p></li><li><p>官解</p><p><a href="https://leetcode.cn/problems/beautiful-towers-ii/solutions/2574217/javapython3cqian-hou-zhui-he-dan-diao-zh-6fxl/?envType=daily-question&amp;envId=2023-12-21">2866. 美丽塔 II - 力扣（LeetCode）</a></p><p>有点困难，之后细看，是从暴力算法优化而来的，采用单调栈和前缀和来计算每个山峰为最高点的最大山峰和。</p></li></ul><h2 id="2660-保龄球游戏的获胜者"><a href="https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game/">2660. 保龄球游戏的获胜者</a></h2><blockquote><p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>player1</code> 和 <code>player2</code> ，分别表示玩家 1 和玩家 2 击中的瓶数。</p><p>保龄球比赛由 <code>n</code> 轮组成，每轮的瓶数恰好为 <code>10</code> 。</p><p>假设玩家在第 <code>i</code> 轮中击中 <code>xi</code> 个瓶子。玩家第 <code>i</code> 轮的价值为：</p><ul><li>如果玩家在该轮的前两轮的任何一轮中击中了 <code>10</code> 个瓶子，则为 <code>2xi</code> 。</li><li>否则，为 <code>xi</code> 。</li></ul><p>玩家的得分是其 <code>n</code> 轮价值的总和。</p><p>返回</p><ul><li>如果玩家 1 的得分高于玩家 2 的得分，则为 <code>1</code> ；</li><li>如果玩家 2 的得分高于玩家 1 的得分，则为 <code>2</code> ；</li><li>如果平局，则为 <code>0</code> 。</li></ul></blockquote><ul><li><p>个人思路</p><p>EZAC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getScore</span><span class="hljs-params">(player []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>score, full_sign := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(player); i++ &#123;<br><span class="hljs-keyword">if</span> full_sign &gt; <span class="hljs-number">0</span> &#123;<br>score += player[i] * <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>score += player[i]<br>&#125;<br><span class="hljs-keyword">if</span> player[i] == <span class="hljs-number">10</span> &#123;<br>full_sign = <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>full_sign--<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> score<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isWinner</span><span class="hljs-params">(player1 []<span class="hljs-type">int</span>, player2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ascore, bscore := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>ascore = getScore(player1)<br>bscore = getScore(player2)<br><span class="hljs-keyword">if</span> ascore &gt; bscore &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ascore &lt; bscore &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2706-购买两块巧克力"><a href="https://leetcode.cn/problems/buy-two-chocolates/">2706. 购买两块巧克力</a></h2><blockquote><p>给你一个整数数组 <code>prices</code> ，它表示一个商店里若干巧克力的价格。同时给你一个整数 <code>money</code> ，表示你一开始拥有的钱数。</p><p>你必须购买 <strong>恰好</strong> 两块巧克力，而且剩余的钱数必须是 <strong>非负数</strong> 。同时你想最小化购买两块巧克力的总花费。</p><p>请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 <code>money</code> 。注意剩余钱数必须是非负数。</p></blockquote><ul><li><p>个人思路</p><p>EZAC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buyChoco</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>, money <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(prices)<br>ans := money - prices[<span class="hljs-number">0</span>] - prices[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> ans &gt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> money<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>科技交流作业</title>
    <link href="/2023/11/27/%E7%A7%91%E6%8A%80%E4%BA%A4%E6%B5%81%E4%BD%9C%E4%B8%9A/"/>
    <url>/2023/11/27/%E7%A7%91%E6%8A%80%E4%BA%A4%E6%B5%81%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1>科技交流作业</h1><h2 id="平时作业">平时作业</h2><ol><li><p>Q:以下论文是否为EI检索？如果是，请给出检索号</p><p>Exploring Best Arm with Top Reward-Cost Ratio in Stochastic Bandits, INFOCOM 2020.</p><p>A：是，20203709155652</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/146715465">SCI/SCIE/SSCI/EI/期刊简介及官方查询验证方法 - 知乎 (zhihu.com)</a></p><p><strong>EI索引</strong>，全称工程索引（EI），是由美国工程信息公司(Engineering information Inc.)编辑出版，历史上最悠久的一部大型综合性检索工具。EI在全球的学术界、工程界、信息界中享有盛誉，是科技界共同认可的重要检索工具。EI主要收录<font color="red">工程技术</font>领域的重要文献，包括期刊以及会议文献，另外也收录一些科技报告、专著等。EI收录包括三种类型：被EI核心收录、非核心收录（Pageone收录）、会议论文。 从2009年起已经没有核心检索和非核心检索的区别，现在全是核心检索。但是还分为期刊检索和会议检索。</p><p><a href="https://blog.csdn.net/weixin_43042467/article/details/103476771">如何查询EI检索号-CSDN博客</a></p><p><a href="https://www.engineeringvillage.com/app/doc/?docid=cpx_M441df12c174920cac9eM64d410178163190&amp;pageSize=25&amp;index=1&amp;searchId=af3e672aadc0498a8ae1876519517c9d&amp;resultsCount=1&amp;usageZone=resultslist&amp;usageOrigin=searchresults&amp;searchType=Quick">Exploring Best Arm with Top Reward-Cost Ratio in Stochastic Bandits | Compendex (engineeringvillage.com)</a></p></blockquote></li><li><p>Q:以下CCF推荐会议属于A/B/C哪一类？</p><p>USENIX Symposium on Network System Design and Implementation</p><p>A:A类</p><blockquote><p><a href="https://www.jianshu.com/p/32406b4b8dc4">CCF、 A、B、C类是什么？？CCF难发还是SCI难？ - 简书 (jianshu.com)</a></p><p><a href="https://www.ccf.org.cn/">中国计算机学会 (ccf.org.cn)</a></p><p><img src="/2023/11/27/%E7%A7%91%E6%8A%80%E4%BA%A4%E6%B5%81%E4%BD%9C%E4%B8%9A/image-20231127171805021.png" alt="image-20231127171805021"></p></blockquote></li><li><p>Q：会议论文主要有哪几种展示形式？</p><p>A：一般说来有四种</p><ul><li>oral，口头报告。</li><li>poster，张贴海报。</li><li>workshop，探讨会。</li><li>paper，论文收录。又可分为全文收录（full paper)和部分收录(short paper)。</li></ul><blockquote><p><a href="https://www.zhihu.com/question/20186384">(56 封私信 / 81 条消息) 一般的学术会议都什么类型的？ - 知乎 (zhihu.com)</a></p></blockquote></li><li><p>Q：期刊/会议学术论文的引言章节主要包括哪几个方面的内容？</p><p>A：一般来说，引言应该包含如下几个结构要素：</p><ol><li><p>研究背景、目的和缘由。这一部分主要是说明你所写的这篇论文的重要性和必要性；</p></li><li><p>相关研究领域内前人所做的工作和研究的情况。这一步主要是介绍一些前人研究者已取得的研究成果以及还需解决的一些不足和问题；</p></li><li><p>论文所要解决的一些问题，本文研究所采用的研究方法和表征手段。这一部分主要是强调你所写论文研究的创新性有哪些，是集大成、承前启后，还是研究方法、内容前所未有的开创性重大成果等等；</p></li><li><p>本研究的预期成果及研究意义。这主要是总结一些研究结论以及对未来研究提出一些展望。一般这一步可以等论文全部书写完成后，在进行归纳书写（个人建议）。具体引言细节划分，可以参照下图所示，同时，平时看论文可以参照这个模式进行训练，有助于书写的规范性。</p></li></ol><blockquote><p><a href="https://zhuanlan.zhihu.com/p/138839188">论文基本结构系列——引言结构 - 知乎 (zhihu.com)</a></p></blockquote></li></ol><h2 id="学术论文阅读">学术论文阅读</h2><p><a href="https://kns.cnki.net/kcms2/article/abstract?v=o5eMcsLgsI5N7nT2KBeqUIGsz5sRUrvqYmwwc0QB58u_Tlf0RSJGEuAJfbnwN7P8mGj1Yx6YEz0GKMNQgVSGR_kHgVwHKGWa5O7h4XEL2MD8if6gfCeOvxW8qbcFYr_1xdp6-3FxyP-A3cgseLf0Mw==&amp;uniplatform=NZKPT&amp;language=CHS">移动边缘计算中智能服务编排和算网资源分配联合优化方法 - 中国知网 (cnki.net)</a></p><p>主要利用chatgpt来阅读该篇论文。</p><h3 id="引言">引言</h3><h4 id="术语解释">术语解释</h4><ul><li><p>移动边缘计算（MEC,mobile edge computing）</p><p>移动边缘计算是指利用移动设备进行边缘计算，即在设备本地进行数据处理和分析，而不是依赖于远程服务器进行计算。这种计算方式可以提高数据处理的效率，减少数据传输时延，并且可以降低对网络带宽的需求。</p><p>移动边缘计算通常涉及到在移动设备上部署一些轻量级的计算和分析工具，以便能够在设备本地对数据进行实时处理和决策。这种方式可以更快速地响应数据，并且能够在没有稳定网络连接的情况下进行计算和分析。</p><p>移动边缘计算在许多场景下都有应用，比如智能手机上的语音识别、图像处理等。它也可以应用在物联网设备、无人机等移动设备上，实现实时数据分析和决策。这种方式可以提高移动设备的智能化程度，同时也能够有效地减少对远程服务器的依赖。</p><ul><li><p>边缘计算</p><p>是一种分布式计算架构，它将数据处理和存储能力从传统的集中式数据中心扩展到靠近数据源的边缘位置，即离数据产生源头更近的地方。边缘计算的目的是减少数据传输延迟、降低网络负载，并提高实时数据处理和分析能力。</p></li></ul></li><li><p>算网资源分配</p><p>指的是在计算网络（包括云计算、边缘计算等）中对计算资源（如CPU、存储、带宽等）进行合理的分配和管理。这个过程涉及到对计算资源的调度、分配、优化和监控，以确保资源能够被有效地利用和充分发挥其性能。</p></li><li><p>启发式算法</p><p>是一种问题求解方法，它通过一系列规则、策略或者启发式知识，来辅助进行问题的求解。这些知识和策略可以帮助算法更快地找到解决方案，尽管不能保证一定能找到最优解。</p><p>启发式算法通常用于解决那些由于规模大、复杂度高、无法通过精确的计算方法得到最优解的问题。它们适用于许多领域，例如优化问题、组合优化、图论、机器学习等。</p><p>启发式算法的一些常见类型包括遗传算法、模拟退火算法、蚁群算法、人工神经网络等。这些算法通过模拟自然界的进化、物理学原理、生物学行为等规律，来搜索可能的解空间，并根据一些启发式的规则选择较优解来逐步优化搜索结果。</p><p>尽管启发式算法不能保证找到最优解，但它们通常能在合理的时间内找到一个较好的解，同时具有较好的鲁棒性，适用于许多现实世界的问题。因此，启发式算法在实际应用中得到了广泛的应用。</p></li><li><p>交替优化</p><p>是一种优化算法，用于解决多变量或多目标函数的优化问题。在交替优化算法中，不同变量或目标函数的优化问题交替进行优化，而不是同时优化。</p><p>具体来说，交替优化算法通常涉及到一个迭代过程，每一轮迭代中只优化一个变量或一个目标函数，而将其他变量或目标函数固定为当前最优解。这样的迭代过程可能会在每一轮中交替优化不同的变量，也可能在每一轮中交替优化不同的目标函数。</p><p>交替优化算法在实践中有着广泛的应用。例如，在机器学习中，交替最小化算法（alternating minimization）用于解决协同过滤、最小二乘支持向量机等问题；在信号处理中，交替最小二乘法（alternating least squares）用于解决矩阵分解问题；在凸优化问题中，交替方向乘子法（alternating direction method of multipliers，ADMM）用于解决凸优化问题等。</p><p>交替优化算法的优点之一是它通常能够在每一轮迭代中快速收敛，并且在某些问题中具有较好的收敛性能。然而，它也可能会收敛到局部最优解，而非全局最优解。因此，在使用交替优化算法时需要仔细考虑问题的性质，以及选择合适的参数和初始值来获得较好的优化结果。</p></li><li><p>半定松弛（Semidefinite Relaxation，SDR）</p><p>是一种数学优化方法，通常用于解决组合优化问题中的半定规划问题。半定规划是一类涉及优化一个矩阵的线性函数，同时满足一组矩阵不等式约束的问题。</p><p>在组合优化问题中，有些问题是非常难以解决的组合优化问题，难以获得精确的解。为了解决这些问题，可以将原问题转化为一个半定规划问题，并对其进行松弛（即放宽约束）来获得近似解。</p><p>半定松弛方法的基本思想是将原问题中的离散变量松弛为连续变量，并引入一个半定矩阵，将原问题转化为一个更容易求解的凸优化问题。通过对半定松弛问题进行求解，可以获得原优化问题的一个近似解。虽然这个解并不一定是最优解，但半定松弛通常能够提供一个较好的近似解，并且具有较好的计算性能。</p><p>半定松弛方法在组合优化、图论、信号处理等领域有着广泛的应用，它为一些原本难以求解的组合优化问题提供了一种有效的求解途径。</p></li><li><p>马尔可夫博弈理论</p><p>马尔可夫博弈理论是一种博弈论中的分支，它将马尔可夫决策过程与博弈论相结合，用于研究多决策者在马尔可夫环境下的决策问题。在这种博弈中，每个决策者的行为会影响环境的转移概率，同时也受到环境的影响。</p><ul><li><p>马尔可夫环境是指在马尔可夫决策过程（Markov Decision Process，MDP）中，决策者所处的环境符合马尔可夫性质的情况。马尔可夫环境具有以下特点：</p><ol><li>马尔可夫性质：在马尔可夫环境下，当前状态的未来发展只取决于当前状态，而不受过去状态的影响。换句话说，给定当前状态，过去的状态信息对未来的发展没有影响。这一性质被称为“无记忆性”，即未来状态只与当前状态有关。</li><li>状态空间：马尔可夫环境中的状态是离散的或连续的，并且包含了所有可能的环境状态。</li><li>状态转移概率：在马尔可夫环境中，状态之间的转移是以一定的概率进行的。换句话说，给定当前状态和采取的行动，环境状态将以一定的概率转移到下一个状态。</li><li>奖励：在马尔可夫环境中，决策者的行动会获得奖励，这个奖励通常与环境当前的状态和决策者的行动有关。</li></ol></li><li><p>一个常见的马尔可夫环境的例子是赌博游戏。假设一个赌徒每天都会进行赌博，每天他可以处于赢钱、输钱或者保持不变的状态。这些状态就构成了马尔可夫环境的状态空间。当赌徒进行赌博时，他的状态会以一定的概率转移到另一个状态，这就是状态转移概率。而赢钱、输钱或者保持不变的状态会对赌徒的情绪、财务状况等产生影响，从而影响他下一次进行赌博时的决策。</p><p>在这个例子中，赌徒的决策过程可以被建模为一个马尔可夫决策过程，其中赌徒的状态（赢钱、输钱或者保持不变）符合马尔可夫性质，状态之间的转移是以一定的概率进行的。同时，赌徒会根据他所处的状态来做出不同的决策（比如下注的大小），以期望在长期内最大化他的收益。这个例子展示了一个实际生活中的马尔可夫环境，可以用于分析赌徒在不确定环境下的决策问题。</p></li></ul></li><li><p>联合优化问题</p><p>指的是在一个优化问题中需要对多个变量或多个目标进行优化。这意味着在优化过程中需要考虑多个相互关联的变量或目标，并寻找它们之间的最佳平衡点或最优解。</p><p>联合优化问题通常涉及多个约束条件和多个优化目标，因此解决这类问题需要综合考虑多个因素，以找到全局最优解或者最优的平衡点。</p><p>举例来说，一个典型的联合优化问题可以是在工程设计中，需要在满足多个约束条件的前提下，同时优化多个设计变量以达到最佳的设计方案。另一个例子是在多目标优化问题中，需要在多个目标之间进行权衡取舍，以寻找到最佳的折衷解。</p><p>解决联合优化问题通常需要使用多目标优化、多变量优化或者多步优化的方法，以寻找到全局最优解或者最优的平衡点。这类问题在工程、经济、管理等领域都有广泛的应用。</p></li><li><p>任务卸载（Task Offloading）</p><p>是指将移动设备上的任务（例如计算、数据处理等）分配给云服务器或边缘服务器进行处理的过程。在移动计算环境中，由于移动设备的计算和存储资源有限，有些复杂的任务可能无法在设备本地完成，因此需要将这些任务卸载到云服务器或边缘服务器上进行处理。</p><p>任务卸载可以带来多方面的好处，例如：</p><p>节省移动设备资源：通过将一部分任务卸载到云服务器或边缘服务器上进行处理，可以减轻移动设备的计算和存储负担，延长设备的电池寿命并提高设备的性能。</p><p>提高响应速度：一些需要大量计算资源的任务，如果在移动设备上进行处理可能会需要很长时间，而将这些任务卸载到云服务器或边缘服务器上可以加快任务的处理速度。</p><p>解决设备资源不足的问题：移动设备的计算和存储资源有限，一些复杂的任务可能无法在设备本地完成，通过任务卸载可以利用云服务器或边缘服务器的丰富资源来完成这些任务。</p></li><li><p>深度强化学习（Deep Reinforcement Learning）是指结合了深度学习和强化学习的一种机器学习方法。在深度强化学习中，智能体通过与环境的交互学习，以最大化累积的奖励。深度学习技术用于模拟智能体的决策过程，并学习从环境状态到动作的映射，从而使智能体能够在复杂的环境中做出有效的决策。</p><ul><li><p>深度学习是机器学习的一个分支，它使用人工神经网络模拟人脑的工作机制，从而实现对数据的学习和理解。与传统的机器学习方法相比，深度学习更加注重层次化的特征学习，通过多层神经网络进行信息提取和抽象，从而实现对复杂数据的建模和分析。</p><p>深度学习的核心是人工神经网络，它通过多层次的神经元组成的网络结构来学习输入数据的复杂特征。深度学习模型可以通过大量的数据进行训练，从而不断调整网络参数以逐渐提高模型的性能。深度学习在图像识别、语音识别、自然语言处理、推荐系统等领域都取得了显著的成就，成为人工智能领域的重要技术手段。</p><p>深度学习的方法包括但不限于：</p><ol><li>卷积神经网络（Convolutional Neural Networks，CNN）：用于处理图像和视频数据，能够有效地提取图像中的特征。</li><li>循环神经网络（Recurrent Neural Networks，RNN）：适用于处理序列数据，能够对时间序列数据进行建模，常用于自然语言处理和语音识别等领域。</li><li>深度信念网络（Deep Belief Networks，DBN）：通过多层叠加的方式进行特征提取和学习，常用于无监督学习。</li><li>深度强化学习（Deep Reinforcement Learning）：结合了深度学习和强化学习的技术，用于训练智能体在复杂环境中做出决策。</li></ol><p>深度学习的发展离不开大数据和强大的计算能力，随着硬件技术的不断进步和算法的不断改进，深度学习在各个领域都有着广泛的应用和发展。</p></li><li><p>强化学习是一种机器学习的方法，它通过智能体与环境的交互学习，在不断尝试和经验积累的过程中，使得智能体能够做出最优的决策，以获得最大化的预期累积奖励。</p><p>在强化学习中，智能体通过观察环境的状态，执行相应的动作，然后从环境中获得奖励或惩罚，最终学习到如何在不同的情况下选择最优的动作。强化学习的目标是通过学习和实践，使得智能体能够在不断变化的环境中做出最优的决策，以获得最大的长期回报。</p><p>强化学习的核心概念包括：</p><ol><li>智能体（Agent）：执行动作并与环境交互的实体，它需要学习如何做出最佳的行为以最大化预期奖励。</li><li>环境（Environment）：智能体所处的外部环境，它对智能体的动作做出反馈，并根据智能体的行为产生新的状态。</li><li>奖励（Reward）：智能体在与环境交互过程中所获得的反馈信号，可以是正向的奖励或者负向的惩罚，智能体的目标是最大化累积的奖励。</li></ol><p>强化学习的方法包括但不限于：Q学习、SARSA、深度强化学习等，不同的方法适用于不同的问题和环境。强化学习在自动控制、游戏设计、金融交易等领域有着广泛的应用。</p></li></ul></li><li><p>分布式服务编排</p><p>是指管理和协调分布式系统中多个服务实例的部署、配置、升级、伸缩等操作的过程。它通常涉及调度、监控、治理和自动化等方面，以确保分布式系统各个服务实例能够协同工作，满足系统的性能、可用性、伸缩性等需求。</p><p>分布式服务编排的主要任务包括：</p><ol><li>部署和配置管理：对于分布式系统中的各种服务实例进行部署和配置，确保它们能够正确地运行并满足系统的需求。</li><li>伸缩和负载均衡：根据系统的负载情况，动态地对服务实例进行扩容或缩容，以及进行负载均衡操作，以确保系统能够有效地应对流量的变化。</li><li>自动化运维：包括监控、故障处理、自动恢复等操作，以确保系统的可用性和稳定性。</li><li>升级和回滚管理：管理系统的升级和回滚操作，确保系统在更新后能够平滑过渡，最小化对用户的影响。</li></ol></li><li><p>长短期记忆（LSTM，long short-term memory）</p><p>是一种常用于处理序列数据的循环神经网络（RNN）架构。LSTM网络最初由Hochreiter和Schmidhuber在1997年提出，旨在解决传统RNN网络中的长期依赖问题。</p><p>LSTM网络的设计是为了解决常规RNN网络在学习长序列数据时遇到的梯度消失和梯度爆炸等问题。LSTM引入了三个门控机制，即输入门、遗忘门和输出门，以及细胞状态（cell state），有效地解决了传统RNN的记忆和遗忘问题。</p><p>LSTM网络的主要组成部分包括：</p><ol><li>输入门（Input Gate）：决定哪些信息将会更新到细胞状态中。</li><li>遗忘门（Forget Gate）：决定哪些信息将从细胞状态中被遗忘。</li><li>细胞状态（Cell State）：负责传递信息，控制信息流动。</li><li>输出门（Output Gate）：决定基于当前细胞状态，哪些信息将输出到下一个时间步的隐藏状态。</li></ol><p>LSTM网络通过这些门控机制，能够有效地捕捉长期依赖关系，记忆和遗忘需要的信息，从而更好地处理和预测序列数据，如自然语言处理、语音识别、时间序列预测等任务。</p><p>由于其优良的性能，LSTM网络在各种领域广泛应用，如机器翻译、情感分析、股票预测、文本生成等。同时，基于LSTM网络的变种模型，如双向LSTM（Bidirectional LSTM）、长短时记忆网络的变种（如GRU，Gated Recurrent Unit）也在实际应用中得到了广泛的应用。</p></li></ul><h4 id="概括">概括</h4><ul><li>当前困境<ul><li>传统的优化方法对任务卸载和资源分配问题进行求解，不仅难以在多项式时间复杂度内获得最优的问题策略，而且通常存在“维数灾难”等问题，性能无法得到保证[10]。此外，传统的优化方法通常需要精确的网络模型，使模型扩展性差，无法适应动态变化的MEC 系统环境。</li><li>上述文献采用集中式策略学习算法，对MEC中的时延、能耗等优化问题展开研究。然而，海量设备接入使集中式策略学习方案的复杂度急剧上升、计算成本增加、计算效率降低，在处理高复杂和大规模问题时性能较差</li></ul></li><li>主要贡献<ul><li>一种去中心化的MEC 卸载模型。</li><li>以最小化任务处理时延为目标，在多维资源（计算、存储和带宽）约束下，建立了一个分布式的服务缓存和算网资源分配联合优化问题。</li><li>将优化问题抽象为部分可观测的马尔可夫决策过程（POMDP, partially observable Markov decision process），提出了一种基于循环多智能体深度强化学习的分布式服务编排和资源分配算法以自主决策服务缓存和算网资源分配策略。</li><li>考虑到用户业务请求的时间依赖性及其与服务缓存间的耦合关系，使用长短期记忆（LSTM, long<br>short-term memory）网络来捕获时间相关的网络状态信息，使智能体通过学习这些状态信息更好地理解未来的状态，做出更优的决策。</li></ul></li></ul><h3 id="系统模型">系统模型</h3><p><img src="/2023/11/27/%E7%A7%91%E6%8A%80%E4%BA%A4%E6%B5%81%E4%BD%9C%E4%B8%9A/image-20231130125956250.png" alt="image-20231130125956250"></p><h4 id="服务缓存模型">服务缓存模型</h4><h4 id="服务指派模型">服务指派模型</h4><p>因此，对于任一MD m i ，其生成的任务有以下4 种处理方式：</p><ol><li>本地计算；</li><li>卸载到关联基站BSm 进行处理；</li><li>通过关联基站将卸载的任务转发到其他BS进行处理；</li><li>卸载到云中心进行处理。</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>大学</category>
      
      <category>大四上</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu设置开机自动登录并取消自动锁屏</title>
    <link href="/2023/11/27/ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%B9%B6%E5%8F%96%E6%B6%88%E8%87%AA%E5%8A%A8%E9%94%81%E5%B1%8F/"/>
    <url>/2023/11/27/ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%B9%B6%E5%8F%96%E6%B6%88%E8%87%AA%E5%8A%A8%E9%94%81%E5%B1%8F/</url>
    
    <content type="html"><![CDATA[<h1>ubuntu设置开机自动登录并取消自动锁屏</h1><h2 id="设置开机自动登录">设置开机自动登录</h2><ol><li><p>打开设置-&gt;详细信息</p><p><img src="/2023/11/27/ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%B9%B6%E5%8F%96%E6%B6%88%E8%87%AA%E5%8A%A8%E9%94%81%E5%B1%8F/image-20231127140945590.png" alt="image-20231127140945590"></p></li><li><p>用户-&gt;解锁-&gt;自动登录</p><p><img src="/2023/11/27/ubuntu%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%E5%B9%B6%E5%8F%96%E6%B6%88%E8%87%AA%E5%8A%A8%E9%94%81%E5%B1%8F/image-20231127141030383.png" alt="image-20231127141030383"></p></li></ol><h2 id="取消自动锁屏">取消自动锁屏</h2><ol><li>设置-&gt;隐私-&gt;锁屏（关)</li></ol><h2 id="坑及修复方法">坑及修复方法</h2><p><a href="https://blog.csdn.net/catfish408/article/details/78870804">linux开机跳过输入用户名密码-CSDN博客</a>这篇文章去掉<code>passwd</code>中x的做法确实可以让你开机不用输入密码，但是你的密码也失效了。完全无法进入权限模式，<code>sudo</code>命令也会失效。</p><p>得亏有解决方法<a href="https://blog.csdn.net/weixin_45646026/article/details/122047672">修改了passwd文件，导致ubuntu系统无法登录的问题_passwd修改密码后登不上去_叼着奶瓶敲键盘的博客-CSDN博客</a>，记录一下，以免以后修改其他文件导致无法进入权限模式。</p><ol><li>重启系统，长按<code>shift</code>进入ubuntu的GRUB模式。</li><li>选择<code>ubuntu</code>，按<code>e</code>键进入编辑模式。</li><li>将倒数第二行的<code>quiet splash &amp;vt_handoff</code>或是其他（<code>ro</code>之后的内容）修改为<code>quiet splash rw init=/bin/bash</code>.</li><li>修改完后，按<code>ctrl+x</code>进入命令行模式，输入<code>mount -rw -o remount</code>获取读写权限（可能不成功，直接尝试修改文件）。然后输入<code>vim etc/passwd</code>编辑文件成原来的内容即可。</li><li><code>ctrl+alt+del</code>重启即可。</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置vscode的rust开发环境</title>
    <link href="/2023/11/22/%E9%85%8D%E7%BD%AEvscode%E7%9A%84rust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/11/22/%E9%85%8D%E7%BD%AEvscode%E7%9A%84rust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1>配置vscode的rust开发环境</h1><h2 id="安装RUST">安装RUST</h2><ol><li><p>从<a href="https://www.rust-lang.org/zh-CN/learn/get-started">入门 - Rust 程序设计语言 (rust-lang.org)</a>下载<code>rustup-init.exe</code>。</p><ul><li><p>若你使用linux，可先配置下载源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static<br><span class="hljs-built_in">export</span> RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup<br></code></pre></td></tr></table></figure><p>再下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh<br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>win</code>键，搜索<code>developer powershell for vs</code>。</p></li><li><p>在打开的powershell中运行<code>rustup-init.exe</code>。</p></li></ol><p><img src="/2023/11/22/%E9%85%8D%E7%BD%AEvscode%E7%9A%84rust%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/image-20231122144043393.png" alt="image-20231122144043393"></p><ol start="4"><li><p>检查安装是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rustc -V<br>rustc 1.56.1 (59eed8a2a 2021-11-01)<br><br>$ cargo -V<br>cargo 1.57.0 (b2e52d7ca 2021-10-21)<br></code></pre></td></tr></table></figure></li><li><p><a href="https://course.rs/first-try/slowly-downloading.html#%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E7%9A%84%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80">覆盖默认的镜像地址</a></p><p>事实上，我们更推荐第二种方式，因为第一种方式在项目大了后，实在是很麻烦，全部修改后，万一以后不用这个镜像了，你又要全部修改成其它的。</p><p>而第二种方式，则不需要修改 <code>Cargo.toml</code> 文件，<strong>因为它是直接使用新注册服务来替代默认的 <code>crates.io</code></strong>。</p><p>在 <code>$HOME/.cargo/config.toml</code> 添加以下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[source.crates-io]</span><br><span class="hljs-attr">replace-with</span> = <span class="hljs-string">&#x27;ustc&#x27;</span><br><br><span class="hljs-section">[source.ustc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br></code></pre></td></tr></table></figure><p>首先，创建一个新的镜像源 <code>[source.ustc]</code>，然后将默认的 <code>crates-io</code> 替换成新的镜像源: <code>replace-with = 'ustc'</code>。</p><p>简单吧？只要这样配置后，以往需要去 <code>crates.io</code> 下载的包，会全部从科大的镜像地址下载，速度刷刷的… 我的 300M 大刀( 宽带 )终于有了用武之地。</p><p><strong>这里强烈推荐大家在学习完后面的基本章节后，看一下 <a href="https://course.rs/cargo/intro.html">Cargo 使用指南章节</a>，对于你的 Rust 之旅会有莫大的帮助！</strong></p></li><li><p>若出现连接问题</p><blockquote><p><a href="https://course.rs/first-try/installation.html#%E5%AE%89%E8%A3%85-c-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E5%99%A8%E9%9D%9E%E5%BF%85%E9%9C%80">安装 C 语言编译器：（非必需）</a></p><p>Rust 对运行环境的依赖和 Go 语言很像，几乎所有环境都可以无需安装任何依赖直接运行。但是，Rust 会依赖 <code>libc</code> 和链接器 <code>linker</code>。所以如果遇到了提示链接器无法执行的错误，你需要再手动安装一个 C 语言编译器：</p><p><strong>macOS 下：</strong></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">xcode-select --install</span><br></code></pre></td></tr></table></figure><p><strong>Linux 下：</strong></p><p>Linux 用户一般应按照相应发行版的文档来安装 <code>GCC</code> 或 <code>Clang</code>。</p><p>例如，如果你使用 Ubuntu，则可安装 <code>build-essential</code>。</p></blockquote></li></ol><h2 id="VSCODE">VSCODE</h2><ol><li>下载如下扩展。<ul><li><code>Rust-Analyzer</code>，编译rust。</li><li><strong><code>CodeLLDB</code></strong>，用于debug。</li><li><code>Catppuccin Noctis</code>，vscode主题</li><li><code>crates</code>，Helps Rust developers managing dependencies with Cargo.toml.</li><li><code>Error Lens</code>，Improve highlighting of errors, warnings and other language diagnostics.</li><li><code>Even Better TOML</code>，支持 .toml 文件完整特性</li><li><code>Project Manager</code>(收藏、识别和管理你的工作空间和项目文件夹)</li></ul></li><li>然后在vscode内置终端或系统终端中运行<code>cargo build</code>或<code>cargo run</code>即可。</li></ol><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/657234679">Visual Studio Code 配置和使用 Rust 开发环境的最佳实践(VSCode + RA) - 知乎 (zhihu.com)</a></p><p><a href="https://course.rs/first-try/slowly-downloading.html">下载依赖太慢了？ - Rust语言圣经(Rust Course)</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
      <tag>windows</tag>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马克思的哲学革命及其当代意义学习记录</title>
    <link href="/2023/11/17/%E9%A9%AC%E5%85%8B%E6%80%9D%E7%9A%84%E5%93%B2%E5%AD%A6%E9%9D%A9%E5%91%BD%E5%8F%8A%E5%85%B6%E5%BD%93%E4%BB%A3%E6%84%8F%E4%B9%89%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/17/%E9%A9%AC%E5%85%8B%E6%80%9D%E7%9A%84%E5%93%B2%E5%AD%A6%E9%9D%A9%E5%91%BD%E5%8F%8A%E5%85%B6%E5%BD%93%E4%BB%A3%E6%84%8F%E4%B9%89%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>马克思的哲学革命及其当代意义学习记录</h1><h2 id="简介">简介</h2><ul><li>马克思：“哲学家们只是以不同的方式解释世界，而问题在于改变世界。”</li><li>在马克思学说面前，人类是难以教导的顽童。</li></ul><h2 id="导论">导论</h2><ul><li><p>马克思学说与当代人类的关系？即马克思的学说是否过时。</p><ul><li><p>《历史的终结和最后的人》（费郎西斯·福山）</p><p>马克思学说过时了。</p></li><li><p>《马克思的幽灵》（德里达）</p><p>马克思是当代人类的遗产，更是一种使命。</p><p><img src="/2023/11/17/%E9%A9%AC%E5%85%8B%E6%80%9D%E7%9A%84%E5%93%B2%E5%AD%A6%E9%9D%A9%E5%91%BD%E5%8F%8A%E5%85%B6%E5%BD%93%E4%BB%A3%E6%84%8F%E4%B9%89%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231117100906494.png" alt="image-20231117100906494"></p></li></ul></li><li><p>《资本论》</p><ul><li>不是一本政治经济学的书，而是对政治经济学的批判，是社会历史书。</li><li>哲学是科学的母体，科学是哲学的产儿。</li><li>思考马克思学说的当代意义，不是为了给马克思做辩护，而是为了向马克思求教。</li></ul></li><li><p>解释世界与改变世界</p><ul><li>马克思：“哲学家们只是以不同的方式解释世界，而问题在于改变世界。”</li><li>海德格尔：“世界需要改变，但每一种对世界的改变都需要对世界的解释作为前提。”</li><li>马克思：“人类需要解释世界，但更需要解释实践。”</li></ul></li><li><p>什么是世界、实践，世界从哪里来</p><ul><li><p>实践在中文语境下是行动，是去做、去干；但在西方哲学下是指创生或改变社会关系的活动。</p><p>因此，一个农夫将锄头砸向土地的时候，并不是实践，因为没有创生或改变社会关系。</p></li><li><p>世界是被建构起来的人与人的关系中形成的</p></li></ul></li></ul><h2 id="“社会权力”的发现">“社会权力”的发现</h2><ul><li>社会权力不等于政治权力</li></ul><blockquote><p>马克思受布鲁诺·鲍威尔之邀去波恩大学做教授，但鲍威尔失势。马克思便去科隆担任《莱茵报》的编辑，当时摩赛尔地区的农民被《林木盗窃法》剥夺了历史所形成的权力，他们捡拾枯枝败木，都属于盗窃林木。马克思为了农民和莱茵省议会辩论，期间学习了黑格尔的法哲学，但发现该权力的剥夺是理性可解释的。</p><p><img src="/2023/11/17/%E9%A9%AC%E5%85%8B%E6%80%9D%E7%9A%84%E5%93%B2%E5%AD%A6%E9%9D%A9%E5%91%BD%E5%8F%8A%E5%85%B6%E5%BD%93%E4%BB%A3%E6%84%8F%E4%B9%89%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231117104208836.png" alt="image-20231117104208836"></p></blockquote><ul><li><p>马克思：“利益是最讲究实际的，在这世界上没有什么比消灭自己的敌人更实际的事情。”</p><blockquote><p>2023年10月7日以色列国内突然遭遇数千枚火箭弹攻击，随即哈马斯宣布从加沙地带发起攻势，兵分三路进攻以色列。</p></blockquote></li><li><p>政治权力就是我们现在称为上层建筑的东西</p></li><li><p>权力</p><ul><li><p>权力是人与人的关系，权力是社会现象，不是观念。权力是自然界所没有的。</p><p>（那猴王相较于其他猴子拥有优先交配权是权力吗）</p></li><li><p>权力是不平等的，非理性的，是统治与非统治，是感性的力量。</p></li><li><p>权力是可以足以支配你的一部分生命时间的力量。</p><p>一块面包值一美元，这一美元就是就是凝聚在面包上的人与人的关系。</p></li></ul></li><li><p>虚构思维实验：假如我有很多钱，而其他人都很贫穷，会怎样？</p><ul><li>抢。但有法律来保护我，政治权力是保障社会权力的。</li><li>我走到哪里，你们跟到哪里。你们劝我投资，不能把钱放到口袋里。你们求我雇佣你们！！！</li></ul></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>王德峰</tag>
      
      <tag>马克思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GNS3部署SONIC路由器并与真机互通</title>
    <link href="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/"/>
    <url>/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/</url>
    
    <content type="html"><![CDATA[<h1>GNS3部署SONIC路由器并与真机互通</h1><h2 id="部署环境">部署环境</h2><ul><li>GNS3 2.2.38 <a href="https://cn.linux-console.net/?p=22052">如何在 Ubuntu 22.04|20.04|18.04 上安装 GNS3 (linux-console.net)</a></li><li>Linux sonic 5.10.0-18-2-amd64 #1 SMP Debian 5.10.140-1 (2022-09-02) x86_64</li></ul><h2 id="配置ip地址及ISIS协议">配置ip地址及ISIS协议</h2><h3 id="python脚本说明">python脚本说明</h3><h4 id="python脚本代码">python脚本代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># author: hey137</span><br><br>ROUTE_NUM = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入路由器数目\n&quot;</span>))<br>TERM_NUM = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入终端数目\n&quot;</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_ipv4</span>(<span class="hljs-params">my_id, oid, mask</span>):<br>    <span class="hljs-keyword">if</span> my_id &lt; oid:<br>        ip = <span class="hljs-string">&quot;10.&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">else</span>:<br>        ip = <span class="hljs-string">&quot;10.&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">if</span> mask &gt; <span class="hljs-number">0</span>:<br>        ip = ip + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(mask)<br>    <span class="hljs-keyword">return</span> ip<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_ipv6</span>(<span class="hljs-params">my_id, oid, mask</span>):<br>    <span class="hljs-keyword">if</span> my_id &lt; oid:<br>        ip = <span class="hljs-string">&quot;2023:&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;::&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">else</span>:<br>        ip = <span class="hljs-string">&quot;2023:&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;::&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">if</span> mask &gt; <span class="hljs-number">0</span>:<br>        ip = ip + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(mask)<br>    <span class="hljs-keyword">return</span> ip<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Terminal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, tid</span>):<br>        <span class="hljs-comment"># tid:term_id</span><br>        self.oid = <span class="hljs-literal">None</span><br>        self.<span class="hljs-built_in">id</span> = tid + ROUTE_NUM<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_ens4_route</span>(<span class="hljs-params">self, oid</span>):<br>        self.oid = oid<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sh</span>(<span class="hljs-params">self</span>):<br>        file_name = <span class="hljs-string">&quot;t&quot;</span> + <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span> - ROUTE_NUM) + <span class="hljs-string">&quot;.sh&quot;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            pre_order = \<br>                <span class="hljs-string">&quot;&quot;&quot;sudo sed -i -e &#x27;s/source-directory \\/run/# source-directory \\/run/g&#x27; /etc/network/interfaces</span><br><span class="hljs-string">sudo sed -i -e &#x27;8a \\\\nauto ens5\\niface ens5 inet dhcp&#x27; /etc/network/interfaces</span><br><span class="hljs-string">sudo rm /etc/network/interfaces.d/50-cloud-init</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            f.write(pre_order)<br>            <span class="hljs-comment"># 修改权限</span><br>            chmod = <span class="hljs-string">&quot;sudo chmod 777 /etc/network/interfaces.d\n&quot;</span><br>            f.write(chmod)<br>            <span class="hljs-comment"># 配置ip和默认网关</span><br>            my_ipv6 = make_ipv6(self.<span class="hljs-built_in">id</span>, self.oid, <span class="hljs-number">64</span>)<br>            o_ipv6 = make_ipv6(self.oid, self.<span class="hljs-built_in">id</span>, <span class="hljs-number">0</span>)<br>            ipv4 = make_ipv4(self.<span class="hljs-built_in">id</span>, self.oid, <span class="hljs-number">24</span>)<br>            o_ipv4 = make_ipv4(self.oid, self.<span class="hljs-built_in">id</span>, <span class="hljs-number">0</span>)<br>            ip_config = <span class="hljs-string">&quot;&quot;&quot;sudo cat &lt;&lt; EOF &gt; /etc/network/interfaces.d/10-ens4</span><br><span class="hljs-string">auto ens4</span><br><span class="hljs-string">iface ens4 inet6 static</span><br><span class="hljs-string">address &quot;&quot;&quot;</span> + my_ipv6 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">gateway &quot;&quot;&quot;</span> + o_ipv6 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">iface ens4 inet static</span><br><span class="hljs-string">address &quot;&quot;&quot;</span> + ipv4 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">up ip route add 10.0.0.0/8 via &quot;&quot;&quot;</span> + o_ipv4 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            f.write(ip_config)<br>            restart_net = <span class="hljs-string">&quot;sudo systemctl restart networking\n&quot;</span><br>            f.write(restart_net)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rid</span>):<br>        <span class="hljs-comment"># rid:router_id</span><br>        self.inter_map = &#123;&#125;<br>        self.<span class="hljs-built_in">id</span> = rid<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_edge</span>(<span class="hljs-params">self, _inter, oid</span>):<br>        <span class="hljs-comment"># oid:other_id</span><br>        self.inter_map[_inter] = oid<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sh</span>(<span class="hljs-params">self</span>):<br>        file_name = <span class="hljs-string">&quot;r&quot;</span> + <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>) + <span class="hljs-string">&quot;.sh&quot;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-comment"># 修改密码</span><br>            change_passwd = <span class="hljs-string">&quot;echo -e \&quot;123\n123\n\&quot; | sudo passwd admin\n&quot;</span><br>            f.write(change_passwd)<br>            <span class="hljs-comment"># 配置isis自启动</span><br>            start_isis = <span class="hljs-string">&quot;&quot;&quot;cat &lt;&lt; EOF &gt; start_isisd.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Docker ISISD Service</span><br><span class="hljs-string">After=docker.service</span><br><span class="hljs-string">Requires=docker.service</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">ExecStart=/usr/bin/docker exec -i bgp /bin/bash -c &quot;/usr/lib/frr/isisd -A 127.0.0.1 -d&quot;</span><br><span class="hljs-string">Restart=always</span><br><span class="hljs-string">RestartSec=5</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">sudo mv start_isisd.service /etc/systemd/system/</span><br><span class="hljs-string">sudo systemctl daemon-reload</span><br><span class="hljs-string">sudo systemctl enable start_isisd.service</span><br><span class="hljs-string">/usr/bin/docker exec -i bgp /bin/bash -c &quot;/usr/lib/frr/isisd -A 127.0.0.1 -d&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            f.write(start_isis)<br>            <span class="hljs-comment"># 配置ip</span><br>            <span class="hljs-keyword">for</span> _inter, oid <span class="hljs-keyword">in</span> self.inter_map.items():<br>                old_id = <span class="hljs-string">&quot;10.0.0.&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;/31&quot;</span><br>                ipv4 = make_ipv4(self.<span class="hljs-built_in">id</span>, oid, <span class="hljs-number">24</span>)<br>                ipv6 = make_ipv6(self.<span class="hljs-built_in">id</span>, oid, <span class="hljs-number">64</span>)<br>                remove_ip = <span class="hljs-string">&quot;sudo config interface ip remove Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + old_id + <span class="hljs-string">&quot;\n&quot;</span><br>                add_ipv4 = <span class="hljs-string">&quot;sudo config interface ip add Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + ipv4 + <span class="hljs-string">&quot;\n&quot;</span><br>                add_ipv6 = <span class="hljs-string">&quot;sudo config interface ip add Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + ipv6 + <span class="hljs-string">&quot;\n&quot;</span><br>                change_mtu = <span class="hljs-string">&quot;sudo config interface mtu Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; 1500\n&quot;</span><br>                start_up = <span class="hljs-string">&quot;sudo config interface startup Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot;\n&quot;</span><br>                f.write(remove_ip)<br>                f.write(add_ipv4)<br>                f.write(add_ipv6)<br>                f.write(change_mtu)<br>                f.write(start_up)<br>            save = <span class="hljs-string">&quot;sudo config save -y\n&quot;</span><br>            f.write(save)<br>            <span class="hljs-comment"># 配置isis</span><br>            pre_order = <span class="hljs-string">&quot;&quot;&quot;vtysh -c &quot;</span><br><span class="hljs-string">config</span><br><span class="hljs-string">ro isis sonic</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            <span class="hljs-comment"># net 49.0001.0000.0000.str(rid)(左边补齐0).00</span><br>            net = <span class="hljs-string">&quot;net 49.0001.0000.0000.&quot;</span> + <span class="hljs-string">&quot;0&quot;</span> * (<span class="hljs-number">4</span> - <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>))) + <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>) + <span class="hljs-string">&quot;.00\n&quot;</span><br>            f.write(pre_order)<br>            f.write(net)<br>            <span class="hljs-keyword">for</span> _inter <span class="hljs-keyword">in</span> self.inter_map.keys():<br>                enter_inter = <span class="hljs-string">&quot;interface Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot;\n&quot;</span><br>                isis = <span class="hljs-string">&quot;ipv6 ro isis sonic\nip ro isis sonic\n&quot;</span><br>                f.write(enter_inter)<br>                f.write(isis)<br>                f.write(<span class="hljs-string">&quot;exit\n&quot;</span>)<br>            f.write(<span class="hljs-string">&quot;end\n&quot;</span>)<br>            f.write(<span class="hljs-string">&quot;write\&quot;&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    router = [Router(<span class="hljs-number">0</span>)]<br>    term = [Terminal(<span class="hljs-number">0</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ROUTE_NUM + <span class="hljs-number">1</span>):<br>        router.append(Router(i))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, TERM_NUM + <span class="hljs-number">1</span>):<br>        term.append(Terminal(i))<br>    <span class="hljs-keyword">if</span> TERM_NUM &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入&quot;</span> + <span class="hljs-built_in">str</span>(TERM_NUM) + <span class="hljs-string">&quot;条终端链路信息 格式：（终端n通过路由器a的ei接口与路由器a相连 n inter_ei aID)&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(TERM_NUM):<br>        edge = <span class="hljs-built_in">input</span>()<br>        term_id, inter, r_id = edge.split()<br>        term_id = <span class="hljs-built_in">int</span>(term_id)<br>        r_id = <span class="hljs-built_in">int</span>(r_id)<br>        inter = <span class="hljs-built_in">int</span>(inter)<br>        term[term_id].add_ens4_route(r_id)<br>        router[r_id].add_edge(inter, term[term_id].<span class="hljs-built_in">id</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入路由链路信息，以空行结尾 格式：（路由器a的ei接口与路由器b的ej接口相连aID inter_ei inter_ej bID）&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        edge = <span class="hljs-built_in">input</span>()<br>        <span class="hljs-keyword">if</span> edge == <span class="hljs-string">&quot;&quot;</span>:<br>            <span class="hljs-keyword">break</span><br>        s_router, s_inter, d_inter, d_router = edge.split()<br>        s_router = <span class="hljs-built_in">int</span>(s_router)<br>        s_inter = <span class="hljs-built_in">int</span>(s_inter)<br>        d_router = <span class="hljs-built_in">int</span>(d_router)<br>        d_inter = <span class="hljs-built_in">int</span>(d_inter)<br>        router[s_router].add_edge(s_inter, d_router)<br>        router[d_router].add_edge(d_inter, s_router)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ROUTE_NUM + <span class="hljs-number">1</span>):<br>        router[i].make_sh()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, TERM_NUM + <span class="hljs-number">1</span>):<br>        term[i].make_sh()<br><br></code></pre></td></tr></table></figure><h4 id="输入说明">输入说明</h4><p>简单以下面的拓扑图为例说明。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113121555664.png" alt="image-20231113121555664"></p><ol><li><p>运行python脚本，输入路由器数目和终端数目。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113120552853.png" alt="image-20231113120552853"></p></li><li><p><strong>本程序默认一个终端仅会连接一个路由器</strong>，故接下来要求输入2条终端链路信息。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113120924658.png" alt="image-20231113120924658"></p></li><li><p>然后输入路由器之间的链路信息即可。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113121417056.png" alt="image-20231113121417056"></p></li><li><p>程序会在本级文件夹生成路由器（以r开头）和终端（以t开头）的配置脚本。</p></li></ol><h3 id="部署步骤">部署步骤</h3><ol><li><p>创建脚本后复制对应脚本内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim init.sh<br></code></pre></td></tr></table></figure></li><li><p>增加权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> +x init.sh<br></code></pre></td></tr></table></figure></li><li><p>运行脚本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./init.sh<br></code></pre></td></tr></table></figure></li></ol><p>另路由器初始账号密码</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">admin<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">YourPaSsWoRd<br></code></pre></td></tr></table></figure><p>终端账号密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">debian<br></code></pre></td></tr></table></figure><h3 id="配置脚本说明">配置脚本说明</h3><h4 id="ip地址">ip地址</h4><ul><li>程序为路由器和终端分配了ID，路由器的ID不变（与输入一致），终端的ID是输入的ID再加上路由器的数目，故终端数量和路由器数量之和不能超过255。</li><li>ipv4地址的分配遵循如下规则：若虚拟设备（即路由器或终端）a与另一台虚拟设备b相连，id分别为aID、bID。且minID，maxID分别表示aID和bID的较小值和较大值，那么a该链路的端口ip即为<code>10.minID.maxID.aID/24</code>,b该链路的端口ip为<code>10.minID.maxID.bID/24</code>。</li><li>ipv6地址的分配与ipv4类似：若虚拟设备（即路由器或终端）a与另一台虚拟设备b相连，id分别为aID、bID。且minID，maxID分别表示aID和bID的较小值和较大值，那么a该链路的端口ip即为<code>2023:minID:maxID::aID/64</code>,b该链路的端口ip为<code>2023:minID:maxID::bID/64</code>。</li></ul><p>故上述拓扑图配置后ip地址如下：</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113124143272.png" alt="image-20231113124143272"></p><h4 id="终端脚本">终端脚本</h4><ol><li>脚本为终端配置了ipv4，ipv6地址。</li><li>配置了一条静态路由，目的地址为<code>10.0.0.0/8</code>，下一跳为与其相连的路由器端口ip。</li></ol><h4 id="路由器脚本">路由器脚本</h4><ol><li>修改<code>admin</code>的密码为<code>123</code>。</li><li>配置了所用端口的ipv4，ipv6地址，并修改mtu为<code>1500</code>。</li><li>配置了所用端口的isis协议，如设备a的net地址为<code>49.0001.0000.0000.aID.00</code>。</li><li>isisd的开机自启动服务。</li></ol><h2 id="虚拟网元连接真机">虚拟网元连接真机</h2><p>​因为本项目是在vm上的gns3，所以要去修改vm的网络适配器，而不是在gns3的设置中去增加vmnet5,6,7…并添加到云的特殊接口上去配置（虽然可能也行，但没寻找到成功的方法）。故需要去配置vmware上的网络适配器。<strong>桥接后的cloud逻辑上可看作物理网线上的一个端口。</strong></p><p>​假如我们在物理电脑A上配置了上述拓扑的1号路由和2号路由的情况下，想通过物理网线连接到物理电脑B上的3号路由，可通过分别在两台电脑上进行以下步骤实现。</p><p><strong>桥接物理网线到cloud（以电脑A为例）</strong></p><ol><li><p>配置物理网线的网卡的ip地址，这里只需要这根逻辑网线的ip在同一个网段即可，即电脑A的网线网卡ip，电脑A上与cloud相连的路由器端口ip，电脑B的网线网卡ip，电脑B上与cloud相连的路由器端口ip在同一个网段，可自行分配ip。我这里仍分配在<code>10.2.3.0/24</code>网段。</p><p>默认网关在你从电脑cmd去ping虚拟网元时起作用（也可配置静态路由），希望ping通哪个虚拟网络，就填哪个虚拟网络的接入路由的端口ip。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113130455168.png" alt="image-20231113130455168"></p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113130529564.png" alt="image-20231113130529564"></p></li><li><p>在vmware虚拟网络编辑器上编辑桥接模式的vmnet0，需要选择为本机网线连接的那个网卡。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231102144701101.png" alt="image-20231102144701101"></p></li><li><p>在gns的虚拟机设置中增加桥接模式的网络适配器，不需要选择复制物理网络连接状态（复制物理网络连接状态是供移动端，无线网络选择的）下图已经添加好了。且注意网络适配器就是云上的eth0，而网络适配器2就是云上的eth1，以此类推。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231102145308528.png" alt="image-20231102145308528"></p></li><li><p>进入gns3的命令行，配置新增加的桥接模式的网卡，这里是eth2。</p><ol><li><p>修改/etc/netplan/00-installer-config.yaml即可，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo nano /etc/netplan/00-installer-config.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改相应内容，配置新增网卡的ip地址和mtu，注意yaml文件对缩进空格严格。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113130721710.png" alt="image-20231113130721710"></p></li><li><p>输入以下命令重启网络服务。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo netplan apply<br></code></pre></td></tr></table></figure></li><li><p>查看配置是否成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113131519924.png" alt="image-20231113131519924"></p></li></ol></li><li><p>在gns3上添加cloud，选择GNS3 VM，连线，cloud连接eth2。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113131649960.png" alt="image-20231113131649960"></p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113131721483.png" alt="image-20231113131721483"></p></li></ol><p>在电脑B上也进行同样操作，即可连通。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231113132439009.png" alt="image-20231113132439009"></p><h2 id="linux环境gns3虚实结合">linux环境gns3虚实结合</h2><h3 id="配置环境">配置环境</h3><ul><li>服务器：Ubuntu18.04</li><li>gns3 2.2.44.1</li><li>外接终端，linux和windows均可。</li></ul><h3 id="配置步骤">配置步骤</h3><ol><li><p>简单拓扑和ip规划如下，配置相应ip即可。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222100434956.png" alt="image-20231222100434956"></p></li><li><p>配置2号路由的e1端口和桥接网口的mtu一致，这里配置为9000。sonic路由的e1端口对应命令行中的Ethernet4，外接终端最好也配置为一样的。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222100712177.png" alt="image-20231222100712177"></p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222100843620.png" alt="image-20231222100843620"></p></li><li><p>路由器1号即可ping通外接终端。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222101008891.png" alt="image-20231222101008891"></p><p>外接终端也可ping通路由器</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222102934408.png" alt="image-20231222102934408"></p></li><li><p>外接终端需要配置静态路由，或者将默认网关设为<code>10.1.3.1</code>，即可ping通2号路由器。静态路由配置见<a href="https://blog.csdn.net/LJ511100/article/details/123851574">linux和windows配置IPV4/IPV6地址、静态路由、查看路由、ping命令_ipv4和ipv6怎么ping-CSDN博客</a></p><p>下图可观察到原来ping不通的10.1.2.2通过配置静态路由后可ping通。-S参数指定网卡，确保10.1.2.2是2号路由器的ip地址，而不是公网上的地址。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222103155726.png" alt="image-20231222103155726"></p></li></ol><h3 id="注意事项">注意事项</h3><ol><li><p>桥接网卡需要配置ip，不配置sonic路由无法ping通外接终端，即使sonic路由器上无法ping通该地址。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222103717425.png" alt="image-20231222103717425"></p><p>服务器（运行gns3的电脑）也无法ping通sonic路由器。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222103950427.png" alt="image-20231222103950427"></p></li><li><p>mtu的一致问题</p><ul><li>本人测试中，若外接终端是linux环境，那么只需保证sonic路由器端口和服务器的桥接网口的mtu一致即可，外接终端的mtu不一致也可连通。</li><li>但若外接终端是windows环境，则sonic路由器端口、服务器的桥接网口和终端网口三者的mtu一致才能连通。</li></ul><p>保险起见，拓扑中的所有mtu最好都设置成一致的。</p><p>且mtu不一致导致无法连通时，即使把mtu配置为相同的数值也无法连通，原因不知，可尝试删除gns3上的链路或cloud解决。</p></li><li><p>mtu的设置范围</p><ul><li><p>sonic的mtu设置范围为68-9216，默认是9100。<img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222104637434.png" alt="image-20231222104637434"></p></li><li><p>ubuntu18.04 mtu范围也是68-9216，默认是1500</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222105250470.png" alt="image-20231222105250470"></p></li><li><p>windows</p><p>与windows版本有关，在windows10中可设置为9100。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222105623542.png" alt="image-20231222105623542"></p><p>而windows11即使开启巨型帧服务，上限也只能是9014。</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231222105541701.png" alt="image-20231222105541701"></p></li></ul></li><li><p>ip规划问题</p><p>外接终端若配置10.0.0.0/8的静态路由，下一跳指向sonic路由器，将无法连接10.0.0.0/8网段下的其他ip，这点需要注意。可通过将sonic路由ip规划为11.0.0.0/8网段下解决。</p></li></ol><h2 id="疑难杂症">疑难杂症</h2><ol><li><p>无法ping通直连网，即物理机不能ping通直接连接到cloud上的路由器端口ip。</p><p>解决措施：</p><ol><li>检查防火墙是否关闭。</li><li>删除cloud，重新加入。</li><li>检查ip设置是否在同一个网段。</li></ol></li><li><p>能ping通直连网，但无法ping通虚拟网络中的其他路由ip。</p><p>解决措施：</p><ol><li><p>检查逻辑网线上的mtu是否一致。</p><p>脚本已将sonic路由器的mtu设为1500，故检查windows的mtu是否为1500，在cmd输入以下命令查看。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">netsh interface ipv4 show subinterfaces<br></code></pre></td></tr></table></figure><p>vmware的shell终端输入以下命令查看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure></li><li><p>检查ip配置是否正确，isis协议配置是否正确。</p></li></ol></li><li><p>添加cloud连线时出现链路已经存在的报错</p><p><img src="/2023/11/13/GNS3%E9%83%A8%E7%BD%B2SONIC%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B9%B6%E4%B8%8E%E7%9C%9F%E6%9C%BA%E4%BA%92%E9%80%9A/image-20231107121044655.png" alt="image-20231107121044655"></p><p>解决措施：关闭gns3再打开即可。</p></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>路由标识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>debian</tag>
      
      <tag>gns3</tag>
      
      <tag>sonic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode23-11</title>
    <link href="/2023/11/01/leetcode23-11/"/>
    <url>/2023/11/01/leetcode23-11/</url>
    
    <content type="html"><![CDATA[<h1>leetcode23-11</h1><h2 id="2127-参加会议的最多员工数"><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/">2127. 参加会议的最多员工数</a></h2><blockquote><p>一个公司准备组织一场会议，邀请名单上有 <code>n</code> 位员工。公司准备了一张 <strong>圆形</strong> 的桌子，可以坐下 <strong>任意数目</strong> 的员工。</p><p>员工编号为 <code>0</code> 到 <code>n - 1</code> 。每位员工都有一位 <strong>喜欢</strong> 的员工，每位员工 <strong>当且仅当</strong> 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 <strong>不会</strong> 是他自己。</p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>favorite</code> ，其中 <code>favorite[i]</code> 表示第 <code>i</code> 位员工喜欢的员工。请你返回参加会议的 <strong>最多员工数目</strong> 。</p></blockquote><ul><li><p>个人思路</p><p>如果将答案中的员工用单向边（a-&gt;b，表示a喜欢b）相连，那么最后其中一定存在一个环，因为假如没有环，这个单向边组成链条中必有一个点没有指出的边，也就是没有喜欢的人，那么他就不应该参会。且这个环，要么是一个两个点的环，要么是一个首尾相连的环，不然无法与喜欢的人在一起。</p><p>这样，我们可以穷举每个人作为起点，依次把前一个人喜欢的人顺时针放入圆桌，同时记录left和right，表示新加入的人左边的人和右边的人，故left始终是起点，而right是前一个新加入的人。而新加入的人new喜欢的人有如下情况：</p><ul><li>不在圆桌上，则继续加入圆桌</li><li>在圆桌上<ul><li>是left，形成首尾相连的环，成功，统计长度。</li><li>是right，形成两个点的环，此时查看是否喜欢left的人，有则加入，并继续查看是否有喜欢新加入的人的人，直到没有喜欢新加入的人的人；对new也做同样处理，成功，统计长度。</li><li>既不是left，也不是right，无法坐在一起，失败。</li></ul></li></ul><p><s>且上述情况成功的人可以标作visited，不把他作为起点。遍历完成后统计最大值即为答案。</s></p><p><s>一次逻辑错误，2人环的可以圈地自萌，应记录2人环的数量，然后在最大值再加这个数量即是答案。</s></p><p><s>二次逻辑错误，当答案是其中一个二人环时，需特殊判断一下，否则答案会多2，如[1,2]会是4。</s></p><p><img src="/2023/11/01/leetcode23-11/image-20231101115818837.png" alt="image-20231101115818837"></p><p><s>不只2人环可以圈地自萌，除了首尾相连（人数大于2）的成功情况（就二人环带尾巴都可以圈地自萌），并且当答案是首尾相连（人数大于2）时，无法圈地自萌。采用groups累计圈地自萌的数量，res只记录首尾相连(len&gt;2)的最大值，最后res取两者最大值。</s></p><p><img src="/2023/11/01/leetcode23-11/image-20231101120031858.png" alt="image-20231101120031858"></p><p>此时样例无法通过了，需要区分groups是否是含有同一个二人环。修改第一次循环判断，增加对visited的判断，开始怀疑是否可以用visited代替table。。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, ok := table[favorite[new_person]]; !ok &amp;&amp; !(visited[favorite[new_person]]); _, ok = table[favorite[new_person]]<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">[2,2,1,2]<br></code></pre></td></tr></table></figure><p><img src="/2023/11/01/leetcode23-11/image-20231101121312534.png" alt="image-20231101121312534"></p><p>然而还是出错，现在的问题是对于二人环的两边的尾巴，需要一个搜索来解决，而不是像我这样直接遍历得来的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><img src="/2023/11/01/leetcode23-11/image-20231101122310790.png" alt="image-20231101122310790"></p><p>本人写的笨比代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">int_max</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumInvitations</span><span class="hljs-params">(favorite []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(favorite)<br>visited := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br><span class="hljs-comment">// for i := 0; i &lt; n; i++ &#123;</span><br><span class="hljs-comment">// visited[i] = false</span><br><span class="hljs-comment">// &#125;</span><br>res, groups := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> visited[i] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>table := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;i: <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;<br>left, right, new_person, now_len := i, i, i, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> _, ok := table[favorite[new_person]]; !ok &amp;&amp; !(visited[favorite[new_person]]); _, ok = table[favorite[new_person]] &#123;<br>right = new_person<br>new_person = favorite[new_person]<br><span class="hljs-comment">// fmt.Printf(&quot;i:%d new_person:%d\n&quot;, i, new_person)</span><br>table[new_person] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>now_len++<br>&#125;<br><span class="hljs-keyword">if</span> favorite[new_person] == left || favorite[new_person] == right &#123;<br><span class="hljs-keyword">if</span> favorite[new_person] == right &#123;<br>left_new := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;left, new_person&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;left_new:%v\n&quot;, left_new)</span><br><span class="hljs-comment">// fmt.Printf(&quot;table:%v\n&quot;, table)</span><br><span class="hljs-keyword">for</span> p := <span class="hljs-number">0</span>; p &lt; <span class="hljs-number">2</span>; p++ &#123;<br><span class="hljs-keyword">for</span> flag, target := <span class="hljs-literal">false</span>, left_new[p]; ; &#123;<br>flag = <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br><span class="hljs-keyword">if</span> _, ok := table[j]; ok || (favorite[j] != target) &#123;<br><span class="hljs-keyword">continue</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>target = j<br><span class="hljs-comment">// fmt.Printf(&quot;i:%d new_person:%d\n&quot;, i, target)</span><br>flag = <span class="hljs-literal">true</span><br>table[j] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>now_len++<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> !flag &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>groups += now_len<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> res &lt; now_len &#123;<br>res = now_len<br>&#125;<br>&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;res:%d now_len:%d\n&quot;, res, now_len)</span><br><span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> table &#123;<br>visited[key] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br>res = int_max(res, groups)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>愚蠢的写法，for循环永远不会执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> flag, target := <span class="hljs-literal">false</span>, left_new[p]; flag; &#123;&#125;<br></code></pre></td></tr></table></figure><p>这几天搞不清楚这个for的执行次序出错很多次了，应是先初始化，再做判断，执行一遍代码，然后循环（赋值，判断，执行代码）</p></li><li><p>官解</p><p>个人思路其实正确，重点在于如何求解环为2的长度。</p><blockquote><p>为了求解「基环内向树」上的最长的「双向游走」路径，我们可以使用拓扑排序 + 动态规划的方法。记 f[i]表示到节点 i为止的最长「游走」路径经过的节点个数，那么状态方程即为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><munder><mrow><mi>max</mi><mo>⁡</mo></mrow><mrow><mi>j</mi><mo>→</mo><mi>i</mi></mrow></munder><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f[i] = \max_{j \to i}\{ f[j] \} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.6138em;vertical-align:-0.8638em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.4306em;"><span style="top:-2.3723em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">→</span><span class="mord mathnormal mtight">i</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8638em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]}</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span></p><p>即我们考虑节点 i 的上一个节点 j，在图中必须有从 j 到 i的一条有向边，这样我们就可以从 j 转移到 i。如果不存在满足要求的 j（例如「基环内向树」退化成一个大小 =2 的环），那么 f[i]=1。状态转移可以和拓扑排序同时进行。</p><p>在拓扑排序完成后，剩余没有被弹出过队列的节点就是环上的节点。我们可以找出每一个环。如果环的大小 ≥3，我们就用其来更新最大的环的大小；如果环的大小 =2，设环上的两个节点为 x和 y，那么该「基环内向树」上最长的「双向游走」的路径长度就是 f[x]+f[y]。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumInvitations</span><span class="hljs-params">(favorite []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(favorite)<br>    <span class="hljs-comment">// 统计入度，便于进行拓扑排序</span><br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> favorite &#123;<br>        indeg[x]++<br>    &#125;<br><br>    used := <span class="hljs-built_in">make</span>([] <span class="hljs-type">bool</span>, n)<br>    f := <span class="hljs-built_in">make</span>([] <span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        f[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <br>    q := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        u := q[<span class="hljs-number">0</span>]<br>        used[u] = <span class="hljs-literal">true</span><br>        q = q[<span class="hljs-number">1</span>:]<br>        v := favorite[u]<br>        <span class="hljs-comment">// 状态转移</span><br>        f[v] = max(f[v], f[u] + <span class="hljs-number">1</span>);<br>        indeg[v]--<br>        <span class="hljs-keyword">if</span> indeg[v] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, v)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ring 表示最大的环的大小</span><br>    <span class="hljs-comment">// total 表示所有环大小为 2 的「基环内向树」上的最长的「双向游走」路径之和</span><br>    ring, total := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> !used[i] &#123;<br>            j := favorite[i];<br>            <span class="hljs-comment">// favorite[favorite[i]] = i 说明环的大小为 2</span><br>            <span class="hljs-keyword">if</span> favorite[j] == i &#123;<br>                total += f[i] + f[j]<br>                used[i], used[j] = <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 否则环的大小至少为 3，我们需要找出环</span><br>                u, cnt := i, <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> <span class="hljs-literal">true</span> &#123;<br>                    cnt++<br>                    u = favorite[u]<br>                    used[u] = <span class="hljs-literal">true</span><br>                    <span class="hljs-keyword">if</span> u == i &#123;<br>                        <span class="hljs-keyword">break</span><br>                    &#125;<br>                &#125;<br>                ring = max(ring, cnt)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(ring, total)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> y<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="2103-环和杆"><a href="https://leetcode.cn/problems/rings-and-rods/">2103. 环和杆</a></h2><blockquote><p>总计有 <code>n</code> 个环，环的颜色可以是红、绿、蓝中的一种。这些环分别穿在 10 根编号为 <code>0</code> 到 <code>9</code> 的杆上。</p><p>给你一个长度为 <code>2n</code> 的字符串 <code>rings</code> ，表示这 <code>n</code> 个环在杆上的分布。<code>rings</code> 中每两个字符形成一个 <strong>颜色位置对</strong> ，用于描述每个环：</p><ul><li>第 <code>i</code> 对中的 <strong>第一个</strong> 字符表示第 <code>i</code> 个环的 <strong>颜色</strong>（<code>'R'</code>、<code>'G'</code>、<code>'B'</code>）。</li><li>第 <code>i</code> 对中的 <strong>第二个</strong> 字符表示第 <code>i</code> 个环的 <strong>位置</strong>，也就是位于哪根杆上（<code>'0'</code> 到 <code>'9'</code>）。</li></ul><p>例如，<code>&quot;R3G2B1&quot;</code> 表示：共有 <code>n == 3</code> 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。</p><p>找出所有集齐 <strong>全部三种颜色</strong> 环的杆，并返回这种杆的数量。</p></blockquote><ul><li><p>个人思路</p><p>模拟很简单，重点在于如何快速的判断三种颜色都存在。我的思路是，另每一个颜色代表一个质数，如2,3,5，每个杆都有一个初始值，为1。遍历颜色环，在i号杆就零i号杆的值乘以对于颜色的质数。最后遍历杆的值，能整除15的就是三种颜色都有的。</p><p>wait，有个新思路，上述涉及乘法可能会有溢出的问题，可以采用位运算。一种运算过一次就不一样的位运算，就是或。三种颜色对应不同位上的1，如001,010,100；每个杆初始值为0，按位或，最后为111的就是三种颜色都有的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPoints</span><span class="hljs-params">(rings <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>rgb := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;R&quot;</span>: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;G&quot;</span>: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>, <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>&#125;<br>pole, res := [<span class="hljs-number">10</span>]<span class="hljs-type">int</span>&#123;&#125;, <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(rings); i += <span class="hljs-number">2</span> &#123;<br>pn, _ := strconv.Atoi(<span class="hljs-type">string</span>(rings[i+<span class="hljs-number">1</span>])) <span class="hljs-comment">//Atoi返回转化后的数字和错误</span><br>pole[pn] |= rgb[<span class="hljs-type">string</span>(rings[i])]<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-comment">// fmt.Println(pole[i])</span><br><span class="hljs-keyword">if</span> pole[i] == <span class="hljs-number">7</span> &#123;<br>res++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>学习一位数字的字符串转化整形</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">pole_index := rings[i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="117-填充每个节点的下一个右侧节点指针-II"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h2><blockquote><p>给定一个二叉树：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p></blockquote><ul><li><p><img src="/2023/11/01/leetcode23-11/image-20231103101229183.png" alt="image-20231103101229183"></p><p>看示例本来以为可以偷鸡，但看代码才发现参数是Node *，返回值也是Node*。</p><p>用层序遍历可以解决，一开始在队列中加入1和NULL，然后对于节点的操作就是令该节点指向队列中的下一个节点，然后往队列中加入左右孩子（按顺序加入），对NULL的操作就是往队列中加入NULL。循环结束条件就是队列长度为1且是NULL。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br><span class="hljs-keyword">var</span> now_node *Node<br>q := <span class="hljs-built_in">make</span>([]*Node, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, root)<br>&#125;<br>q = <span class="hljs-built_in">append</span>(q, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">for</span> !(<span class="hljs-built_in">len</span>(q) == <span class="hljs-number">1</span> &amp;&amp; q[<span class="hljs-number">0</span>] == <span class="hljs-literal">nil</span>) &#123;<br>now_node, q = q[<span class="hljs-number">0</span>], q[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> now_node != <span class="hljs-literal">nil</span> &#123;<br>now_node.Next = q[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> now_node.Left != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, now_node.Left)<br>&#125;<br><span class="hljs-keyword">if</span> now_node.Right != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, now_node.Right)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, <span class="hljs-literal">nil</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>题目的进阶要求是使用常数级额外空间，允许使用递归。额，这怎么递归。</p></li><li><p>官解</p><p>也没有递归呀</p><p><img src="/2023/11/01/leetcode23-11/image-20231103105139031.png" alt="image-20231103105139031"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span></span> *Node &#123;<br>    start := root<br>    <span class="hljs-keyword">for</span> start != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">var</span> nextStart, last *Node<br>        handle := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cur *Node)</span></span> &#123;<br>            <span class="hljs-keyword">if</span> cur == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> nextStart == <span class="hljs-literal">nil</span> &#123;<br>                nextStart = cur<br>            &#125;<br>            <span class="hljs-keyword">if</span> last != <span class="hljs-literal">nil</span> &#123;<br>                last.Next = cur<br>            &#125;<br>            last = cur<br>        &#125;<br>        <span class="hljs-keyword">for</span> p := start; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>            handle(p.Left)<br>            handle(p.Right)<br>        &#125;<br>        start = nextStart<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="421-数组中两个数的最大异或值△"><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值△</a></h2><blockquote><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p></blockquote><ul><li><p>个人思路：</p><p>暴力不行，会TLE</p></li><li><p>官解</p><blockquote><p>异或运算的性质</p><p>解决这个问题，我们首先需要利用异或运算的一个性质：</p><p>如果 a ^ b = c 成立，那么a ^ c = b 与 b ^ c = a 均成立。</p><p>即 如果有三个数，满足其中两个数的异或值等于另一个值，那么这三个数的顺序可以任意调换。</p><p>（说明：利用这条性质，可以不使用第 3 个变量而交换两个变量的值。）</p><p>那么如何理解这个性质呢？因为异或运算其实就是 二进制下不进位的加法，你不妨自己举几个例子，在草稿纸上验证一下。<br>如何应用到本题？</p><p>这道题找最大值的思路是这样的：因为两两异或可以得到一个值，在所有的两两异或得到的值中，一定有一个最大值，我们推测这个最大值应该是什么样的？即根据“最大值”的存在性解题（一定存在）。在这里要强调一下：</p><p>我们只用关心这个最大的异或值需要满足什么性质，进而推出这个最大值是什么，而不必关心这个异或值是由哪两个数得来的。</p><p>（上面这句话很重要，如果读者一开始看不明白下面的思考，不妨多看几遍我上面写的这句话。）</p><p>于是有如下思考：</p><p>1、二进制下，我们希望一个数尽可能大，即希望越高位上越能够出现“1”，这样这个数就是所求的最大数，这是贪心算法的思想。</p><p>2、于是，我们可以从最高位开始，到最低位，首先假设高位是 “1”，把这 n 个数全部遍历一遍，看看这一位是不是真的可以是“1”，否则这一位就得是“0”，判断的依据是上面“异或运算的性质”，即下面的第 3 点；</p><p>3、如果 a ^ b = max 成立 ，max 表示当前得到的“最大值”，那么一定有 max ^ b = a 成立。我们可以先假设当前数位上的值为 “1”，再把当前得到的数与这个 n 个数的 前缀（因为是从高位到低位看，所以称为“前缀”）进行异或运算，放在一个哈希表中，再依次把所有 前缀 与这个假设的“最大值”进行异或以后得到的结果放到哈希表里查询一下，如果查得到，就说明这个数位上可以是“1”，否则就只能是 0（看起来很晕，可以看代码理解）。</p><p>一种极端的情况是，这 n 个数在某一个数位上全部是 0 ，那么任意两个数异或以后都只能是 0，那么假设当前数位是 1 这件事情就不成立。</p><p>4、如何得到前缀，可以用掩码（mask），掩码可以进行如下构造，将掩码与原数依次进行 “与” 运算，就能得到前缀。</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/</a></p></blockquote><p>从最大值的存在性来解题，从最高位开始，先贪心假设该位可以为1，然后<strong>分别</strong>与数组异或，若异或的值能在哈希表（这个哈希表就是数组每个数的前缀）中找到，就说明该位可以是1（这里体现了题目中的两个数的异或最大值，若a^b=c，则c^b=a）。而之后是带着前面已经锁定的位继续遍历的，而不是单独的每一个位遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (x <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">const</span> highBit = <span class="hljs-number">30</span> <span class="hljs-comment">// 最高位的二进制位编号为 30</span><br>    <span class="hljs-keyword">for</span> k := highBit; k &gt;= <span class="hljs-number">0</span>; k-- &#123;<br>        <span class="hljs-comment">// 将所有的 pre^k(a_j) 放入哈希表中</span><br>        seen := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>            <span class="hljs-comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br>            <span class="hljs-comment">// 只需将其右移 k 位</span><br>            seen[num&gt;&gt;k] = <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br>        <span class="hljs-comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br>        xNext := x*<span class="hljs-number">2</span> + <span class="hljs-number">1</span><br>        found := <span class="hljs-literal">false</span><br><br>        <span class="hljs-comment">// 枚举 i</span><br>        <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>            <span class="hljs-keyword">if</span> seen[num&gt;&gt;k^xNext] &#123;<br>                found = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> found &#123;<br>            x = xNext<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br>            <span class="hljs-comment">// 即为 x = x*2</span><br>            x = xNext - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="187-重复的DNA序列"><a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h2><blockquote><p><strong>DNA序列</strong> 由一系列核苷酸组成，缩写为 <code>'A'</code>, <code>'C'</code>, <code>'G'</code> 和 <code>'T'</code>.。</p><ul><li>例如，<code>&quot;ACGAATTCCG&quot;</code> 是一个 <strong>DNA序列</strong> 。</li></ul><p>在研究 <strong>DNA</strong> 时，识别 DNA 中的重复序列非常有用。</p><p>给定一个表示 <strong>DNA序列</strong> 的字符串 <code>s</code> ，返回所有在 DNA 分子中出现不止一次的 <strong>长度为 <code>10</code></strong> 的序列(子字符串)。你可以按 <strong>任意顺序</strong> 返回答案。</p></blockquote><ul><li><p>个人思路</p><p><s>看ow比赛摸了，韩国队都打赢了，沙特队输了，意难平呀。</s></p></li><li><p>官解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> L = <span class="hljs-number">10</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatedDnaSequences</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans []<span class="hljs-type">string</span>) &#123;<br>    cnt := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">len</span>(s)-L; i++ &#123;<br>        sub := s[i : i+L]<br>        cnt[sub]++<br>        <span class="hljs-keyword">if</span> cnt[sub] == <span class="hljs-number">2</span> &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, sub)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="318-最大单词长度乘积"><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2><blockquote><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p></blockquote><ul><li><p>个人思路</p><p>重点在于如何检测两个单词不含有公共字母，用set去判断会超时。如果要求<code>length(words[i]) + length(words[j])</code>最大，可以采用贪心的思想，先排序，但乘法不一样。换用数组去判断，直接过了，看来不是用库的数据结构就一定快的呀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPara</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 会超时</span><br><span class="hljs-comment">// seta := map[byte]struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// setb := map[byte]struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// set := map[byte]struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// for i := 0; i &lt; len(a); i++ &#123;</span><br><span class="hljs-comment">// seta[a[i]] = struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// set[a[i]] = struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// for i := 0; i &lt; len(b); i++ &#123;</span><br><span class="hljs-comment">// setb[b[i]] = struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// set[b[i]] = struct&#123;&#125;&#123;&#125;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// if len(set) == len(seta)+len(setb) &#123;</span><br><span class="hljs-comment">// return true</span><br><span class="hljs-comment">// &#125; else &#123;</span><br><span class="hljs-comment">// return false</span><br><span class="hljs-comment">// &#125;</span><br>set := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>setb := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br><span class="hljs-keyword">if</span> set[a[i]-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span> &#123;<br>set[a[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(b); i++ &#123;<br><span class="hljs-keyword">if</span> setb[b[i]-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">0</span> &#123;<br>setb[b[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>set[b[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br><span class="hljs-keyword">if</span> set[i] &gt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(words); j++ &#123;<br><span class="hljs-keyword">if</span> isPara(words[i], words[j]) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words[i])*<span class="hljs-built_in">len</span>(words[j]) &gt; res &#123;<br>res = <span class="hljs-built_in">len</span>(words[i]) * <span class="hljs-built_in">len</span>(words[j])<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>位运算，我也想到了，但只记得那个异或了。。将字符串或运算后，判断两个字符串是否含有公共字符直接按位与即可，若不等于0则说明有公共字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    masks := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(words))<br>    <span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> words &#123;<br>        <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>            masks[i] |= <span class="hljs-number">1</span> &lt;&lt; (ch - <span class="hljs-string">&#x27;a&#x27;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> masks &#123;<br>        <span class="hljs-keyword">for</span> j, y := <span class="hljs-keyword">range</span> masks[:i] &#123;<br>            <span class="hljs-keyword">if</span> x&amp;y == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(words[i])*<span class="hljs-built_in">len</span>(words[j]) &gt; ans &#123;<br>                ans = <span class="hljs-built_in">len</span>(words[i]) * <span class="hljs-built_in">len</span>(words[j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进一步优化，维护一个数组用来记录对应掩码的最长单词长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(words []<span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    masks := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words &#123;<br>        mask := <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>            mask |= <span class="hljs-number">1</span> &lt;&lt; (ch - <span class="hljs-string">&#x27;a&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(word) &gt; masks[mask] &#123;<br>            masks[mask] = <span class="hljs-built_in">len</span>(word)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> x, lenX := <span class="hljs-keyword">range</span> masks &#123;<br>        <span class="hljs-keyword">for</span> y, lenY := <span class="hljs-keyword">range</span> masks &#123;<br>            <span class="hljs-keyword">if</span> x&amp;y == <span class="hljs-number">0</span> &amp;&amp; lenX*lenY &gt; ans &#123;<br>                ans = lenX * lenY<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2586-统计范围内的元音字符串数"><a href="https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range/">2586. 统计范围内的元音字符串数</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 和两个整数：<code>left</code> 和 <code>right</code> 。</p><p>如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 <strong>元音字符串</strong> ，其中元音字母是 <code>'a'</code>、<code>'e'</code>、<code>'i'</code>、<code>'o'</code>、<code>'u'</code> 。</p><p>返回 <code>words[i]</code> 是元音字符串的数目，其中 <code>i</code> 在闭区间 <code>[left, right]</code> 内。</p></blockquote><ul><li><p>个人思路</p><p>EZ</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isVowel</span><span class="hljs-params">(letter <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>vowels := [<span class="hljs-number">5</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">if</span> letter == vowels[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">vowelStrings</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := left; i &lt;= right; i++ &#123;<br>word_len := <span class="hljs-built_in">len</span>(words[i])<br><span class="hljs-keyword">if</span> isVowel(words[i][<span class="hljs-number">0</span>]) &amp;&amp; isVowel(words[i][word_len<span class="hljs-number">-1</span>]) &#123;<br>res++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>使用字典代替if判断，将会更快</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">vowelStrings</span><span class="hljs-params">(words []<span class="hljs-type">string</span>, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    vowels := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;<span class="hljs-string">&#x27;a&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;e&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;i&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;o&#x27;</span> : &#123;&#125;, <span class="hljs-string">&#x27;u&#x27;</span> : &#123;&#125;&#125;<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span>(words[left : right + <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">if</span> _, ok1 := vowels[word[<span class="hljs-number">0</span>]]; ok1 &#123;<br>            <span class="hljs-keyword">if</span> _, ok2 := vowels[word[<span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span>]]; ok2 &#123;<br>                ans++<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2609-最长平衡子字符串"><a href="https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string/">2609. 最长平衡子字符串</a></h2><blockquote><p>给你一个仅由 <code>0</code> 和 <code>1</code> 组成的二进制字符串 <code>s</code> 。</p><p>如果子字符串中 <strong>所有的</strong> <code>0</code> <strong>都在</strong> <code>1</code> <strong>之前</strong> 且其中 <code>0</code> 的数量等于 <code>1</code> 的数量，则认为 <code>s</code> 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。</p><p>返回 <code>s</code> 中最长的平衡子字符串长度。</p><p>子字符串是字符串中的一个连续字符序列。</p></blockquote><ul><li><p>个人思路</p><p>一次遍历应该就行，遇0累加cnt，遇1累减cnt，等于0则统计一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheLongestBalancedSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br>cnt0, cnt1 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>cnt0, cnt1 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[i] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>cnt0++<br>i++<br>&#125;<br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(s) &amp;&amp; s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>cnt1++<br>i++<br>&#125;<br><br><span class="hljs-keyword">if</span> cnt0 &gt;= cnt1 &amp;&amp; res &lt; cnt1*<span class="hljs-number">2</span> &#123;<br>res = cnt1 * <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-keyword">if</span> cnt0 &lt;= cnt1 &amp;&amp; res &lt; cnt0*<span class="hljs-number">2</span> &#123;<br>res = cnt0 * <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTheLongestBalancedSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    count := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>            count[<span class="hljs-number">1</span>]++<br>            res = max(res, <span class="hljs-number">2</span> * min(count[<span class="hljs-number">0</span>], count[<span class="hljs-number">1</span>]))<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>            count[<span class="hljs-number">0</span>], count[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count[<span class="hljs-number">0</span>]++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res   <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2258-逃离火灾"><a href="https://leetcode.cn/problems/escape-the-spreading-fire/">2258. 逃离火灾</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始大小为 <code>m x n</code> 的二维整数数组 <code>grid</code> ，它表示一个网格图。每个格子为下面 3 个值之一：</p><ul><li><code>0</code> 表示草地。</li><li><code>1</code> 表示着火的格子。</li><li><code>2</code> 表示一座墙，你跟火都不能通过这个格子。</li></ul><p>一开始你在最左上角的格子 <code>(0, 0)</code> ，你想要到达最右下角的安全屋格子 <code>(m - 1, n - 1)</code> 。每一分钟，你可以移动到 <strong>相邻</strong> 的草地格子。每次你移动 <strong>之后</strong> ，着火的格子会扩散到所有不是墙的 <strong>相邻</strong> 格子。</p><p>请你返回你在初始位置可以停留的 <strong>最多</strong> 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 <code>-1</code> 。如果不管你在初始位置停留多久，你 <strong>总是</strong> 能到达安全屋，请你返回 <code>109</code> 。</p><p>注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。</p><p>如果两个格子有共同边，那么它们为 <strong>相邻</strong> 格子。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>考虑火的到达安全屋的最短时间和人到达安全屋的最短时间</p><ul><li>如果火的最短时间&lt;人的最短时间，那么返回<code>-1</code></li><li>如果火的最短时间=人的最短时间，这时与火的位置有关。可以这样思考，考虑两者到达安全屋的前一分钟，火能否覆盖到人的位置。具体到本题，安全屋必然在右下角，故前一分钟要么在安全屋的上面，要么在安全屋的左面<ul><li>若能覆盖，也是<code>-1</code>，因为人无法换路，换路火必然先于人到达安全屋。</li><li>若不能覆盖，人和火同时达到安全屋，按题意视为安全到达安全屋，返回<code>0</code>。</li></ul></li><li>如果火的最短时间&gt;人的最短时间，人可等待多出的时间，转化为两者时间相等的情况考虑。</li></ul><p>代码方面，两者的最短时间使用从安全屋开始的广度优先搜索，如何考虑相等时前一分钟的覆盖情况呢，我认为需要从安全屋的上面和左面来广搜。故不如直接从这两个点开始搜。</p><p>感觉思路有点奇怪，不是很想写代码（懒了。</p></li></ul></li><li><p>官解</p><ul><li><p>二分查找</p><p>我认为重点有二：</p><ol><li><p>如何意识到二分？线性即可二分</p><p>假设已知最大可以停留的时间为 stayTime，则当停留的时间大于 stayTime时则一定无法到达终点，当停留时间小于 stayTime时，则一定可以到达终点，二者成线性关系，因此可以利用二分查找找到最大停留时间。</p></li><li><p>由于火到达每个格子的时间是固定的，我们可以提前求出火到达每个格子的时间 fireTime[i][j]</p></li></ol><p>所以代码需要先广搜一遍出fireTime，然后是检查当前stayTime是否能到达安全屋的check函数，其仍是广搜，因为fireTime已经求出，到达一个新的点只需满足fireTime&gt;stayTime+到达该点需要的时间（在广搜中累加）即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> dirs = [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-keyword">var</span> INF <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumMinutes</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    fireTime := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        fireTime[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            fireTime[i][j] = INF<br>        &#125;<br>    &#125;<br><br>    bfs := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        q := [][]<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-number">1</span> &#123;<br>                    q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;i, j&#125;)<br>                    fireTime[i][j] = <span class="hljs-number">0</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        time := <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>            tmp := q<br>            q = [][]<span class="hljs-type">int</span>&#123;&#125;<br>            <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> tmp &#123;<br>                cx, cy := p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>                    nx, ny := cx + d[<span class="hljs-number">0</span>], cy + d[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &#123;<br>                        <span class="hljs-keyword">if</span> grid[nx][ny] == <span class="hljs-number">2</span> || fireTime[nx][ny] != INF &#123;<br>                                <span class="hljs-keyword">continue</span><br>                        &#125;<br>                        q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;nx, ny&#125;)<br>                        fireTime[nx][ny] = time <br>                    &#125;<br>                &#125;<br>            &#125;<br>            time += <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 通过 bfs 求出每个格子着火的时间 */</span><br>    bfs()<br>    <span class="hljs-comment">/* 二分查找找到最大停留时间 */</span><br>    check := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(stayTime <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, m)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>            visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        &#125;<br>        q := [][]<span class="hljs-type">int</span>&#123;&#125;<br>        q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, stayTime&#125;)<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>            tmp := q<br>            q = [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>            <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> tmp &#123;<br>                cx, cy, time := p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>], p[<span class="hljs-number">2</span>]<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123;<br>                    nx, ny := cx + d[<span class="hljs-number">0</span>], cy + d[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &#123;<br>                        <span class="hljs-keyword">if</span> visit[nx][ny] || grid[nx][ny] == <span class="hljs-number">2</span> &#123;<br>                            <span class="hljs-keyword">continue</span><br>                        &#125;<br>                        <span class="hljs-comment">/* 到达安全屋 */</span><br>                        <span class="hljs-keyword">if</span> nx == m - <span class="hljs-number">1</span> &amp;&amp; ny == n - <span class="hljs-number">1</span> &#123;<br>                            <span class="hljs-keyword">return</span> fireTime[nx][ny] &gt;= time + <span class="hljs-number">1</span><br>                        &#125;<br>                        <span class="hljs-comment">/* 火未到达当前位置 */</span><br>                        <span class="hljs-keyword">if</span> fireTime[nx][ny] &gt; time + <span class="hljs-number">1</span> &#123;<br>                            q = <span class="hljs-built_in">append</span>(q, []<span class="hljs-type">int</span>&#123;nx, ny, time + <span class="hljs-number">1</span>&#125;)<br>                            visit[nx][ny] = <span class="hljs-literal">true</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>   <br>    &#125;<br><br>    ans := <span class="hljs-number">-1</span><br>    low, high := <span class="hljs-number">0</span>, m * n<br>    <span class="hljs-keyword">for</span> low &lt;= high &#123;<br>        mid := low + (high - low) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> check(mid) &#123;<br>            ans = mid<br>            low = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            high = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ans &gt;= m * n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1e9</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分类讨论</p><p><img src="/2023/11/01/leetcode23-11/image-20231109130858875.png" alt="image-20231109130858875"></p><p>我的思路是对的，<a href="https://leetcode.cn/problems/escape-the-spreading-fire/solutions/1460794/er-fen-bfspythonjavacgo-by-endlesscheng-ypp1/">2258. 逃离火灾 - 力扣（LeetCode）</a>，广搜两次，安全屋的上面格子和左面格子即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123; x, y <span class="hljs-type">int</span> &#125;<br><span class="hljs-keyword">var</span> dirs = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximumMinutes</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment">// 返回三个数，分别表示到达安全屋/安全屋左边/安全屋上边的最短时间</span><br>    bfs := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(q []pair)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br>        time := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> time &#123;<br>            time[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> time[i] &#123;<br>                time[i][j] = <span class="hljs-number">-1</span> <span class="hljs-comment">// -1 表示未访问</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> q &#123;<br>            time[p.x][p.y] = <span class="hljs-number">0</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> t := <span class="hljs-number">1</span>; <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>; t++ &#123; <span class="hljs-comment">// 每次循环向外扩展一圈</span><br>            tmp := q<br>            q = <span class="hljs-literal">nil</span><br>            <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> tmp &#123;<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> dirs &#123; <span class="hljs-comment">// 枚举上下左右四个方向</span><br>                    <span class="hljs-keyword">if</span> x, y := p.x+d.x, p.y+d.y; <span class="hljs-number">0</span> &lt;= x &amp;&amp; x &lt; m &amp;&amp; <span class="hljs-number">0</span> &lt;= y &amp;&amp; y &lt; n &amp;&amp; grid[x][y] == <span class="hljs-number">0</span> &amp;&amp; time[x][y] &lt; <span class="hljs-number">0</span> &#123;<br>                        time[x][y] = t<br>                        q = <span class="hljs-built_in">append</span>(q, pair&#123;x, y&#125;)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> time[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>], time[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-2</span>], time[m<span class="hljs-number">-2</span>][n<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    manToHouseTime, m1, m2 := bfs([]pair&#123;&#123;&#125;&#125;)<br>    <span class="hljs-keyword">if</span> manToHouseTime &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 人无法到安全屋</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    firePos := []pair&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> j, x := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span> &#123;<br>                firePos = <span class="hljs-built_in">append</span>(firePos, pair&#123;i, j&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br>    fireToHouseTime, f1, f2 := bfs(firePos) <span class="hljs-comment">// 多个着火点同时跑 BFS</span><br>    <span class="hljs-keyword">if</span> fireToHouseTime &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 火无法到安全屋</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>_000_000_000<br>    &#125;<br><br>    d := fireToHouseTime - manToHouseTime<br>    <span class="hljs-keyword">if</span> d &lt; <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 火比人先到安全屋</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> m1 != <span class="hljs-number">-1</span> &amp;&amp; m1+d &lt; f1 || <span class="hljs-comment">// 安全屋左边相邻格子，人比火先到</span><br>       m2 != <span class="hljs-number">-1</span> &amp;&amp; m2+d &lt; f2 &#123;  <span class="hljs-comment">// 安全屋上边相邻格子，人比火先到</span><br>        <span class="hljs-keyword">return</span> d <span class="hljs-comment">// 图中第一种情况</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> d - <span class="hljs-number">1</span> <span class="hljs-comment">// 图中第二种情况</span><br>&#125;<br><br>作者：灵茶山艾府<br>链接：https:<span class="hljs-comment">//leetcode.cn/problems/escape-the-spreading-fire/solutions/1460794/er-fen-bfspythonjavacgo-by-endlesscheng-ypp1/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2300-咒语和药水的成功对数"><a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">2300. 咒语和药水的成功对数</a></h2><blockquote><p>给你两个正整数数组 <code>spells</code> 和 <code>potions</code> ，长度分别为 <code>n</code> 和 <code>m</code> ，其中 <code>spells[i]</code> 表示第 <code>i</code> 个咒语的能量强度，<code>potions[j]</code> 表示第 <code>j</code> 瓶药水的能量强度。</p><p>同时给你一个整数 <code>success</code> 。一个咒语和药水的能量强度 <strong>相乘</strong> 如果 <strong>大于等于</strong> <code>success</code> ，那么它们视为一对 <strong>成功</strong> 的组合。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>pairs</code>，其中 <code>pairs[i]</code> 是能跟第 <code>i</code> 个咒语成功组合的 <strong>药水</strong> 数目。</p></blockquote><ul><li><p>个人思路</p><p>将药水排序，二分去查找即可。换c++写一阵子，为了<s>汉堡</s>，程序设计大赛。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">successfulPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;spells, vector&lt;<span class="hljs-type">int</span>&gt; &amp;potions, <span class="hljs-type">long</span> <span class="hljs-type">long</span> success)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(spells.size())</span></span>;<br>        <span class="hljs-built_in">sort</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; spells.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-comment">// cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; endl;</span><br>            <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = potions.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (left &lt;= right)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; mid &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; endl;</span><br>                <span class="hljs-type">long</span> <span class="hljs-type">long</span> cross = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)spells[i] * potions[mid];<br>                <span class="hljs-keyword">if</span> (cross &gt;= success)<br>                &#123;<br>                    right = mid - <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            res[i] = potions.<span class="hljs-built_in">size</span>() - left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>二分查找</p><p>先排序，且利用upper_bound直接查找目标值。upper_bound是二分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">successfulPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; spells, vector&lt;<span class="hljs-type">int</span>&gt;&amp; potions, <span class="hljs-type">long</span> <span class="hljs-type">long</span> success)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i : spells) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> t = (success + i - <span class="hljs-number">1</span>) / i - <span class="hljs-number">1</span>;<br>            res.<span class="hljs-built_in">push_back</span>(potions.<span class="hljs-built_in">size</span>() - (<span class="hljs-built_in">upper_bound</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>(), t) - potions.<span class="hljs-built_in">begin</span>()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为什么使用<code>auto&amp;</code>？</p><p><img src="/2023/11/01/leetcode23-11/image-20231110094954664.png" alt="image-20231110094954664"></p></li><li><p>双指针</p><p>spells升序，potions降序，i，j为两者排序后的初始下标，随着i的增加，j只增不减，为O(n)。为了记录原始下标，对<strong>spells下标</strong>按照其位置上的能量强度进行升序排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">successfulPairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; spells, vector&lt;<span class="hljs-type">int</span>&gt;&amp; potions, <span class="hljs-type">long</span> <span class="hljs-type">long</span> success)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(spells.size())</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">idx</span><span class="hljs-params">(spells.size())</span></span>;<br>        <span class="hljs-built_in">iota</span>(idx.<span class="hljs-built_in">begin</span>(), idx.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">sort</span>(idx.<span class="hljs-built_in">begin</span>(), idx.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>            <span class="hljs-keyword">return</span> spells[a] &lt; spells[b];<br>        &#125;);<br>        <span class="hljs-built_in">sort</span>(potions.<span class="hljs-built_in">begin</span>(), potions.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>            <span class="hljs-keyword">return</span> a &gt; b;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; spells.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> p = idx[i];<br>            <span class="hljs-type">int</span> v = spells[p];<br>            <span class="hljs-keyword">while</span> (j &lt; potions.<span class="hljs-built_in">size</span>() &amp;&amp; (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) potions[j] * v &gt;= success) &#123;<br>                ++j;<br>            &#125;<br>            res[p] = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="765-情侣牵手"><a href="https://leetcode.cn/problems/couples-holding-hands/">765. 情侣牵手</a></h2><blockquote><p><code>n</code> 对情侣坐在连续排列的 <code>2n</code> 个座位上，想要牵到对方的手。</p><p>人和座位由一个整数数组 <code>row</code> 表示，其中 <code>row[i]</code> 是坐在第 <code>i </code>个座位上的人的 <strong>ID</strong>。情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2n-2, 2n-1)</code>。</p><p>返回 <em>最少交换座位的次数，以便每对情侣可以并肩坐在一起</em>。 <em>每次</em>交换可选择任意两人，让他们站起来交换座位。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>一开始将所有已经牵手的情侣去掉，剩下的都是未牵手的。然后明确一点，一个最小的情侣圈（情侣圈指这个圈子的所有情侣里是能通过交换座位来牵手的，不会出现单身狗。最小的是指这个圈无法通过划分变成两个更小的情侣圈）的人数是2n，那么必定需要交换n-1次来使情侣两两牵手。</p><p>如何寻找最小的情侣圈？</p><p>没想出来</p></li></ul></li><li><p>官解</p><ul><li><p>并查集</p><p>自己都说情侣圈了，其实就是找环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go">class Solution &#123;<br>public:<br>    <span class="hljs-type">int</span> getf(vector&lt;<span class="hljs-type">int</span>&gt;&amp; f, <span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">if</span> (f[x] == x) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-type">int</span> newf = getf(f, f[x]);<br>        f[x] = newf;<br>        <span class="hljs-keyword">return</span> newf;<br>    &#125;<br><br>    void add(vector&lt;<span class="hljs-type">int</span>&gt;&amp; f, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>        <span class="hljs-type">int</span> fx = getf(f, x);<br>        <span class="hljs-type">int</span> fy = getf(f, y);<br>        f[fx] = fy;<br>    &#125;<br><br>    <span class="hljs-type">int</span> minSwapsCouples(vector&lt;<span class="hljs-type">int</span>&gt;&amp; row) &#123;<br>        <span class="hljs-type">int</span> n = row.size();<br>        <span class="hljs-type">int</span> tot = n / <span class="hljs-number">2</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; f(tot, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tot; i++) &#123;<br>            f[i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> l = row[i] / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> r = row[i + <span class="hljs-number">1</span>] / <span class="hljs-number">2</span>;<br>            add(f, l, r);<br>        &#125;<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tot; i++) &#123;<br>            <span class="hljs-type">int</span> fx = getf(f, i);<br>            m[fx]++;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> auto&amp; [f, sz]: m) &#123;<br>            ret += sz - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="715-Range-模块"><a href="https://leetcode.cn/problems/range-module/">715. Range 模块</a></h2><blockquote><p>Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 <strong>半开区间</strong> 的范围并查询它们。</p><p><strong>半开区间</strong> <code>[left, right)</code> 表示所有 <code>left &lt;= x &lt; right</code> 的实数 <code>x</code> 。</p><p>实现 <code>RangeModule</code> 类:</p><ul><li><code>RangeModule()</code> 初始化数据结构的对象。</li><li><code>void addRange(int left, int right)</code> 添加 <strong>半开区间</strong> <code>[left, right)</code>，跟踪该区间中的每个实数。添加与当前跟踪的数字部分重叠的区间时，应当添加在区间 <code>[left, right)</code> 中尚未跟踪的任何数字到该区间中。</li><li><code>boolean queryRange(int left, int right)</code> 只有在当前正在跟踪区间 <code>[left, right)</code> 中的每一个实数时，才返回 <code>true</code> ，否则返回 <code>false</code> 。</li><li><code>void removeRange(int left, int right)</code> 停止跟踪 <strong>半开区间</strong> <code>[left, right)</code> 中当前正在跟踪的每个实数。</li></ul></blockquote><ul><li><p>官解</p><p><a href="https://lfool.github.io/LFool-Notes/algorithm/%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%AF%A6%E8%A7%A3.html">线段树详解 (lfool.github.io)</a></p><p><strong>线段树解决的是「区间和」的问题，且该「区间」会被修改</strong></p></li></ul><h2 id="307-区域和检索-数组可修改"><a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></h2><blockquote><p>给你一个数组 <code>nums</code> ，请你完成两类查询。</p><ol><li>其中一类查询要求 <strong>更新</strong> 数组 <code>nums</code> 下标对应的值</li><li>另一类查询要求返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的nums元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 用整数数组 <code>nums</code> 初始化对象</li><li><code>void update(int index, int val)</code> 将 <code>nums[index]</code> 的值 <strong>更新</strong> 为 <code>val</code></li><li><code>int sumRange(int left, int right)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的nums元素的 <strong>和</strong> （即，<code>nums[left] + nums[left + 1], ..., nums[right]</code>）</li></ul></blockquote><ul><li><p>个人思路</p><p>前缀和会超时，原因应该是更新操作费时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; array;<br>    vector&lt;<span class="hljs-type">int</span>&gt; pre_sum;<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)<br>    &#123;<br>        array.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        pre_sum.<span class="hljs-built_in">push_back</span>(nums[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            array.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            pre_sum.<span class="hljs-built_in">push_back</span>(pre_sum[i - <span class="hljs-number">1</span>] + nums[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> diff = val - array[index];<br>        array[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; array.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            pre_sum[i] += diff;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> left ? pre_sum[right] - pre_sum[left - <span class="hljs-number">1</span>] : pre_sum[right];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>分块和</p><p>重点在于对分块粒度的分析</p><blockquote><p><img src="/2023/11/01/leetcode23-11/image-20231113105050025.png" alt="image-20231113105050025"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; sum; <span class="hljs-comment">// sum[i] 表示第 i 个块的元素和</span><br>    <span class="hljs-type">int</span> size; <span class="hljs-comment">// 块的大小</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) : <span class="hljs-built_in">nums</span>(nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        size = <span class="hljs-built_in">sqrt</span>(n);<br>        sum.<span class="hljs-built_in">resize</span>((n + size - <span class="hljs-number">1</span>) / size); <span class="hljs-comment">// n/size 向上取整</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            sum[i / size] += nums[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        sum[index / size] += val - nums[index];<br>        nums[index] = val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-type">int</span> b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;<br>        <span class="hljs-keyword">if</span> (b1 == b2) &#123; <span class="hljs-comment">// 区间 [left, right] 在同一块中</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>() + b1 * size + i1, nums.<span class="hljs-built_in">begin</span>() + b1 * size + i2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> sum1 = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>() + b1 * size + i1, nums.<span class="hljs-built_in">begin</span>() + b1 * size + size, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum2 = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>() + b2 * size, nums.<span class="hljs-built_in">begin</span>() + b2 * size + i2 + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> sum3 = <span class="hljs-built_in">accumulate</span>(sum.<span class="hljs-built_in">begin</span>() + b1 + <span class="hljs-number">1</span>, sum.<span class="hljs-built_in">begin</span>() + b2, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum1 + sum2 + sum3;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>树状数组</p><p><a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll/?envType=daily-question&amp;envId=2023-11-13">带你发明树状数组！附数学证明</a></p><p><a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p><p>单点更新，范围查询。要点如下：</p><ul><li><p>一个区间可以按二进制来划分</p><p><img src="/2023/11/01/leetcode23-11/image-20231113161334209.png" alt="image-20231113161334209"></p></li><li><p>lowbit（i）是i&amp;-i</p><p><img src="/2023/11/01/leetcode23-11/image-20231113161434596.png" alt="image-20231113161434596"></p></li><li><p>如果 x 是一个被更新的关键区间的右端点，那么下一个被更新的关键区间的右端点为 x+lowbit(x)。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefixSum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &gt; <span class="hljs-number">0</span>; i &amp;= i - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// i -= i &amp; -i 的另一种写法,i&amp;-i是lowbit（i）</span><br>            s += tree[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) : <span class="hljs-built_in">nums</span>(nums.<span class="hljs-built_in">size</span>()), <span class="hljs-built_in">tree</span>(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-built_in">update</span>(i, nums[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> delta = val - nums[index];<br>        nums[index] = val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index + <span class="hljs-number">1</span>; i &lt; tree.<span class="hljs-built_in">size</span>(); i += i &amp; -i) &#123;<br>            tree[i] += delta;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">prefixSum</span>(right + <span class="hljs-number">1</span>) - <span class="hljs-built_in">prefixSum</span>(left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2760-最长奇偶子数组"><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/">2760. 最长奇偶子数组</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p><p>请你从 <code>nums</code> 的子数组中找出以下标 <code>l</code> 开头、下标 <code>r</code> 结尾 <code>(0 &lt;= l &lt;= r &lt; nums.length)</code> 且满足以下条件的 <strong>最长子数组</strong> ：</p><ul><li><code>nums[l] % 2 == 0</code></li><li>对于范围 <code>[l, r - 1]</code> 内的所有下标 <code>i</code> ，<code>nums[i] % 2 != nums[i + 1] % 2</code></li><li>对于范围 <code>[l, r]</code> 内的所有下标 <code>i</code> ，<code>nums[i] &lt;= threshold</code></li></ul><p>以整数形式返回满足题目要求的最长子数组的长度。</p><p><strong>注意：子数组</strong> 是数组中的一个连续非空元素序列。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>dp</p><p>用一维数组<code>dp[i]</code>表示以<code>i</code>为下标的数结尾的最长奇偶子数组长度，转移方程是</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>nums[i]&lt;=threshold 且 nums[i] % 2 != nums[i + 1] % 2</mtext></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>其他</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i]=\begin{cases}dp[i-1]+1 &amp; \text{nums[i]&lt;=threshold 且 nums[i] \% 2 != nums[i + 1] \% 2}\\1 &amp; \text{其他}\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">nums[i]&lt;=threshold </span><span class="mord cjk_fallback">且</span><span class="mord"> nums[i] % 2 != nums[i + 1] % 2</span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">其他</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> threshold)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt;= threshold &amp;&amp; nums[i] % <span class="hljs-number">2</span> != nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>)<br>        &#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; res)<br>            &#123;<br>                res = dp[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>错误，没注意第一个条件是<code>nums[l] % 2 == 0</code></p></li><li><p>枚举</p><p>一遍遍历，直接记录符合条件的子数组最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> threshold)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= threshold)<br>            &#123;<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>;<br>                i++;<br>                <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[i] &lt;= threshold &amp;&amp; nums[i] % <span class="hljs-number">2</span> != nums[i - <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>)<br>                &#123;<br>                    len++;<br>                    i++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len &gt; res)<br>                &#123;<br>                    res = len;<br>                &#125;<br>                i--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><ul><li><p>枚举</p></li><li><p>动态规划</p><p>dp为开头，而不是结尾，这样才能考虑第一位，因此需要反向遍历。w</p><p><img src="/2023/11/01/leetcode23-11/image-20231116120027193.png" alt="image-20231116120027193"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestAlternatingSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> threshold)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, dp = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = n - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; l--) &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] &gt; threshold) &#123;<br>                dp = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == n - <span class="hljs-number">1</span> || nums[l] % <span class="hljs-number">2</span> != nums[l + <span class="hljs-number">1</span>] % <span class="hljs-number">2</span>) &#123;<br>                dp++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[l] % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                res = <span class="hljs-built_in">max</span>(res, dp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2736-最大和查询"><a href="https://leetcode.cn/problems/maximum-sum-queries/">2736. 最大和查询</a></h2><blockquote><p>给你两个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，另给你一个下标从 <strong>1</strong> 开始的二维数组 <code>queries</code> ，其中 <code>queries[i] = [xi, yi]</code> 。</p><p>对于第 <code>i</code> 个查询，在所有满足 <code>nums1[j] &gt;= xi</code> 且 <code>nums2[j] &gt;= yi</code> 的下标 <code>j</code> <code>(0 &lt;= j &lt; n)</code> 中，找出 <code>nums1[j] + nums2[j]</code> 的 <strong>最大值</strong> ，如果不存在满足条件的 <code>j</code> 则返回 <strong>-1</strong> 。</p><p>返回数组 <code>answer</code> *，*其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>贪心？</p><p>按最大和排序，但这是个困难题，铁超时。看眼提示</p><p><img src="/2023/11/01/leetcode23-11/image-20231117093859444.png" alt="image-20231117093859444"></p><p>看不懂</p></li></ul></li><li><p>官解</p><ul><li><p>单调栈+二分查找</p><p><a href="https://leetcode.cn/problems/maximum-sum-queries/solutions/2524819/zui-da-he-cha-xun-by-leetcode-solution-jlk0/?envType=daily-question&amp;envId=2023-11-17">2736. 最大和查询 - 力扣（LeetCode）</a></p><p>爬完山还是很累。。不想看了。</p></li></ul></li></ul><h2 id="53-最大子数组和"><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p>滑雪回来，重整旗鼓。</p><blockquote><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p></blockquote><ul><li><p>个人思路</p><p>好眼熟的题目。</p><ul><li><p>贪心</p><p>遍历数组，用一个变量<code>sum</code>累加，若<code>sum</code>变负了则置零重新开始累加，因为负了对加上这段将会使答案变小，因此抛弃，这就是贪心的思想。期间记录最大值，即为返回答案。</p><p>要注意sum和res的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sum, res := <span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>sum += nums[i]<br><span class="hljs-keyword">if</span> res &lt; sum &#123;<br>res = sum<br>&#125;<br><span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>sum = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><ul><li><p>动态规划</p><p>[经典动态规划问题（理解「无后效性」)](<a href="https://leetcode.cn/problems/maximum-subarray/solutions/9058/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/?envType=daily-question&amp;envId=2023-11-20">53. 最大子数组和 - 力扣（LeetCode）</a>)。</p></li></ul></li></ul><h2 id="2216-美化数组的最少删除数"><a href="https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/">2216. 美化数组的最少删除数</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p><ul><li><code>nums.length</code> 为偶数</li><li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li></ul><p>注意，空数组同样认为是美丽数组。</p><p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p><p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目*。*</p></blockquote><ul><li><p>个人思路</p><ul><li><p>直接解题法（</p><p>依题意，直接遍历，若<code>nums[i]</code>和<code>nums[i+1]</code>一致就删除，且删除后要与<code>nums[i+2]</code>不一致。删除<code>nums[i]</code>或<code>nums[i+1]</code>即可，由于是遍历过来的，前面不会有一致的，若删除前面可能导致一致，且无论删除<code>nums[i]</code>或<code>nums[i+1]</code>还是i之前的，对大于i+1都是一样的，不用纠结。</p><p>可以通过指针来模拟删除，而不是真的删除后位移数组。</p><p>AC，注意对i+1，i+2的越界判断以及最后数组长度是否为偶数的判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDeletion</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); &#123;<br><span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(nums) &#123;<br>res++<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br><span class="hljs-keyword">if</span> i+<span class="hljs-number">2</span> &gt;= <span class="hljs-built_in">len</span>(nums) || nums[i] != nums[i+<span class="hljs-number">2</span>] || nums[i+<span class="hljs-number">1</span>] != nums[i+<span class="hljs-number">2</span>] &#123;<br>i += <span class="hljs-number">3</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i += <span class="hljs-number">1</span><br>&#125;<br>res++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i += <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(nums)-res)%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>res++<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><p>额，个人思考中，删除后要与<code>nums[i+1]</code>不一致这一点多余了，因为要判断这一点时，<code>nums[i]</code>和<code>nums[i+1]</code>是相等的，直接删除即可。本人代码优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDeletion</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); &#123;<br><span class="hljs-keyword">if</span> i+<span class="hljs-number">1</span> &gt;= <span class="hljs-built_in">len</span>(nums) &#123;<br>res++<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> nums[i] == nums[i+<span class="hljs-number">1</span>] &#123;<br>i += <span class="hljs-number">1</span><br>res++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>i += <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2304-网格中的最小路径代价"><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">2304. 网格中的最小路径代价</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, …, <code>(x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意：</strong> 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价*。*</p><p><img src="/2023/11/01/leetcode23-11/image-20231122115444781.png" alt="image-20231122115444781"></p></blockquote><ul><li><p>个人思路</p><ul><li><p>dp</p><p>用一个二维数组<code>dp[i][j]</code>表示从第一行开始到达第i行第j列的单元格的最小路径代价。先初始化第一行为单元格的值，然后遍历得到最小值即可。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathCost</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, moveCost [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>m, n, res := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]), <span class="hljs-number">-1</span><br>dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>dp[i][j] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m<span class="hljs-number">-1</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; n; k++ &#123;<br>temp := dp[i][j] + moveCost[grid[i][j]][k] + grid[i+<span class="hljs-number">1</span>][k]<br>dp[i+<span class="hljs-number">1</span>][k] = my_min(dp[i+<span class="hljs-number">1</span>][k], temp)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>res = my_min(dp[m<span class="hljs-number">-1</span>][i], res)<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">my_min</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> a == <span class="hljs-number">-1</span> || b == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">if</span> a == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> b<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> a &lt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> b<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><p>基本类似。</p></li></ul><h2 id="1410-HTML-实体解析器-c-宏，go声明初始化二维数组"><a href="https://leetcode.cn/problems/html-entity-parser/">1410. HTML 实体解析器(c++宏，go声明初始化二维数组)</a></h2><blockquote><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p><p>HTML 里这些特殊字符和它们对应的字符实体包括：</p><ul><li>**双引号：**字符实体为 <code>&quot;</code> ，对应的字符是 <code>&quot;</code> 。</li><li>**单引号：**字符实体为 <code>'</code> ，对应的字符是 <code>'</code> 。</li><li>**与符号：**字符实体为 <code>&amp;</code> ，对应对的字符是 <code>&amp;</code> 。</li><li>**大于号：**字符实体为 <code>&gt;</code> ，对应的字符是 <code>&gt;</code> 。</li><li>**小于号：**字符实体为 <code>&lt;</code> ，对应的字符是 <code>&lt;</code> 。</li><li>**斜线号：**字符实体为 <code>⁄</code> ，对应的字符是 <code>/</code> 。</li></ul><p>给你输入字符串 <code>text</code> ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。</p></blockquote><ul><li><p>个人思路</p><p>额，学习go的字符串替换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Replace</span><span class="hljs-params">(s,old,<span class="hljs-built_in">new</span> <span class="hljs-type">string</span> ,n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>s</td><td>要替换的整个字符串</td></tr><tr><td>old</td><td>要替换的字符串</td></tr><tr><td>new</td><td>替换成什么字符串</td></tr><tr><td>n</td><td>要替换的次数，为-1则全部替换</td></tr></tbody></table><p>调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs GO">strings.Replace(strHaiCoder, <span class="hljs-string">&quot;HaiCoder&quot;</span>, <span class="hljs-string">&quot;haicoder&quot;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>编写代码如下，特别注意二维字符串数组的声明初始化</p><ul><li>使用花括号，而不是[]</li><li><code>'</code>不需要转义，即不要写成<code>\'</code></li><li>最后一个花括号后面还有一个逗号</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entityParser</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> smap [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<br>&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>text = strings.Replace(text, smap[i][<span class="hljs-number">0</span>], smap[i][<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-keyword">return</span> text<br>&#125;<br></code></pre></td></tr></table></figure><p>但是出错</p><p><img src="/2023/11/01/leetcode23-11/image-20231123103327078.png" alt="image-20231123103327078"></p><p>就是说，只需要一次转义。因此需要将<code>&amp;amp</code>的处理放在最后面。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entityParser</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> smap [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<br>&#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++ &#123;<br>text = strings.Replace(text, smap[i][<span class="hljs-number">0</span>], smap[i][<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-keyword">return</span> text<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>官解是去模拟的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">entityParser</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    entityMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br>        <span class="hljs-string">&quot;&amp;quot;&quot;</span>: <span class="hljs-string">&quot;\&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;apos;&quot;</span>: <span class="hljs-string">&quot;&#x27;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;gt;&quot;</span>: <span class="hljs-string">&quot;&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;lt;&quot;</span>: <span class="hljs-string">&quot;&lt;&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;frasl;&quot;</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>        <span class="hljs-string">&quot;&amp;amp;&quot;</span>: <span class="hljs-string">&quot;&amp;&quot;</span>,<br>    &#125;<br><br>    i := <span class="hljs-number">0</span><br>    n := <span class="hljs-built_in">len</span>(text)<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i &lt; n &#123;<br>        isEntity := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">if</span> text[i] == <span class="hljs-string">&#x27;&amp;&#x27;</span> &#123;<br>            <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> entityMap &#123;<br>                <span class="hljs-keyword">if</span> i + <span class="hljs-built_in">len</span>(k) &lt;= n &amp;&amp; text[i : i + <span class="hljs-built_in">len</span>(k)] == k &#123;<br>                    res = <span class="hljs-built_in">append</span>(res, v)<br>                    isEntity = <span class="hljs-literal">true</span><br>                    i += <span class="hljs-built_in">len</span>(k)<br>                    <span class="hljs-keyword">break</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !isEntity &#123;<br>            res = <span class="hljs-built_in">append</span>(res, text[i:i+<span class="hljs-number">1</span>])<br>            i++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strings.Join(res, <span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，看到一个用c++宏来解题的代码，比较优雅</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REPLACE(STRING, CHAR)\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    static constexpr string_view sv = #STRING;\</span><br><span class="hljs-meta">    <span class="hljs-keyword">if</span> (i + sv.size() &lt;= s &amp;&amp; string_view(&amp;c, sv.size()) == sv) &#123;\</span><br><span class="hljs-meta">        ans += CHAR;\</span><br><span class="hljs-meta">        i += sv.size();\</span><br><span class="hljs-meta">        continue;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">entityParser</span><span class="hljs-params">(string text)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> s = text.<span class="hljs-built_in">size</span>();<br>        string ans;<br>        ans.<span class="hljs-built_in">reserve</span>(s);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; s;) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; c = text[i];<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&amp;&#x27;</span>) &#123;<br>                <span class="hljs-built_in">REPLACE</span>(&amp;quot;, <span class="hljs-string">&#x27;\&quot;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;apos;, <span class="hljs-string">&#x27;\&#x27;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;amp;, <span class="hljs-string">&#x27;&amp;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;gt;, <span class="hljs-string">&#x27;&gt;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;lt;, <span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>                <span class="hljs-built_in">REPLACE</span>(&amp;frasl;, <span class="hljs-string">&#x27;/&#x27;</span>)<br>            &#125;<br>            ans += c;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2824-统计和小于目标的下标对数目"><a href="https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/">2824. 统计和小于目标的下标对数目</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个整数 <code>target</code> ，请你返回满足 <code>0 &lt;= i &lt; j &lt; n</code> 且 <code>nums[i] + nums[j] &lt; target</code> 的下标对 <code>(i, j)</code> 的数目。</p></blockquote><ul><li><p>个人思路</p><ul><li><p>贪心</p><p>排序，然后遍历。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(nums)<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(nums); j++ &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[j] &lt; target &#123;<br>res++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><p>排序之后，重点在于找到不满足的那个<code>nums[j]</code>即可。</p><ul><li><p>二分查找</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        res += sort.SearchInts(nums[<span class="hljs-number">0</span>:i], target - nums[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    sort.Ints(nums)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>; i &lt; j; i++ &#123;<br>        <span class="hljs-keyword">for</span> i &lt; j &amp;&amp;  nums[i] + nums[j] &gt;= target &#123;<br>            j--<br>        &#125;<br>        res += j - i<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="1457-二叉树中的伪回文路径"><a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/">1457. 二叉树中的伪回文路径</a></h2><blockquote><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<strong>伪回文</strong>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>请你返回从根到叶子节点的所有路径中 <strong>伪回文</strong> 路径的数目。</p><p><img src="/2023/11/01/leetcode23-11/image-20231125100659250.png" alt="image-20231125100659250"></p></blockquote><ul><li><p>个人思路</p><p>伪回文序列指的是存在一个序列是回文序列，也就是说需要满足这个序列中的数个数为奇数最多只能有一个，其他数的个数均为偶数。</p><ul><li><p>深度搜素</p><p>深搜每一条路径，记录每一条路径的序列后判断是否为伪回文即可。</p><p>MLE，因为虽然go语言的参数传递全是值传递，但是切片是引用类型，因此我的处理方式是复制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pseudoPalindromicPaths</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>nums, res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span><br>dfs(root, nums, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node *TreeNode, nums []<span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>m[nums[i]]++<br>&#125;<br>odd := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>odd++<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> odd &lt; <span class="hljs-number">2</span> &#123;<br>*res++<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>nums_new := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), nums...)<br>nums_new = <span class="hljs-built_in">append</span>(nums_new, node.Val)<br>dfs(node.Left, nums_new, res)<br>&#125;<br><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>nums_new := <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>), nums...)<br>nums_new = <span class="hljs-built_in">append</span>(nums_new, node.Val)<br>dfs(node.Right, nums_new, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是优化了一下，结果TLE了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pseudoPalindromicPaths</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>nums, res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0</span><br>dfs(root, nums, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node *TreeNode, nums []<span class="hljs-type">int</span>, res *<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>m[nums[i]]++<br>&#125;<br>odd := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>odd++<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> odd &lt; <span class="hljs-number">2</span> &#123;<br>*res++<br>&#125;<br>nums = nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>dfs(node.Left, nums, res)<br>nums = nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, node.Val)<br>dfs(node.Right, nums, res)<br>nums = nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从题解来看，问题在于对伪回文的判断上。</p></li></ul></li><li><p>官解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pseudoPalindromicPaths</span> <span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    counter := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">return</span> dfs(root, counter)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, counter []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    counter[root.Val]++<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> isPseudoPalindrome(counter) &#123;<br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res = dfs(root.Left, counter) + dfs(root.Right, counter)<br>    &#125;<br>    counter[root.Val]--<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPseudoPalindrome</span><span class="hljs-params">(counter []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    odd := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> counter &#123;<br>        <span class="hljs-keyword">if</span> value % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            odd++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> odd &lt;= <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>res = dfs(root.Left, counter) + dfs(root.Right, counter)</code>这句比较难理解，重点在于res仍是只在叶子节点才会进行判断增加。</p></li></ul><h2 id="828-统计子串中的唯一字符"><a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/">828. 统计子串中的唯一字符</a></h2><blockquote><p>我们定义了一个函数 <code>countUniqueChars(s)</code> 来统计字符串 <code>s</code> 中的唯一字符，并返回唯一字符的个数。</p><p>例如：<code>s = &quot;LEETCODE&quot;</code> ，则其中 <code>&quot;L&quot;</code>, <code>&quot;T&quot;</code>,<code>&quot;C&quot;</code>,<code>&quot;O&quot;</code>,<code>&quot;D&quot;</code> 都是唯一字符，因为它们只出现一次，所以 <code>countUniqueChars(s) = 5</code> 。</p><p>本题将会给你一个字符串 <code>s</code> ，我们需要返回 <code>countUniqueChars(t)</code> 的总和，其中 <code>t</code> 是 <code>s</code> 的子字符串。输入用例保证返回值为 32 位整数。</p><p>注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 <code>s</code> 的所有子字符串中的唯一字符）。</p></blockquote><ul><li><p>个人思路</p><p>考虑一个全是不重复字母组成的字符串<code>s</code>，其长度为<code>n</code>,那么他的<code>countUniqueChars(s)</code>应为<code>1*n+2*(n-1)+3*(n-2)+...+n*1</code></p><p>考虑已经有一个长度为<code>n</code>的字符串<code>str</code>，在其后新增一个字母，假设为<code>a</code>，那么他将为新的字符串贡献以它结尾的<code>n+1</code>个子字符串（本身也是一个子字符串）。这样思路，这些新的子字符串是通过它向前遍历得来的，期间维护一个变量<code>unique_num</code>，统计当前新子字符串中的唯一字符数量，每遍历一个就加一次。</p><p>TLE</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniqueLetterString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>m, unique_num := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;s[i]: <span class="hljs-number">1</span>&#125;, <span class="hljs-number">1</span><br>res++<br><span class="hljs-keyword">for</span> j := i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br><span class="hljs-keyword">if</span> m[s[j]] == <span class="hljs-number">0</span> &#123;<br>unique_num++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> m[s[j]] == <span class="hljs-number">1</span> &#123;<br>unique_num--<br>&#125;<br>m[s[j]]++<br>res += unique_num<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>s优化：不用向前遍历统计唯一字符数量，可以一开始就维护一张表，记录<code>unique_num</code>在这个位置是增加还是减少。嘶，写不出来</p></li><li><p>官解</p><p>思路不一样，官解是针对到每一个字符，统计它能产生多少个只包含一个该字符的子串，假设该字符现在在第<code>i</code>位，记作<code>ci</code>，上一次出现的字符记作<code>cj</code>，下一次出现的字符为<code>ck</code>，则只包含i位置上的c能产生的子串有<code>(cj-ci)*(ci-ck)</code>个。</p><p><code>arr = append(append([]int&#123;-1&#125;, arr...), len(s))</code>的作用是在数组前加了一个<code>-1</code>，最后加了一个数组的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniqueLetterString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    idx := <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> s &#123;<br>        idx[c] = <span class="hljs-built_in">append</span>(idx[c], i)<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, arr := <span class="hljs-keyword">range</span> idx &#123;<br>        arr = <span class="hljs-built_in">append</span>(<span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>&#125;, arr...), <span class="hljs-built_in">len</span>(s))<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr)<span class="hljs-number">-1</span>; i++ &#123;<br>            ans += (arr[i] - arr[i<span class="hljs-number">-1</span>]) * (arr[i+<span class="hljs-number">1</span>] - arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="907-子数组的最小值之和"><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></h2><blockquote><p>给定一个整数数组 <code>arr</code>，找到 <code>min(b)</code> 的总和，其中 <code>b</code> 的范围为 <code>arr</code> 的每个（连续）子数组。</p><p>由于答案可能很大，因此 <strong>返回答案模 <code>10^9 + 7</code></strong> 。</p></blockquote><ul><li><p>个人思路</p><p>和上一题思考角度类似。考虑最小值能产生多少贡献，嘶，那第二最小值得在没有这个最小值的子串中去考虑，是个递归？</p><p>回到上一题的自己个人思路，考虑每一个增加的数能产生多少贡献。从后往前记录数值下降的数</p><p>第73个样例WA了，这怎么查。</p><p><img src="/2023/11/01/leetcode23-11/image-20231127122859159.png" alt="image-20231127122859159"></p><p>观察结果，大于<code>10^9+7</code>，发现是模出错了。</p><p>AC</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>MOD := <span class="hljs-type">int</span>(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>res, now_min, idx := arr[<span class="hljs-number">0</span>], <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(arr)), <span class="hljs-number">0</span><br>now_min[<span class="hljs-number">0</span>] = [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;arr[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>j := idx<br><span class="hljs-keyword">for</span> ; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br><span class="hljs-keyword">if</span> arr[i] &gt;= now_min[j][<span class="hljs-number">0</span>] &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> j != <span class="hljs-number">-1</span> &amp;&amp; now_min[i][<span class="hljs-number">0</span>] == arr[i] &#123;<br>idx = j<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>idx = j + <span class="hljs-number">1</span><br>&#125;<br>now_min[idx] = [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;arr[i], i&#125;<br><span class="hljs-keyword">for</span> j = idx; j &gt; <span class="hljs-number">0</span>; j-- &#123;<br>res += now_min[j][<span class="hljs-number">0</span>] * (now_min[j][<span class="hljs-number">1</span>] - now_min[j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]) % MOD<br>&#125;<br>res += now_min[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * (now_min[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) % MOD<br><span class="hljs-comment">// fmt.Println(i)</span><br><span class="hljs-comment">// fmt.Println(now_min)</span><br>&#125;<br><span class="hljs-keyword">return</span> res % MOD<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><ul><li><p>单调栈</p><p>有关单调栈，有点复杂，之后再看。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">const</span> mod <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br>    n := <span class="hljs-built_in">len</span>(arr)<br>    left := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    right := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    monoStack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &amp;&amp; x &lt;= arr[monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]] &#123;<br>            monoStack = monoStack[:<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) == <span class="hljs-number">0</span> &#123;<br>            left[i] = i + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left[i] = i - monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        monoStack = <span class="hljs-built_in">append</span>(monoStack, i)<br>    &#125;<br>    monoStack = []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &amp;&amp; arr[i] &lt; arr[monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]] &#123;<br>            monoStack = monoStack[:<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) == <span class="hljs-number">0</span> &#123;<br>            right[i] = n - i<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right[i] = monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>] - i<br>        &#125;<br>        monoStack = <span class="hljs-built_in">append</span>(monoStack, i)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> arr &#123;<br>        ans = (ans + left[i]*right[i]*x) % mod<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>dp</p><p>思路和我类似，感觉是换了一个形式输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">const</span> mod <span class="hljs-type">int</span> = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span><br>    n := <span class="hljs-built_in">len</span>(arr)<br>    monoStack := []<span class="hljs-type">int</span>&#123;&#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> arr &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &amp;&amp; arr[monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]] &gt; x &#123;<br>            monoStack = monoStack[:<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        k := i + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &#123;<br>            k = i - monoStack[<span class="hljs-built_in">len</span>(monoStack)<span class="hljs-number">-1</span>]<br>        &#125;<br>        dp[i] = k * x<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(monoStack) &gt; <span class="hljs-number">0</span> &#123;<br>            dp[i] += dp[i-k]<br>        &#125;<br>        ans = (ans + dp[i]) % mod<br>        monoStack = <span class="hljs-built_in">append</span>(monoStack, i)<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="1670-设计前中后队列"><a href="https://leetcode.cn/problems/design-front-middle-back-queue/">1670. 设计前中后队列</a></h2><blockquote><p>请你设计一个队列，支持在前，中，后三个位置的 <code>push</code> 和 <code>pop</code> 操作。</p><p>请你完成 <code>FrontMiddleBack</code> 类：</p><ul><li><code>FrontMiddleBack()</code> 初始化队列。</li><li><code>void pushFront(int val)</code> 将 <code>val</code> 添加到队列的 <strong>最前面</strong> 。</li><li><code>void pushMiddle(int val)</code> 将 <code>val</code> 添加到队列的 <strong>正中间</strong> 。</li><li><code>void pushBack(int val)</code> 将 <code>val</code> 添加到队里的 <strong>最后面</strong> 。</li><li><code>int popFront()</code> 将 <strong>最前面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li><li><code>int popMiddle()</code> 将 <strong>正中间</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li><li><code>int popBack()</code> 将 <strong>最后面</strong> 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 <code>-1</code> 。</li></ul><p>请注意当有 <strong>两个</strong> 中间位置的时候，选择靠前面的位置进行操作。比方说：</p><ul><li>将 <code>6</code> 添加到 <code>[1, 2, 3, 4, 5]</code> 的中间位置，结果数组为 <code>[1, 2, **6**, 3, 4, 5]</code> 。</li><li>从 <code>[1, 2, **3**, 4, 5, 6]</code> 的中间位置弹出元素，返回 <code>3</code> ，数组变为 <code>[1, 2, 4, 5, 6]</code> 。</li></ul></blockquote><ul><li><p>个人思路</p><p>阿巴阿巴</p></li><li><p>官解</p><ul><li><p>双端队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FrontMiddleBackQueue <span class="hljs-keyword">struct</span> &#123;<br>    left *list.List<br>    right *list.List<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> FrontMiddleBackQueue &#123;<br>    <span class="hljs-keyword">return</span> FrontMiddleBackQueue&#123;<br>        left: list.New(), <br>        right: list.New(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PushFront(val <span class="hljs-type">int</span>)  &#123;<br>    this.left.PushFront(val)<br>    <span class="hljs-keyword">if</span> this.left.Len() == this.right.Len() + <span class="hljs-number">2</span> &#123;<br>        this.right.PushFront(this.left.Back().Value.(<span class="hljs-type">int</span>))<br>        this.left.Remove(this.left.Back())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PushMiddle(val <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == this.right.Len() + <span class="hljs-number">1</span> &#123;<br>        this.right.PushFront(this.left.Back().Value.(<span class="hljs-type">int</span>))<br>        this.left.Remove(this.left.Back())<br>    &#125;<br>    this.left.PushBack(val)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PushBack(val <span class="hljs-type">int</span>)  &#123;<br>    this.right.PushBack(val)<br>    <span class="hljs-keyword">if</span> this.left.Len() + <span class="hljs-number">1</span> == this.right.Len() &#123;<br>        this.left.PushBack(this.right.Front().Value.(<span class="hljs-type">int</span>))<br>        this.right.Remove(this.right.Front())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PopFront() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    val := this.left.Front().Value.(<span class="hljs-type">int</span>)<br>    this.left.Remove(this.left.Front())<br>    <span class="hljs-keyword">if</span> this.left.Len() + <span class="hljs-number">1</span> == this.right.Len() &#123;<br>        this.left.PushBack(this.right.Front().Value.(<span class="hljs-type">int</span>))<br>        this.right.Remove(this.right.Front())<br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PopMiddle() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    val := this.left.Back().Value.(<span class="hljs-type">int</span>)<br>    this.left.Remove(this.left.Back())<br>    <span class="hljs-keyword">if</span> this.left.Len() + <span class="hljs-number">1</span> == this.right.Len() &#123;<br>        this.left.PushBack(this.right.Front().Value.(<span class="hljs-type">int</span>))<br>        this.right.Remove(this.right.Front())<br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FrontMiddleBackQueue)</span></span> PopBack() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.left.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.right.Len() == <span class="hljs-number">0</span> &#123;<br>        val := this.left.Back().Value.(<span class="hljs-type">int</span>)<br>        this.left.Remove(this.left.Back())<br>        <span class="hljs-keyword">return</span> val<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        val := this.right.Back().Value.(<span class="hljs-type">int</span>)<br>        this.right.Remove(this.right.Back())<br>        <span class="hljs-keyword">if</span> this.left.Len() == this.right.Len() + <span class="hljs-number">2</span> &#123;<br>            this.right.PushFront(this.left.Back().Value.(<span class="hljs-type">int</span>))<br>            this.left.Remove(this.left.Back())<br>        &#125;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2336-无限集中的最小数字"><a href="https://leetcode.cn/problems/smallest-number-in-infinite-set/">2336. 无限集中的最小数字</a></h2><blockquote><p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...]</code> 。</p><p>实现 <code>SmallestInfiniteSet</code> 类：</p><ul><li><code>SmallestInfiniteSet()</code> 初始化 <strong>SmallestInfiniteSet</strong> 对象以包含 <strong>所有</strong> 正整数。</li><li><code>int popSmallest()</code> <strong>移除</strong> 并返回该无限集中的最小整数。</li><li><code>void addBack(int num)</code> 如果正整数 <code>num</code> <strong>不</strong> 存在于无限集中，则将一个 <code>num</code> <strong>添加</strong> 到该无限集中。</li></ul></blockquote><ul><li><p>个人思路</p><ul><li><p>独家秘诀（大概</p><p><code>arr_next[i]=j</code>用于记录<code>i</code>后的下一个最小的数为<code>j</code>，若为<code>-1</code>则表示该数不在集合中；<code>minp</code>用于记录最小的数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SmallestInfiniteSet <span class="hljs-keyword">struct</span> &#123;<br>arr_next []<span class="hljs-type">int</span><br>minp     <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> SmallestInfiniteSet &#123;<br>arr_next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1005</span>, <span class="hljs-number">1005</span>)<br>minp := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1002</span>; i++ &#123;<br>arr_next[i] = i + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> SmallestInfiniteSet&#123;arr_next: arr_next, minp: minp&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> PopSmallest() <span class="hljs-type">int</span> &#123;<br>res := this.minp<br>this.minp = this.arr_next[res]<br>this.arr_next[res] = <span class="hljs-number">-1</span><br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> AddBack(num <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> this.arr_next[num] == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">if</span> this.minp &gt; num &#123;<br>this.arr_next[num] = this.minp<br>this.minp = num<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> i := num - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> this.arr_next[i] != <span class="hljs-number">-1</span> &#123;<br>this.arr_next[num] = this.arr_next[i]<br>this.arr_next[i] = num<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><p>卑鄙的官解使用库函数，而且利用了题目中操作不会大于1000的条件，这样才可以使用<code>thres</code>记录最小值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SmallestInfiniteSet <span class="hljs-keyword">struct</span> &#123;<br>    thres <span class="hljs-type">int</span><br>    s *treeset.Set<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> SmallestInfiniteSet &#123;<br>    <span class="hljs-keyword">return</span> SmallestInfiniteSet&#123;<br>        thres:<span class="hljs-number">1</span>,<br>        s:treeset.NewWithIntComparator(),<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> PopSmallest() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.s.Empty() &#123;<br>        ans := this.thres<br>        this.thres++<br>        <span class="hljs-keyword">return</span> ans<br>    &#125;<br>    it := this.s.Iterator()<br>    it.Next()<br>    ans := it.Value().(<span class="hljs-type">int</span>)<br>    this.s.Remove(ans)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *SmallestInfiniteSet)</span></span> AddBack(num <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> num &lt; this.thres &#123;<br>        this.s.Add(num)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1657-确定两个字符串是否接近"><a href="https://leetcode.cn/problems/determine-if-two-strings-are-close/">1657. 确定两个字符串是否接近</a></h2><blockquote><p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p><ul><li><p>操作 1：交换任意两个</p><p>现有</p><p>字符。</p><ul><li>例如，<code>a**b**cd**e** -&gt; a**e**cd**b**</code></li></ul></li><li><p>操作 2：将一个</p><p>现有</p><p>字符的每次出现转换为另一个</p><p>现有</p><p>字符，并对另一个字符执行相同的操作。</p><ul><li>例如，<code>**aa**c**abb** -&gt; **bb**c**baa**</code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li></ul></li></ul><p>你可以根据需要对任意一个字符串多次使用这两种操作。</p><p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果 <code>word1</code> 和 <code>word2</code> <strong>接近</strong> ，就返回 <code>true</code> ；否则，返回 <code>false</code> 。</p></blockquote><ul><li><p>官解</p><p><img src="/2023/11/01/leetcode23-11/image-20231130100552783.png" alt="image-20231130100552783"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closeStrings</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    count1, count2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">26</span>)<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> word1 &#123;<br>        count1[c - <span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> word2 &#123;<br>        count2[c - <span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br>        <span class="hljs-keyword">if</span> count1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; count2[i] == <span class="hljs-number">0</span> || count1[i] == <span class="hljs-number">0</span> &amp;&amp; count2[i] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    sort.Ints(count1)<br>    sort.Ints(count2)<br>    <span class="hljs-keyword">return</span> reflect.DeepEqual(count1, count2)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go高性能省流版</title>
    <link href="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/"/>
    <url>/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1>Go高性能编程省流</h1><p><a href="https://geektutu.com/post/high-performance-go.html">Go 语言高性能编程 | 极客兔兔 (geektutu.com)</a></p><h2 id="序言">序言</h2><ol><li>对性能敏感用go，不敏感用python。python文本处理很有优势。</li></ol><h2 id="性能分析">性能分析</h2><h3 id="benchmark基准测试">benchmark基准测试</h3><p>位于内置的<code>testing</code>库。</p><h4 id="稳定测试环境">稳定测试环境</h4><ul><li>机器处于闲置状态，测试时不要执行其他任务，也不要和其他人共享硬件资源。</li><li>机器是否关闭了节能模式，一般笔记本会默认打开这个模式，测试时关闭。</li><li>避免使用虚拟机和云主机进行测试，一般情况下，为了尽可能地提高资源的利用率，虚拟机和云主机 CPU 和内存一般会超分配，超分机器的性能表现会非常地不稳定。</li></ul><h4 id="使用">使用</h4><ol><li><p>结构</p><ul><li>benchmark 和普通的单元测试用例一样，都位于 <code>_test.go</code> 文件中。</li><li>函数名以 <code>Benchmark</code> 开头，参数是 <code>b *testing.B</code>。和普通的单元测试用例很像，单元测试函数名以 <code>Test</code> 开头，参数是 <code>t *testing.T</code>。</li></ul></li><li><p>运行</p><p><code>go test &lt;module name&gt;/&lt;package name&gt;</code> 用来运行某个 package 内的所有测试用例。</p><ul><li>运行当前 package 内的用例：<code>go test example</code> 或 <code>go test .</code></li><li>运行子 package 内的用例： <code>go test example/&lt;package name&gt;</code> 或 <code>go test ./&lt;package name&gt;</code></li><li>如果想递归测试当前目录下的所有的 package：<code>go test ./...</code> 或 <code>go test example/...</code>。</li></ul><p><code>go test</code> 命令默认不运行 benchmark 用例的，如果我们想运行 benchmark 用例，则需要加上 <code>-bench</code> 参数。</p><p><code>-bench</code> 参数支持传入一个正则表达式，匹配到的用例才会得到执行。</p></li><li><p>如何工作</p><ul><li>重复运行用例直到执行时间增长到1s，但实际运行时间会大于1s，因为测试用例编译、执行、销毁等是需要时间的。</li><li>BenchmarkFib-8 中的 <code>-8</code> 即 <code>GOMAXPROCS</code>，默认等于 CPU 核数。可以通过 <code>-cpu</code> 参数改变 <code>GOMAXPROCS</code>，<code>-cpu</code> 支持传入一个列表作为参数。</li></ul></li><li><p>提升精准度</p><ul><li><code>-benchtime</code> 参数可控制执行时间（之前说的1s）。</li><li><code>-count</code>参数可控制benchmark的轮数。</li></ul></li><li><p>内存分配</p><ul><li><code>-benchmem</code>参数可度量内存分配次数。内存分配是耗时的，重复扩展切片容量比一次分配好足够的切片容量要多耗时。</li></ul></li><li><p>测试不同输入</p><ul><li>可修改函数输入参数，设置不同数量级的输入，来验证函数的时间复杂度。</li></ul></li></ol><h4 id="注意事项">注意事项</h4><ol><li><p>ResetTimer</p><p><code>b.ResetTimer()</code>用于屏蔽耗时准备任务的干扰。</p></li><li><p>StopTimer &amp; StartTimer</p><p><code>b.StopTimer()</code>和<code>b.StartTimer()</code>用于屏蔽测试函数调用前后的准备工作和清理工作的干扰。</p></li></ol><p>如果benchmark测试用例的耗时干扰只有一次，用<code>ResetTimer</code>。如果有多次，用<code>StopTimer</code>和<code>StartTimer</code></p><h3 id="pprof性能分析">pprof性能分析</h3><p>benchmark用于对单个函数的性能分析，且这个函数是影响整个程序性能的瓶颈函数。但对于未知程序的性能分析，就需要用到pprof了。pprof包含两部分。</p><ul><li>编译到程序中的 <code>runtime/pprof</code> 包</li><li>性能剖析工具 <code>go tool pprof</code></li></ul><h4 id="性能分析类型">性能分析类型</h4><ol><li><p>CPU性能分析</p><p>寻找执行次数最多的函数。</p></li><li><p>内存性能分析</p><p>内存性能分析(Memory profiling) 记录堆内存分配时的堆栈信息，忽略栈内存分配信息。</p></li><li><p>阻塞性能分析</p><p>阻塞性能分析(block profiling) 是 Go 特有的。</p><p>判断程序的并发瓶颈时会很有用。阻塞的场景包括：</p><ul><li>在没有缓冲区的信道上发送或接收数据。</li><li>从空的信道上接收数据，或发送数据到满的信道上。</li><li>尝试获得一个已经被其他协程锁住的排它锁。</li></ul><p>一般情况下，当所有的 CPU 和内存瓶颈解决后，才会考虑这一类分析。</p></li><li><p>锁性能分析</p><p>锁性能分析(mutex profiling) 与阻塞分析类似，但专注于因为锁竞争导致的等待或延时。</p></li></ol><h4 id="CPU性能分析">CPU性能分析</h4><ol><li><p>生成profile</p><p>导入<code>os</code>和<code>runtime/pprof</code>库，在main函数中添加2行代码，可将CPU性能分析输出到标准输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">pprof.StartCPUProfile(os.Stdout)<br><span class="hljs-keyword">defer</span> pprof.StopCPUProfile()<br></code></pre></td></tr></table></figure><p>运行时可将输出重定向到文件中。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run main.go &gt; cpu.pprof<br></code></pre></td></tr></table></figure><p>但一般来说，更推荐直接输出到一个文件，避免与程序的本身输出混在一起。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">f, _ := os.OpenFile(<span class="hljs-string">&quot;cpu.pprof&quot;</span>, os.O_CREATE|os.O_RDWR, <span class="hljs-number">0644</span>)<br><span class="hljs-keyword">defer</span> f.Close()<br>pprof.StartCPUProfile(f)<br><span class="hljs-keyword">defer</span> pprof.StopCPUProfile()<br></code></pre></td></tr></table></figure></li><li><p>分析数据</p><ul><li><p>使用<code>go tool pprof</code>来分析。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go tool pprof -http=:9999 cpu.pprof<br></code></pre></td></tr></table></figure><p>需要安装<code>Graphviz</code>，访问<code>localhost:9999</code>来查看</p></li><li><p>或直接在命令行查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go tool pprof cpu.pprof<br></code></pre></td></tr></table></figure><p>会进入<code>(pprof)</code>交互模式</p><ul><li><code>top</code>按cpu消耗排序显示结果。</li><li><code>top --cum</code>按时间累计消耗排序来显示结果。</li></ul><p>若不想进入交互模式，可加入<code>-text</code>选项</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> tool pprof -text cpu.pprof<br></code></pre></td></tr></table></figure><p>直接在命令行中运行 <code>go tool pprof</code> 即可看到所有支持的选项。</p></li></ul></li></ol><h4 id="内存性能分析">内存性能分析</h4><p>可使用更强的库来分析<code>pkg/profile</code>，封装了<code>pprof</code>库，在<code>import</code>中引入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/pkg/profile&quot;</span><br>)<br></code></pre></td></tr></table></figure><ul><li><p><code>pkg/profile</code>的CPU性能分析</p><p>在main函数开头加入以下代码，运行后会在<code>/tmp</code>目录下生成CPU性能分析文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> profile.Start().Stop()<br></code></pre></td></tr></table></figure></li><li><p>内存性能分析</p><p>main函数开头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> profile.Start(profile.MemProfile, profile.MemProfileRate(<span class="hljs-number">1</span>)).Stop()<br></code></pre></td></tr></table></figure></li></ul><p>数据分析与CPU性能分析一致，可用网页和命令行两种方式查看。</p><h4 id="benchmark生成profile">benchmark生成profile</h4><p><code>testing</code> 支持生成 CPU、memory 和 block 的 profile 文件。</p><ul><li>-cpuprofile=$FILE</li><li>-memprofile=$FILE, -memprofilerate=N 调整记录速率为原来的 1/N。</li><li>-blockprofile=$FILE</li></ul><p>加入对应参数即可，如生成CPU的profile</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go <span class="hljs-built_in">test</span> -bench=<span class="hljs-string">&quot;Fib$&quot;</span> -cpuprofile=cpu.pprof .<br></code></pre></td></tr></table></figure><h2 id="常用数据结构">常用数据结构</h2><h3 id="字符串拼接性能及原理">字符串拼接性能及原理</h3><h4 id="高效拼接">高效拼接</h4><p>在 Go 语言中，字符串(string) 是不可变的，拼接字符串事实上是创建了一个新的字符串对象。如果代码中存在大量的字符串拼接，对性能会产生严重的影响。</p><ol><li><p>5种常见拼接方式（拼接<code>a</code>,<code>b</code>到<code>c</code>）</p><ul><li><p>使用 <code>+</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := a + b<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>fmt.Sprintf</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">c := fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, a, b)<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>strings.Builder</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> builder strings.Builder<br>builder.WriteString(a)<br>builder.WriteString(b)<br>c := builder.String()<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>bytes.Buffer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">buf := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>buf.WriteString(a)<br>buf.WriteString(b)<br>c := buf.String()<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>[]byte</code>，此时c是<code>[]byte</code>，需要用<code>string(c)</code>来转换</p><ul><li><p>预分配容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a)+<span class="hljs-built_in">len</span>(b))<br>c = <span class="hljs-built_in">append</span>(c, a...)<br>c = <span class="hljs-built_in">append</span>(c, b...)<br></code></pre></td></tr></table></figure></li><li><p>不预分配容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br>c = <span class="hljs-built_in">append</span>(c, a...)<br>c = <span class="hljs-built_in">append</span>(c, b...)<br></code></pre></td></tr></table></figure></li></ul><p><code>make()</code>的第一个参数是类型，第二个参数是长度，第三个参数是容量。</p></li></ul></li><li><p>性能比较</p><p>使用 <code>+</code> 和 <code>fmt.Sprintf</code> 的效率是最低的，<code>strings.Builder</code>、<code>bytes.Buffer</code> 和 <code>[]byte</code> 的性能差距不大，而且消耗的内存也十分接近，性能最好且消耗内存最小的是 <code>preByteConcat</code>，这种方式预分配了内存，在字符串拼接的过程中，不需要进行字符串的拷贝，也不需要分配新的内存，因此性能最好，且内存消耗最小。</p></li><li><p>建议</p><p>综合易用性和性能，一般推荐使用 <code>strings.Builder</code> 来拼接字符串。</p><p>且<code>string.Builder</code> 也提供了预分配内存的方式 <code>Grow</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">builder.Grow(<span class="hljs-built_in">len</span>(a) + <span class="hljs-built_in">len</span>(b))<br></code></pre></td></tr></table></figure></li></ol><h4 id="性能背后的原理">性能背后的原理</h4><ol><li><p>string.Builder与+</p><p><code>string.Builder</code>申请空间是成倍增长的(到2048后会改变申请策略），而<code>+</code>是每次都申请一个新的字符串拼接之和的空间大小，故<code>string.Builder</code>的申请空间次数少，耗时就少。</p></li><li><p>string.Builder与bytes.Buffer</p></li></ol><p><code>bytes.Buffer</code> 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 <code>strings.Builder</code> 直接将底层的 <code>[]byte</code> 转换成了字符串类型返回了回来。故<code>strings.Builder</code>略快。</p><h3 id="切片-slice-性能及陷阱">切片(slice)性能及陷阱</h3><h4 id="切片的本质">切片的本质</h4><ol><li><p>数组</p><ul><li>数组类型定义了长度和元素类型，长度不同的 2 个数组是不可以相互赋值的，因为这 2 个数组属于不同的类型。</li><li>在 C 语言中，数组变量是指向第一个元素的指针，但是 Go 语言中并不是。Go 语言中，数组变量属于值类型(value type)，因此当一个数组变量被赋值或者传递时，实际上会复制整个数组。例如，将 a 赋值给 b，修改 a 中的元素并不会改变 b 中的元素</li><li>因此，函数想要对数组进行修改，应传入指针，否则将会复制一个数组。</li></ul></li><li><p>切片</p><ul><li><p>切片使用字面量初始化时和数组很像，但是不需要指定长度。注意与数组的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>b := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>fmt.Println(reflect.TypeOf(a).Kind()) <span class="hljs-comment">//array</span><br>fmt.Println(reflect.TypeOf(b).Kind()) <span class="hljs-comment">//slice</span><br></code></pre></td></tr></table></figure></li><li><p>或者使用内置函数 make 进行初始化，make 的函数定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">([]T, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>)</span></span> []T<br></code></pre></td></tr></table></figure><p>第一个参数是 <code>[]T</code>，T 即元素类型，第二个参数是长度 len，即初始化的切片拥有多少个元素，第三个参数是容量 cap，容量是可选参数，默认等于长度。</p></li><li><p>切片的空间申请也是成倍增长的(到2048后会改变申请策略）参看 <a href="https://golang.org/src/runtime/slice.go">runtime/slice.go</a></p></li><li><p>切片本质是一个数组片段的描述，包括了数组的指针，这个片段的长度和容量(不改变内存分配情况下的最大长度)。</p></li><li><p>切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的。</p></li></ul></li></ol><h4 id="切片操作及性能">切片操作及性能</h4><ol><li><p>copy<img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/copy.png" alt="hpg-slice"></p></li><li><p>append</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/append.png" alt="hpg-slice"></p><p>切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景：</p><ul><li>当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间。</li><li>当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组。</li></ul><blockquote><p>因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能。</p></blockquote></li><li><p>delete</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/delete.png" alt="hpg-slice"></p><p>切片的底层是数组，因此删除意味着后面的元素需要逐个向前移位。每次删除的复杂度为 O(N)，因此切片不合适大量随机删除的场景，这种场景下适合使用链表。</p></li><li><p>delete(gc)垃圾回收</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/delete_gc.png" alt="hpg-slice"></p></li><li><p>insert</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/insert.png" alt="hpg-slice"></p><p>insert 和 append 类似。即在某个位置添加一个元素后，将该位置后面的元素再 append 回去。复杂度为 O(N)。因此，不适合大量随机插入的场景。</p></li><li><p>filter(in place)就地</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/filter_in_place.png" alt="hpg-slice"></p><p>个人理解也可以gc？重点在于<code>a = a[:n]</code>。</p></li><li><p>push</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/push.png" alt="hpg-slice"></p><p>在末尾追加元素，不考虑内存拷贝的情况，复杂度为 O(1)。</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/push_front.png" alt="hpg-slice"></p><p>在头部追加元素，时间和空间复杂度均为 O(N)，不推荐。</p></li><li><p>pop</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/pop.png" alt="hpg-slice"></p><p>尾部删除元素，复杂度 O(1)</p><p><img src="/2023/10/27/Go%E9%AB%98%E6%80%A7%E8%83%BD%E7%9C%81%E6%B5%81%E7%89%88/pop_front.png" alt="hpg-slice"></p><p>头部删除元素，如果使用切片方式，复杂度为 O(1)。但是需要注意的是，底层数组没有发生改变，第 0 个位置的内存仍旧没有释放。如果有大量这样的操作，头部的内存会一直被占用。</p></li></ol><h4 id="性能陷阱">性能陷阱</h4><p>在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组。因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。比较推荐的做法，使用 <code>copy</code> 替代 <code>re-slice</code>。</p><h3 id="for和range的性能比较">for和range的性能比较</h3><ol><li><p>int[]</p><p>遍历 []int 类型的切片，for 与 range 性能几乎没有区别。</p></li><li><p>[]struct</p><ul><li>仅遍历下标的情况下，for 和 range 的性能几乎是一样的。</li><li>与 for 不同的是，<code>range</code> 对每个迭代值都创建了一个拷贝。因此如果每次迭代的值内存占用很小的情况下，for 和 range 的性能几乎没有差异，但是如果每个迭代值内存占用很大，for的性能就会优于range</li><li>因此，利用range对[]T做修改时，将会无效。</li></ul></li><li><p>[]*struct{}</p><p>for 和 range 的性能几乎是一样的。而且使用指针还有另一个好处，可以直接修改指针对应的结构体的值。</p></li><li><p>总结</p><p>range 在迭代过程中返回的是迭代值的拷贝，如果每次迭代的元素的内存占用很低，那么 for 和 range 的性能几乎是一样，例如 <code>[]int</code>。但是如果迭代的元素内存占用较高，例如一个包含很多属性的 struct 结构体，那么 for 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 for，如果使用 range，建议只迭代下标，通过下标访问迭代值，这种使用方式和 for 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。</p></li></ol><h3 id="反射（reflect）性能">反射（reflect）性能</h3><h4 id="反射的用途">反射的用途</h4><p>标准库 <a href="https://golang.org/pkg/reflect/">reflect</a> 为 Go 语言提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。</p><h4 id="如何简化代码">如何简化代码</h4><p>利用反射去获取结构体中的tag来进行操作。详见<a href="https://geektutu.com/post/hpg-reflect.html">Go Reflect 提高反射性能 | Go 语言高性能编程 | 极客兔兔 (geektutu.com)</a>。</p><h4 id="反射的性能">反射的性能</h4><ol><li><p>创建对象</p><p>reflect耗时约为new的1.5倍。</p></li><li><p>修改字段的值</p><p>耗时：直接赋值&lt;通过下标寻找对应字段再赋值(<code>Field[]</code>）&lt;通过字段名寻找对应字段再赋值(<code>FieldByName</code>)</p></li><li><p>性能差距原理</p><p>Filed[]通过下标访问，是O（1），FieldByName是顺序查找字段名，是O(n)。</p></li></ol><h4 id="提高性能">提高性能</h4><ol><li><p>避免使用reflect</p><p>例如 RPC 协议中，需要对结构体进行序列化和反序列化，这个时候避免使用 Go 语言自带的 <code>json</code> 的 <code>Marshal</code> 和 <code>Unmarshal</code> 方法，因为标准库中的 json 序列化和反序列化是利用反射实现的。可选的替代方案有 <a href="https://github.com/mailru/easyjson">easyjson</a>，在大部分场景下，相比标准库，有 5 倍左右的性能提升。</p></li><li><p>缓存</p><p><code>FieldByName</code> 相比于 <code>Field</code> 有一个数量级的性能劣化。那在实际的应用中，就要避免直接调用 <code>FieldByName</code>。我们可以利用字典将 <code>Name</code> 和 <code>Index</code> 的映射缓存起来。避免每次反复查找，耗费大量的时间。</p></li></ol><h3 id="空结构体节省内存">空结构体节省内存</h3><h4 id="空结构体不占用空间">空结构体不占用空间</h4><p>空结构体不占用空间！！！</p><h4 id="空结构体的作用">空结构体的作用</h4><p>因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符。</p><ol><li><p>实现集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>不发送数据的channel</p><p>有时候使用 channel 不需要发送任何的数据，只用来通知子协程(goroutine)执行任务，或只用来控制协程并发度。这种情况下，使用空结构体作为占位符就非常合适了。</p></li><li><p>仅包含方法的结构体</p><p>在部分场景下，结构体只包含方法，不包含任何的字段。</p></li></ol><h3 id="内存对齐对性能的影响">内存对齐对性能的影响</h3><h4 id="结构体体积">结构体体积</h4><p>一个结构体实例所占据的空间等于各字段占据空间之和，再加上内存对齐的空间大小。</p><h4 id="内存对齐">内存对齐</h4><ol><li><p>为什么</p><ul><li>CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。</li><li>故内存对齐的目的是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。</li><li>合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。</li></ul></li><li><p>unsafe.Alignof</p><p><code>unsafe</code> 标准库提供了 <code>Alignof</code> 方法，可以返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。</p></li><li><p>对齐保证（align guarantee)</p><ul><li>对于任意类型的变量 x ，<code>unsafe.Alignof(x)</code> 至少为 1。</li><li>对于 struct 结构体类型的变量 x，计算 x 每一个字段 f 的 <code>unsafe.Alignof(x.f)</code>，<code>unsafe.Alignof(x)</code> 等于其中的最大值。</li><li>对于 array 数组类型的变量 x，<code>unsafe.Alignof(x)</code> 等于构成数组的元素类型的对齐倍数。</li><li>没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0，不同的大小为 0 的变量可能指向同一块地址。</li></ul></li></ol><h4 id="技巧">技巧</h4><ol><li>调整字段顺序，减少内存占用。</li><li>空struct{}的对齐<ul><li>空 <code>struct&#123;&#125;</code> 大小为 0，作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 <code>struct&#123;&#125;</code> 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段, 返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。</li><li>因此，别把空<code>struct&#123;&#125;</code>放最后就好。</li></ul></li></ol><h2 id="并发编程">并发编程</h2><h3 id="读写锁和互斥锁的性能比较">读写锁和互斥锁的性能比较</h3><p>一句话，在读&gt;=写的情景下，sync.RWMutex优于sync.Mutex。</p><h4 id="互斥锁如何实现公平">互斥锁如何实现公平</h4><p><a href="https://colobu.com/2018/12/18/dive-into-sync-mutex/">sync.mutex 源代码分析</a> 这篇文章介绍了 sync.Mutex 的演进历史和当前的实现机制。</p><blockquote><p>互斥锁有两种状态：正常状态和饥饿状态。</p><p>在正常状态下，所有等待锁的 goroutine 按照FIFO顺序等待。唤醒的 goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过 1ms 没有获取锁，那么它将会把锁转变为饥饿模式。</p><p>在饥饿模式下，锁的所有权将从 unlock 的 goroutine 直接交给交给等待队列中的第一个。新来的 goroutine 将不会尝试去获得锁，即使锁看起来是 unlock 状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p><p>如果一个等待的 goroutine 获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。</p><p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p></blockquote><h3 id="退出协程（超时场景）">退出协程（超时场景）</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo折叠内容</title>
    <link href="/2023/10/26/hexo%E6%8A%98%E5%8F%A0%E5%86%85%E5%AE%B9/"/>
    <url>/2023/10/26/hexo%E6%8A%98%E5%8F%A0%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1>hexo折叠内容</h1><h2 id="利用html语言">利用html语言</h2><p>这种方法在typora中也可以显示，但由于是html语言，折叠的内容是plain text，不美观。</p><p>在typora输入下述代码即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span>答案<span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span><br>    隐藏内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span><br></code></pre></td></tr></table></figure><details>    <summary>答案</summary>    隐藏内容</details><h2 id="利用Hexo插件">利用Hexo插件</h2><p>参考<a href="https://wty-yy.space/posts/44830/">Hexo Fluid 代码折叠 - wty’s blog (wty-yy.space)</a></p><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-sliding-spoiler --save<br></code></pre></td></tr></table></figure></li><li><p>修改<code>node_modules/hexo-sliding-spoiler/assets/spoiler.css</code>下的内容，从而自定义配置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.spoiler</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">105</span>, <span class="hljs-number">105</span>, <span class="hljs-number">105</span>);<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">clear</span>: both;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span> <span class="hljs-selector-class">.spoiler-title</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">105</span>, <span class="hljs-number">105</span>, <span class="hljs-number">105</span>);<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> -<span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">cursor</span>: pointer;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span> <span class="hljs-selector-class">.spoiler-title</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">font-weight</span>: bold;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span><span class="hljs-selector-class">.collapsed</span> <span class="hljs-selector-class">.spoiler-title</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;▲ &quot;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span><span class="hljs-selector-class">.expanded</span> <span class="hljs-selector-class">.spoiler-title</span><span class="hljs-selector-pseudo">:before</span> &#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;▼ &quot;</span>;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span> <span class="hljs-selector-class">.spoiler-content</span> &#123;<br>    <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>;<br>    -moz-<span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">0.3s</span>;<br>    -webkit-<span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">0.3s</span>;<br>    -o-<span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">0.3s</span>;<br>    <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">0.3s</span>;<br>    -moz-<span class="hljs-attribute">transition-timing-function</span>: ease-in-out;<br>    -webkit-<span class="hljs-attribute">transition-timing-function</span>: ease-in-out;<br>    -o-<span class="hljs-attribute">transition-timing-function</span>: ease-in-out;<br>    <span class="hljs-attribute">transition-timing-function</span>: ease-in-out;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span><span class="hljs-selector-class">.collapsed</span> <span class="hljs-selector-class">.spoiler-content</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">max-height</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span><span class="hljs-selector-class">.expanded</span> <span class="hljs-selector-class">.spoiler-content</span> &#123;<br>    <span class="hljs-attribute">max-height</span>: <span class="hljs-number">3000px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-class">.spoiler</span> <span class="hljs-selector-class">.spoiler-content</span> <span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<br>    <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用方法</p><p>在markdown中直接以标签的形式插入，如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% spoiler &quot;答案&quot; %&#125;<br><br>支持markdown语法，代码块，数学公式<br><br>```go<br>if val, ok := dict[&quot;foo&quot;]; ok &#123;<br>    //do something here<br>&#125;<br>```<br><br>dict[&quot;foo&quot;] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key &quot;foo&quot;，val 将被赋予 &quot;foo&quot; 对应的值。<br><br>&#123;% endspoiler %&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>支持markdown语法，代码块，数学公式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> val, ok := dict[<span class="hljs-string">&quot;foo&quot;</span>]; ok &#123;<br>    <span class="hljs-comment">//do something here</span><br>&#125;<br></code></pre></td></tr></table></figure><p>dict[“foo”] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p>    </div></div></li></ol><h2 id="代码块折叠">代码块折叠</h2><blockquote><p>参考<a href="https://github.com/fluid-dev/hexo-theme-fluid/issues/629">给代码块增加折叠功能 · Issue #629 · fluid-dev/hexo-theme-fluid · GitHub</a></p><p>另一种方式无法成功，可能是缺失图标资源库。<a href="https://kiyanyang.github.io/posts/c4dd4019/">使用 Hexo 过滤器实现 Fluid 主题的代码折叠 | Kiyan’s Blog (kiyanyang.github.io)</a></p></blockquote><ol><li><p>在<code>Blog\themes\fluid\source\js</code>下添加文件<code>code-collapse.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// KiyanYang</span><br><br><span class="hljs-comment">// 获取唯一 ID</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUuiD</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>) + <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addLanguage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 获取所有 figure.highlight 元素</span><br>    <span class="hljs-keyword">var</span> hs = $(<span class="hljs-string">&quot;figure.highlight&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hs.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-comment">// 获取代码语言</span><br>        <span class="hljs-keyword">var</span> lang = hs[i].<span class="hljs-property">firstChild</span>.<span class="hljs-property">firstChild</span>.<span class="hljs-property">firstChild</span>.<span class="hljs-property">lastChild</span>.<span class="hljs-property">firstChild</span>.<span class="hljs-property">firstChild</span>.<span class="hljs-property">classList</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 折叠块的 id</span><br>        <span class="hljs-keyword">var</span> id = <span class="hljs-string">`kiyan-collapse-<span class="hljs-subst">$&#123;getUuiD()&#125;</span>`</span>;<br>        <span class="hljs-comment">// 前面折叠按钮，这里我使用的是 FAS 图标，可以在 custom_css 添加 https://use.fontawesome.com/releases/v5.15.4/css/all.css 来引入</span><br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-string">`&lt;i class=&quot;fas fa-angle-down&quot; type=&quot;button&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#<span class="hljs-subst">$&#123;id&#125;</span>&quot;&gt;&lt;/i&gt;`</span>;<br>        <span class="hljs-comment">// 代码语言</span><br>        <span class="hljs-keyword">var</span> span = <span class="hljs-string">`&lt;span&gt;<span class="hljs-subst">$&#123;lang&#125;</span>&lt;/span&gt;`</span>;<br>        <span class="hljs-comment">// 折叠块包裹原来的内容</span><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-string">`&lt;div class=&quot;collapse show&quot; id=&quot;<span class="hljs-subst">$&#123;id&#125;</span>&quot;&gt;<span class="hljs-subst">$&#123;hs[i].innerHTML&#125;</span>&lt;/div&gt;`</span>;<br>        hs[i].<span class="hljs-property">innerHTML</span> = btn + span + div;<br>    &#125;<br>&#125;<br><br>$(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ready</span>(addLanguage);<br></code></pre></td></tr></table></figure></li><li><p>在<code>Blog\themes\fluid\source\css</code>下添加文件<code>code-collapse.styl</code>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// ==================================================</span><br><span class="hljs-comment">// 代码块折叠</span><br><span class="hljs-comment">// ==================================================</span><br><span class="hljs-selector-tag">figure</span><span class="hljs-selector-class">.highlight</span> &#123;<br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">112</span>,<span class="hljs-number">128</span>,<span class="hljs-number">144</span>);<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0.5rem</span>;<br><br>    <span class="hljs-selector-tag">table</span> &#123;<br>        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0.5rem</span> <span class="hljs-number">0.5rem</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 折叠图标动画</span><br>    <span class="hljs-selector-class">.fas</span><span class="hljs-selector-class">.fa-angle-down</span> &#123;<br>        <span class="hljs-attribute">transform</span>: none;<br>        <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">0.2s</span> ease-in-out;<br><br>        &amp;<span class="hljs-selector-class">.collapsed</span> &#123;<br>            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(-<span class="hljs-number">90deg</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 折叠图标</span><br>    &gt; <span class="hljs-selector-tag">i</span> &#123;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-number">#E6E6FA</span>;<br>        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">2rem</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 代码语言</span><br>    &gt; <span class="hljs-selector-tag">span</span> &#123;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-number">#E6E6FA</span>;<br>        <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;<br>        <span class="hljs-attribute">font-weight</span>: bold;<br>    &#125;<br><br>    <span class="hljs-comment">// 固定代码块的第一列也即固定代码行数</span><br>    <span class="hljs-selector-tag">td</span><span class="hljs-selector-pseudo">:first-child</span> &#123;<br>        <span class="hljs-attribute">position</span>: sticky;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// ==================================================</span><br><span class="hljs-comment">// 代码块的复制按钮</span><br><span class="hljs-comment">// ==================================================</span><br><span class="hljs-selector-class">.copy-btn</span> &#123;<br>    <span class="hljs-comment">// 注意：top 是和折叠功能共生的</span><br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">5px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1rem</span>;<br><br>    &gt; <span class="hljs-selector-tag">i</span> &#123;<br>        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.875rem</span>;<br>        <span class="hljs-attribute">font-weight</span>: bold;<br>    &#125;<br>&#125;<br><br><span class="hljs-selector-class">.copy-btn-dark</span> &#123;<br>    <span class="hljs-attribute">color</span>: darkslategrey;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改主题配置文件<code>Blog\_config.fluid.yml</code>的<code>custom_js</code>和<code>custom_css</code>，<code>custom_css</code>下的网址是资源库。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js</span><br><span class="hljs-comment"># Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`</span><br><span class="hljs-attr">custom_js:</span>  <span class="hljs-string">/js/code-collapse.js</span><br><br><span class="hljs-comment"># 指定自定义 .css 文件路径，用法和 custom_js 相同</span><br><span class="hljs-comment"># The usage is the same as custom_js</span><br><span class="hljs-attr">custom_css:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">https://lib.baomitu.com/font-awesome/6.1.2/css/all.min.css</span> <span class="hljs-comment"># Font Awesome</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">/css/code-collapse</span><br></code></pre></td></tr></table></figure></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言笔试面试题</title>
    <link href="/2023/10/26/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/10/26/Go%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>Go 语言笔试面试题</h1><p><a href="https://geektutu.com/post/qa-golang.html">Go 语言笔试面试题汇总 | 极客面试 | 极客兔兔 (geektutu.com)</a></p><h2 id="基础语法">基础语法</h2><h3 id="和-的区别？"><code>=</code>和<code>:=</code>的区别？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p><code>=</code>是赋值</p><p><code>:=</code>是声明+赋值</p>    </div></div><h3 id="指针的作用？">指针的作用？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>指针用来保存变量的地址。</p><p>例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x =  <span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = &amp;x<br>fmt.Printf(<span class="hljs-string">&quot;x = %d&quot;</span>,  *p) <span class="hljs-comment">// x 可以用 *p 访问</span><br></code></pre></td></tr></table></figure><ul><li><code>*</code> 运算符，也称为解引用运算符，用于访问地址中的值。</li><li><code>＆</code>运算符，也称为地址运算符，用于返回变量的地址。</li></ul>    </div></div><h3 id="Go-允许多个返回值吗？">Go 允许多个返回值吗？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>允许</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   a, b := swap(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>)<br>   fmt.Println(a, b) <span class="hljs-comment">// B A</span><br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><h3 id="Go-有异常类型吗？">Go 有异常类型吗？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>Go 没有异常类型，只有错误类型（Error），通常使用返回值来表示异常状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err := os.Open(<span class="hljs-string">&quot;test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><h3 id="什么是协程（Goroutine）">什么是协程（Goroutine）</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>Goroutine 是与其他函数或方法同时运行的函数或方法。 Goroutines 可以被认为是轻量级的线程。 与线程相比，创建 Goroutine 的开销很小。 Go应用程序同时运行数千个 Goroutine 是非常常见的做法。</p>    </div></div><h3 id="如何高效地拼接字符串">如何高效地拼接字符串</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 <code>strings.Builder</code>，最小化内存拷贝次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> str strings.Builder<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>    str.WriteString(<span class="hljs-string">&quot;a&quot;</span>)<br>&#125;<br>fmt.Println(str.String())<br></code></pre></td></tr></table></figure>    </div></div><h3 id="什么是-rune-类型">什么是 rune 类型</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p><p>Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。例如下面的例子中 <code>语</code> 和 <code>言</code> 使用 UTF-8 编码后各占 3 个 byte，因此 <code>len(&quot;Go语言&quot;)</code> 等于 8，当然我们也可以将字符串转换为 rune 序列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;Go语言&quot;</span>)) <span class="hljs-comment">// 8</span><br>fmt.Println(<span class="hljs-built_in">len</span>([]<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;Go语言&quot;</span>))) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>    </div></div><h3 id="如何判断-map-中是否包含某个-key-？">如何判断 map 中是否包含某个 key ？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> val, ok := dict[<span class="hljs-string">&quot;foo&quot;</span>]; ok &#123;<br>    <span class="hljs-comment">//do something here</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​    dict[“foo”] 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 dict 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p>    </div></div><h3 id="Go-支持默认参数或可选参数吗？">Go 支持默认参数或可选参数吗？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>Go 语言不支持默认参数或可选参数（python 支持），也不支持方法重载（java支持）。</p><p>但可以通过传入一个函数作为参数（该函数的作用是给参数赋默认值）来实现，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Option <span class="hljs-keyword">struct</span> &#123;<br>  num <span class="hljs-type">int</span><br>  str <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ModOption <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *Option)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(modOption ModOption)</span></span> *Foo &#123;<br>  <span class="hljs-comment">// 默认值</span><br>  option := Option&#123;<br>    num: <span class="hljs-number">100</span>,<br>    str: <span class="hljs-string">&quot;hello&quot;</span>,<br>  &#125;<br><br>  modOption(&amp;option)<br><br>  <span class="hljs-keyword">return</span> &amp;Foo&#123;<br>    option: option,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用方函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">New(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(option *Option)</span></span> &#123;<br>  <span class="hljs-comment">// 调用方只设置 num</span><br>  option.num = <span class="hljs-number">200</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>详见：[Go创建对象时，如何优雅的传递初始化参数 - 知乎 (<a href="http://zhihu.com">zhihu.com</a>)](<a href="https://zhuanlan.zhihu.com/p/93928756#:~:text=Go%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BC%A0%E9%80%92%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0">https://zhuanlan.zhihu.com/p/93928756#:~:text=Go创建对象时，如何优雅的传递初始化参数</a> 1 支持传递多个参数 2,参数个数、类型发生变化时，尽量保持接口的兼容性 3 参数支持默认值 4 具体的参数可根据调用方需关心的程度，决定是否提供默认值)</p>    </div></div><h3 id="defer-的执行顺序">defer 的执行顺序</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <ul><li>多个 defer 语句，遵从后进先出(Last In First Out，LIFO)的原则，最后声明的 defer 语句，最先得到执行。</li><li>defer 在 return 语句之后执行，但在函数退出之前，defer 可以修改返回值。</li></ul><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;defer1&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i += <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;defer2&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, test())<br>&#125;<br><span class="hljs-comment">// defer2</span><br><span class="hljs-comment">// defer1</span><br><span class="hljs-comment">// return 0</span><br></code></pre></td></tr></table></figure><p>这个例子中，可以看到 defer 的执行顺序：后进先出。但是返回值并没有被修改，这是由于 Go 的返回机制决定的，执行 return 语句后，Go 会创建一个临时变量保存返回值，因此，defer 语句修改了局部变量 i，并没有修改返回值。那如果是有名的返回值呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br>i = <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i += <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;defer2&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">return</span> i<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;return&quot;</span>, test())<br>&#125;<br><span class="hljs-comment">// defer2</span><br><span class="hljs-comment">// return 1</span><br></code></pre></td></tr></table></figure><p>这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。</p>    </div></div><h3 id="如何交换-2-个变量的值？">如何交换 2 个变量的值？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">a, b := <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span><br>a, b = b, a<br>fmt.Println(a, b) <span class="hljs-comment">// B A</span><br></code></pre></td></tr></table></figure>    </div></div><h3 id="Go-语言-tag-的用处？">Go 语言 tag 的用处？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>tag 可以理解为 struct 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过反射获取到某个字段定义的属性，采取相应的处理方式。tag 丰富了代码的语义，增强了灵活性。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;encoding/json&quot;</span><br><br><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stu_name&quot;`</span><br>ID   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stu_id&quot;`</span><br>Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>buf, _ := json.Marshal(Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;t001&quot;</span>, <span class="hljs-number">18</span>&#125;)<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, buf)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子使用 tag 定义了结构体字段与 json 字段的转换关系，Name -&gt; <code>stu_name</code>, ID -&gt; <code>stu_id</code>，忽略 Age 字段。很方便地实现了 Go 结构体与不同规范的 json 文本之间的转换。</p>    </div></div><h3 id="如何判断-2-个字符串切片（slice-是相等的？">如何判断 2 个字符串切片（slice) 是相等的？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>go 语言中可以使用反射 <code>reflect.DeepEqual(a, b)</code> 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。</p><p>通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StringSliceEqualBCE</span><span class="hljs-params">(a, b []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) != <span class="hljs-built_in">len</span>(b) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">nil</span>) != (b == <span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    b = b[:<span class="hljs-built_in">len</span>(a)]<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>        <span class="hljs-keyword">if</span> v != b[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中的<code>b = b[:len(a)]</code>在<code>go 1.15.6</code>之前起优化的作用，防止编译器做边界检查（BCE），<code>go 1.15.6</code>之后就没有用了。</p>    </div></div><h3 id="字符串打印时，-v-和-v-的区别">字符串打印时，<code>%v</code> 和 <code>%+v</code> 的区别</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p><code>%v</code> 和 <code>%+v</code> 都可以用来打印 struct 的值，区别在于 <code>%v</code> 仅打印各个字段的值，<code>%+v</code> 还会打印各个字段的名称。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;) <span class="hljs-comment">// &#123;Tom&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;) <span class="hljs-comment">// &#123;Name:Tom&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但如果结构体定义了 <code>String()</code> 方法，<code>%v</code> 和 <code>%+v</code> 都会调用 <code>String()</code> 覆盖默认值。</p>    </div></div><h3 id="Go-语言中如何表示枚举值-enums-？">Go 语言中如何表示枚举值(enums)？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>通常使用常量(const) 来表示枚举值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StuType <span class="hljs-type">int32</span><br><br><span class="hljs-keyword">const</span> (<br>Type1 StuType = <span class="hljs-literal">iota</span><br>Type2<br>Type3<br>Type4<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Type1, Type2, Type3, Type4) <span class="hljs-comment">// 0, 1, 2, 3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意是<code>iota</code>不是<code>itoa</code></p><p>参考 <a href="https://stackoverflow.com/questions/14426366/what-is-an-idiomatic-way-of-representing-enums-in-go">What is an idiomatic way of representing enums in Go? - StackOverflow</a></p>    </div></div><h3 id="空-struct-的用途">空 struct{} 的用途</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>使用空结构体 struct{} 可以节省内存，<strong>一般作为占位符使用</strong>，表明这里并不需要一个值。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fmt.<span class="hljs-constructor">Println(<span class="hljs-params">unsafe</span>.Sizeof(<span class="hljs-params">struct</span>&#123;&#125;&#123;&#125;)</span>) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>比如使用 map 表示集合时，只关注 key，value 可以使用 struct{} 作为占位符。如果使用其他类型作为占位符，例如 int，bool，不仅浪费了内存，而且容易引起歧义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>set := <span class="hljs-built_in">make</span>(Set)<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125; &#123;<br>set[item] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>fmt.Println(<span class="hljs-built_in">len</span>(set)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">if</span> _, ok := set[<span class="hljs-string">&quot;A&quot;</span>]; ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;A exists&quot;</span>) <span class="hljs-comment">// A exists</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，使用信道(channel)控制并发时，<strong>我们只是需要一个信号，但并不需要传递值</strong>，这个时候，也可以使用 struct{} 代替。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-ch<br><span class="hljs-comment">// do something</span><br>&#125;()<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，<strong>声明只包含方法的结构体</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Lamp <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> On() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;On&quot;</span>)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> Off() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Off&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><h2 id="实现原理">实现原理</h2><h3 id="init-函数是什么时候执行的？">init() 函数是什么时候执行的？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p><code>init()</code> 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 <code>init()</code> 函数。同一个包，甚至是同一个源文件可以有多个 <code>init()</code> 函数。<code>init()</code> 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 <code>init()</code> 函数的执行顺序不作保证。</p><p>一句话总结： <strong>import –&gt; const –&gt; var –&gt; <code>init()</code> –&gt; <code>main()</code></strong></p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(<span class="hljs-string">&quot;init1:&quot;</span>, a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>  &#123;<br>fmt.Println(<span class="hljs-string">&quot;init2:&quot;</span>, a)<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">100</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main:&quot;</span>, a)<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br><span class="hljs-comment">// init1: 10</span><br><span class="hljs-comment">// init2: 10</span><br><span class="hljs-comment">// main: 10</span><br></code></pre></td></tr></table></figure>    </div></div><h3 id="Go-语言的局部变量分配在栈上还是堆上？">Go 语言的局部变量分配在栈上还是堆上？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>v := <span class="hljs-number">11</span><br><span class="hljs-keyword">return</span> &amp;v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := foo()<br><span class="hljs-built_in">println</span>(*m) <span class="hljs-comment">// 11</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>foo()</code> 函数中，如果 v 分配在栈上，foo 函数返回时，<code>&amp;v</code> 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。</p>    </div></div><h3 id="2-个-interface-可以比较吗-？">2 个 interface 可以比较吗 ？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>Go 语言中，interface 的内部实现包含了 2 个字段，类型 <code>T</code> 和 值 <code>V</code>，interface 可以使用 <code>==</code> 或 <code>!=</code> 比较。2 个 interface 相等有以下 2 种情况</p><ol><li>两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</li><li>类型 T 相同，且对应的值 V 相等。</li></ol><p>看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stu <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> StuInt <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> stu1, stu2 StuInt = &amp;Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;, &amp;Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;<br><span class="hljs-keyword">var</span> stu3, stu4 StuInt = Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;, Stu&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;<br>fmt.Println(stu1 == stu2) <span class="hljs-comment">// false</span><br>fmt.Println(stu3 == stu4) <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>stu1</code> 和 <code>stu2</code> 对应的类型是 <code>*Stu</code>，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br><code>stu3</code> 和 <code>stu4</code> 对应的类型是 <code>Stu</code>，值是 Stu 结构体，且各字段相等，因此结果为 true。</p>    </div></div><h3 id="2-个-nil-可能不相等吗？！">2 个 nil 可能不相等吗？！</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>可能。</p><p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 <code>T</code> 和 值 <code>V</code>。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p><ul><li>两个接口值比较时，会先比较 T，再比较 V。</li><li>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span> = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = p<br>fmt.Println(i == p) <span class="hljs-comment">// true</span><br>fmt.Println(p == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true</span><br>fmt.Println(i == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为<code>(T=*int, V=nil)</code>，i 与 p 作比较时，将 p 转换为接口后再比较，因此 <code>i == p</code>，p 与 nil 比较，直接比较值，所以 <code>p == nil</code>。</p><p>但是当 i 与 nil 比较时，会将 nil 转换为接口 <code>(T=nil, V=nil)</code>，与i <code>(T=*int, V=nil)</code> 不相等，因此 <code>i != nil</code>。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</p>    </div></div><h3 id="简述-Go-语言GC-垃圾回收-的工作原理">简述 Go 语言GC(垃圾回收)的工作原理</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。</p><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段 — 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段 — 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><p>标记清除算法的一大问题是在标记期间，需要暂停程序（Stop the world，STW），标记结束之后，用户程序才可以继续执行。为了能够异步执行，减少 STW 的时间，Go 语言采用了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色：不确定对象。</li><li>灰色：存活对象，子对象待处理。</li><li>黑色：存活对象。</li></ul><p>标记开始时，所有对象加入白色集合（这一步需 STW ）。首先将根对象标记为灰色，加入灰色集合，垃圾搜集器取出一个灰色对象，将其标记为黑色，并将其指向的对象标记为灰色，加入灰色集合。重复这个过程，直到灰色集合为空为止，标记阶段结束。那么白色对象即可需要清理的对象，而黑色对象均为根可达的对象，不能被清理。</p><p>三色标记法因为多了一个白色的状态来存放不确定对象，所以后续的标记阶段可以并发地执行。当然并发执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。</p><p>三色标记法并发执行仍存在一个问题，即在 GC 过程中，对象指针发生了改变。比如下面的例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">A <span class="hljs-function"><span class="hljs-params">(黑)</span> -&gt;</span> B <span class="hljs-function"><span class="hljs-params">(灰)</span> -&gt;</span> C <span class="hljs-function"><span class="hljs-params">(白)</span> -&gt;</span> D (白)<br></code></pre></td></tr></table></figure><p>正常情况下，D 对象最终会被标记为黑色，不应被回收。但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">A <span class="hljs-function"><span class="hljs-params">(黑)</span> -&gt;</span> B <span class="hljs-function"><span class="hljs-params">(灰)</span> -&gt;</span> C (白) <br>  ↓<br> D (白)<br></code></pre></td></tr></table></figure><p>为了解决这个问题，Go 使用了内存屏障技术，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，类似于一个钩子。垃圾收集器使用了写屏障（Write Barrier）技术，当对象新增或更新时，会将其着色为灰色。这样即使与用户程序并发执行，对象的引用发生改变时，垃圾收集器也能正确处理了。</p><p>一次完整的 GC 分为四个阶段：</p><ul><li><p>1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</p></li><li><p>2）使用三色标记法标记（Marking, 并发）</p></li><li><p>3）标记结束(Mark Termination，需 STW)，关闭写屏障。</p></li><li><p>4）清理(Sweeping, 并发)</p></li><li><p>参考 <a href="https://www.fullstack.cafe/golang">fullstack</a></p></li></ul>    </div></div><h3 id="函数返回局部变量的指针是否安全？">函数返回局部变量的指针是否安全？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上。</p>    </div></div><h3 id="非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？">非接口的任意类型 T() 都能够调用 <code>*T</code> 的方法吗？反过来呢？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <ul><li>一个T类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code>*T</code>声明的方法。</li><li>反过来，一个<code>*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</li></ul><p>哪些值是不可寻址的呢？</p><ul><li>字符串中的字节；</li><li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；</li><li>常量；</li><li>包级别的函数等。</li></ul><p>举一个例子，定义类型 T，并为类型 <code>*T</code> 声明一个方法 <code>hello()</code>，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span></span> hello() &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> t1 T = <span class="hljs-string">&quot;ABC&quot;</span><br>t1.hello() <span class="hljs-comment">// hello</span><br><span class="hljs-keyword">const</span> t2 T = <span class="hljs-string">&quot;ABC&quot;</span><br>t2.hello() <span class="hljs-comment">// error: cannot call pointer method on t</span><br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><h2 id="并发编程">并发编程</h2><h3 id="无缓冲的-channel-和有缓冲的-channel-的区别？">无缓冲的 channel 和有缓冲的 channel 的区别？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。</p><p>对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</p><p>例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>st := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>  &#123;<br>time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>&lt;-ch<br>&#125;()<br>ch &lt;- <span class="hljs-literal">true</span>  <span class="hljs-comment">// 无缓冲，发送方阻塞直到接收方接收到数据。</span><br>fmt.Printf(<span class="hljs-string">&quot;cost %.1f s\n&quot;</span>, time.Now().Sub(st).Seconds())<br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>st := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>  &#123;<br>time.Sleep(time.Second * <span class="hljs-number">2</span>)<br>&lt;-ch<br>&#125;()<br>ch &lt;- <span class="hljs-literal">true</span><br>ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// 缓冲区为 2，发送方不阻塞，继续往下执行</span><br>fmt.Printf(<span class="hljs-string">&quot;cost %.1f s\n&quot;</span>, time.Now().Sub(st).Seconds()) <span class="hljs-comment">// cost 0.0 s</span><br>ch &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行</span><br>fmt.Printf(<span class="hljs-string">&quot;cost %.1f s\n&quot;</span>, time.Now().Sub(st).Seconds()) <span class="hljs-comment">// cost 2.0 s</span><br>time.Sleep(time.Second * <span class="hljs-number">5</span>)<br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><h3 id="什么是协程泄露-Goroutine-Leak-？">什么是协程泄露(Goroutine Leak)？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：</p><ul><li>缺少接收器，导致发送阻塞</li></ul><p>这个例子中，每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞，不能退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">query</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; ch &lt;- <span class="hljs-number">0</span> &#125;()<br>&#125;<br><span class="hljs-keyword">return</span> &lt;-ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>query()<br>fmt.Printf(<span class="hljs-string">&quot;goroutines: %d\n&quot;</span>, runtime.NumGoroutine())<br>&#125;<br>&#125;<br><span class="hljs-comment">// goroutines: 1001</span><br><span class="hljs-comment">// goroutines: 2000</span><br><span class="hljs-comment">// goroutines: 2999</span><br><span class="hljs-comment">// goroutines: 3998</span><br></code></pre></td></tr></table></figure><ul><li>缺少发送器，导致接收阻塞</li></ul><p>那同样的，如果启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。</p><ul><li>死锁(dead lock)</li></ul><p>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。</p><ul><li>无限循环(infinite loops)</li></ul><p>这个例子中，为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(url <span class="hljs-type">string</span>, wg *sync.WaitGroup)</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> _, err := http.Get(url); err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// write to db</span><br><span class="hljs-keyword">break</span><br>&#125;<br>i++<br><span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> request(fmt.Sprintf(<span class="hljs-string">&quot;https://127.0.0.1:8080/%d&quot;</span>, i), &amp;wg)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><h3 id="Go-可以限制运行时操作系统线程的数量吗？">Go 可以限制运行时操作系统线程的数量吗？</h3><div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <blockquote><p>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.</p></blockquote><p>可以使用环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS(num int)</code> 设置，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">runtime</span>.GOMAXPROCS(<span class="hljs-number">1</span>) // 限制同时执行Go代码的操作系统线程数为 <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>从官方文档的解释可以看到，<code>GOMAXPROCS</code> 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。<code>GOMAXPROCS</code> 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I/O 密集型应用，适当地调大该值，可以提高 I/O 吞吐率。</p>    </div></div><h2 id="代码输出">代码输出</h2><p>下列代码的输出是</p><h3 id="变量与常量">变量与常量</h3><ol><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-string">&quot;golang&quot;</span>, <span class="hljs-number">100</span><br>d, e<br>f <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>g<br>)<br>fmt.Println(d, e, g)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>golang 100 true</p><p>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-string">&quot;golang&quot;</span>, <span class="hljs-number">100</span><br>d, e = <span class="hljs-string">&quot;golang&quot;</span>, <span class="hljs-number">100</span><br>f <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>g <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span><br>)<br>fmt.Println(d, e, g)<br>&#125;<br></code></pre></td></tr></table></figure>    </div></div><ol start="2"><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> N = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = N<br><br><span class="hljs-keyword">const</span> M <span class="hljs-type">int32</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">int</span> = M<br>fmt.Println(x, y)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>编译失败：cannot use M (type int32) as type int in assignment</p><p>Go 语言中，常量分为无类型常量和有类型常量两种，<code>const N = 100</code>，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，<code>var x int = N</code>。但是对于有类型的常量 <code>const M int32 = 100</code>，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> y <span class="hljs-built_in">int</span> = <span class="hljs-built_in">int</span>(M)<br></code></pre></td></tr></table></figure>    </div></div><ol start="3"><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br>fmt.Println(b)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>-128</p><p>int8 能表示的数字的范围是 [-2^7, 2^7-1]，即 [-128, 127]。-128 是无类型常量，转换为 int8，再除以变量 -1，结果为 128，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 -128。</p><p>对于有符号整型，最高位是是符号位，计算机用补码表示负数。补码 = 原码取反加一。</p><p>例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">-1 :  11111111<br>00000001(原码)    11111110(取反)    11111111(加一)<br>-128：    <br>10000000(原码)    01111111(取反)    10000000(加一)<br><br>-1 + 1 = 0<br>11111111 + 00000001 = 00000000(最高位溢出省略)<br>-128 + 127 = -1<br>10000000 + 01111111 = 11111111<br></code></pre></td></tr></table></figure>    </div></div><ol start="4"><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">-1</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int8</span> = <span class="hljs-number">-128</span> / a<br>fmt.Println(b)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>编译失败：constant 128 overflows int8</p><p>-128 和 a 都是常量，在编译时求值，-128 / a = 128，两个常量相除，结果也是一个常量，常量类型转换时不允许溢出，因而编译失败。</p>    </div></div><h3 id="作用域">作用域</h3><ol><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>err := fmt.Errorf(<span class="hljs-string">&quot;err&quot;</span>)<br>fmt.Println(<span class="hljs-number">1</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-number">2</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>1 err</p><p><code>:=</code> 表示声明并赋值，<code>=</code> 表示仅赋值。</p><p>变量的作用域是大括号，因此在第一个 if 语句 <code>if err == nil</code> 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 <code>if err != nil</code> 不成立。所以只打印了 <code>1 err</code>。</p>    </div></div><h3 id="defer-延迟调用">defer 延迟调用</h3><ol><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t T)</span></span> f(n <span class="hljs-type">int</span>) T &#123;<br>fmt.Print(n)<br><span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> t T<br><span class="hljs-keyword">defer</span> t.f(<span class="hljs-number">1</span>).f(<span class="hljs-number">2</span>)<br>fmt.Print(<span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>132</p><p>defer 延迟调用时，需要保存函数指针和参数，因此链式调用的情况下，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 <code>t.f(1)</code> 直接执行，然后执行 <code>fmt.Print(3)</code>，最后函数返回时再执行 <code>.f(2)</code>，因此输出是 132。</p>    </div></div><ol start="2"><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(n)<br>n += <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>1</p><p>打印 1 而不是 101。defer 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 defer 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果。</p>    </div></div><ol start="3"><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(n)<br>&#125;()<br>n += <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <p>101</p><p>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p>    </div></div><ol start="4"><li></li></ol>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n := <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(n)<br>n += <span class="hljs-number">100</span><br>&#125;<br>fmt.Println(n)<br>&#125;<br></code></pre></td></tr></table></figure>   <div class="spoiler collapsed">    <div class="spoiler-title">        答案    </div>    <div class="spoiler-content">        <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">101<br>1<br></code></pre></td></tr></table></figure><p>先打印 101，再打印 1。defer 的作用域是函数，而不是代码块，因此 if 语句退出时，defer 不会执行，而是等 101 打印后，整个函数返回时，才会执行。</p>    </div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EndNote教程</title>
    <link href="/2023/10/26/EndNote%E6%95%99%E7%A8%8B/"/>
    <url>/2023/10/26/EndNote%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>EndNote教程</h1><h2 id="如何引用">如何引用</h2><ol><li><p>在EndNote中导入文献，支持ris格式。</p></li><li><p>选择tools-&gt; output styles-&gt;style manager，选中想要的引用格式。没有可以选择web搜索，下载后放入EndNote的style文件夹中，然后再选中。</p><p><img src="/2023/10/26/EndNote%E6%95%99%E7%A8%8B/image-20231026113233304.png" alt="image-20231026113233304"></p></li><li><p>在word中可选择引用格式和引用按钮，或在EndNote中选择引用也是可以的。</p><p><img src="/2023/10/26/EndNote%E6%95%99%E7%A8%8B/image-20231026113616203.png" alt="image-20231026113616203"></p></li></ol><h2 id="EndNote导入bibtex格式">EndNote导入bibtex格式</h2><ol><li>用jabref打开bib文件，导出为endnote格式或者ris格式。</li><li>再用endnote导入就行。</li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EndNote</tag>
      
      <tag>论文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言简明教程</title>
    <link href="/2023/10/25/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <url>/2023/10/25/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>Go</h1><p><a href="https://geektutu.com/post/quick-golang.html">Go 语言简明教程 | 快速入门 | 极客兔兔 (geektutu.com)</a></p><h2 id="Go安装">Go安装</h2><p><a href="https://golang.org/dl/">官方下载</a>下载go并安装。</p><h3 id="vscode配置go环境">vscode配置go环境</h3><ol><li><p>配置系统环境，<code>GOPATH</code>是工作区的路径（用户变量和系统变量都配置），<code>GOROOT</code>是go的安装路径（仅配置系统变量）</p></li><li><p>将用户变量中的Path的<code>%USERPROFILE%\go\bin</code>，改成 <code>%GOPATH%\bin</code></p></li><li><p>在<code>GOPATH</code>对应目录下新建三个文件夹bin、pkg、src</p></li><li><p>下载vscode扩展</p><p><img src="/2023/10/25/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20231025170551590.png" alt="image-20231025170551590"></p></li><li><p>在cmd输入两条指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direc<br></code></pre></td></tr></table></figure></li><li><p>在vscode输入<code>ctrl+shift+P</code>，输入go，选中install/update tools，全部安装即可。</p></li><li><p>进入工作目录，在cmd执行命令，创建Go语言依赖管理库。可参考<a href="https://learn.microsoft.com/zh-cn/azure/developer/go/configure-visual-studio-code#6-run-the-debugger">第6步</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">go mod init [project name]<br></code></pre></td></tr></table></figure></li><li><p>之后可执行清洁库的命令来将当前的库源码文件所依赖的包，全部安装并记录下来，多的包就删掉，少了的就自动补上。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">go mod tidy<br></code></pre></td></tr></table></figure></li><li><p>注意，go语言的项目应位于<code>GOPATH</code>内，否则会出现下列错误。</p><p><img src="/2023/10/25/Go%E8%AF%AD%E8%A8%80%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/image-20231025171807679.png" alt="image-20231025171807679"></p></li></ol><p>参考：</p><p><a href="https://www.zhihu.com/tardis/zm/art/262984879?source_id=1005">vs code配置go开发环境 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_44286126/article/details/131706839">VScode下配置Go语言开发环境【2023最新】_vscode配置go语言开发环境_迈克柯里喵的博客-CSDN博客</a></p><h2 id="HelloWorld">HelloWorld</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>解释</p><blockquote><ul><li>package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。</li><li>import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。</li><li>func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 <code>main</code>。</li><li>fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!”</li></ul></blockquote><p>Go 字符串格式化符号:</p><table><thead><tr><th style="text-align:left">格  式</th><th style="text-align:left">描  述</th></tr></thead><tbody><tr><td style="text-align:left">%v</td><td style="text-align:left">按值的本来值输出</td></tr><tr><td style="text-align:left">%+v</td><td style="text-align:left">在 %v 基础上，对结构体字段名和值进行展开</td></tr><tr><td style="text-align:left">%#v</td><td style="text-align:left">输出 Go 语言语法格式的值</td></tr><tr><td style="text-align:left">%T</td><td style="text-align:left">输出 Go 语言语法格式的类型和值</td></tr><tr><td style="text-align:left">%%</td><td style="text-align:left">输出 % 本体</td></tr><tr><td style="text-align:left">%b</td><td style="text-align:left">整型以二进制方式显示</td></tr><tr><td style="text-align:left">%o</td><td style="text-align:left">整型以八进制方式显示</td></tr><tr><td style="text-align:left">%d</td><td style="text-align:left">整型以十进制方式显示</td></tr><tr><td style="text-align:left">%x</td><td style="text-align:left">整型以十六进制方式显示</td></tr><tr><td style="text-align:left">%X</td><td style="text-align:left">整型以十六进制、字母大写方式显示</td></tr><tr><td style="text-align:left">%U</td><td style="text-align:left">Unicode 字符</td></tr><tr><td style="text-align:left">%f</td><td style="text-align:left">浮点数</td></tr><tr><td style="text-align:left">%p</td><td style="text-align:left">指针，十六进制方式显示</td></tr></tbody></table><h2 id="变量和内置数据类型">变量和内置数据类型</h2><h3 id="变量">变量</h3><p><strong>go语言是静态类型。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> <span class="hljs-comment">// 如果没有赋值，默认为0</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 声明时赋值</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> <span class="hljs-comment">// 声明时赋值</span><br>a := <span class="hljs-number">1</span><br>msg := <span class="hljs-string">&quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="简单类型">简单类型</h3><ul><li>空值：nil</li><li>整形：int，int8，int16，uint8…</li><li>浮点数：float32，float64</li><li>字节：byte（等价于uint8）</li><li>字符串：string</li><li>布尔：boolean</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int8</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> c1 <span class="hljs-type">byte</span> = <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">float32</span> = <span class="hljs-number">12.2</span><br><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&quot;Hello World&quot;</span><br>ok := <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><p>Go语言使用UTF-8编码，不是ASCII。英文字符占1byte，中文占3byte。</p><p>使用<code>reflect.TypeOf().Kind() </code>可以知道字符串的类型是uint8，占一个byte，引用新的包需要在<code>import</code>中添加。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">str1 := <span class="hljs-string">&quot;Golang&quot;</span><br>str2 := <span class="hljs-string">&quot;Go语言&quot;</span><br>fmt.Println(reflect.TypeOf(str2[<span class="hljs-number">2</span>]).Kind()) <span class="hljs-comment">// uint8</span><br></code></pre></td></tr></table></figure><p>因此打印字符需要使用<code>string</code>类型转换，但由于中文UTF-8占3个字符，故<code>string</code>也无法正常显示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(str1[<span class="hljs-number">2</span>], <span class="hljs-type">string</span>(str1[<span class="hljs-number">2</span>]))       <span class="hljs-comment">// 108 l</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %c\n&quot;</span>, str2[<span class="hljs-number">2</span>], str2[<span class="hljs-number">2</span>])     <span class="hljs-comment">// 232 è</span><br>fmt.Println(<span class="hljs-string">&quot;len(str2)：&quot;</span>, <span class="hljs-built_in">len</span>(str2))       <span class="hljs-comment">// len(str2)： 8 Go占2byte，语言占6byte</span><br></code></pre></td></tr></table></figure><p>显示中文需要将字符串转化为<code>rune</code>数组，转换成 <code>[]rune</code> 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">str2 := <span class="hljs-string">&quot;Go语言&quot;</span><br>runeArr := []<span class="hljs-type">rune</span>(str2)<br>fmt.Println(reflect.TypeOf(runeArr[<span class="hljs-number">2</span>]).Kind()) <span class="hljs-comment">// int32</span><br>fmt.Println(runeArr[<span class="hljs-number">2</span>], <span class="hljs-type">string</span>(runeArr[<span class="hljs-number">2</span>]))    <span class="hljs-comment">// 35821 语</span><br>fmt.Println(<span class="hljs-string">&quot;len(runeArr)：&quot;</span>, <span class="hljs-built_in">len</span>(runeArr))    <span class="hljs-comment">// len(runeArr)： 4</span><br></code></pre></td></tr></table></figure><h4 id="类型转化">类型转化</h4><ul><li><p>字符串转数字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">pn, _ := strconv.Atoi(<span class="hljs-type">string</span>(rings[i+<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p>若是一位数字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">pole_index := rings[i + <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>数字转字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := strconv.Itoa(i)<br></code></pre></td></tr></table></figure><p>或者，注意是<code>%d</code>，不是<code>%s</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-type">int32</span>(<span class="hljs-number">111</span>))<br></code></pre></td></tr></table></figure></li></ul><h4 id="其他操作">其他操作</h4><p><a href="https://blog.csdn.net/qq_41542894/article/details/104089610">Go学习随笔（二）字符串的操作\遍历\索引\统计\替换\大小写转化\修改\插入\判断是否包含_go for _, val := range sl { fmt.printf(&quot;%s - &quot;, va-CSDN博客</a></p><h3 id="数组（array）与切片（slice）">数组（array）与切片（slice）</h3><ul><li><p>数组</p><p>声明数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>     <span class="hljs-comment">// 一维</span><br><span class="hljs-keyword">var</span> arr2 [<span class="hljs-number">5</span>][<span class="hljs-number">5</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 二维 </span><br></code></pre></td></tr></table></figure><p>声明初始化，若没有初始化，就是默认值，如整形就是0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-comment">// 或 arr := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="hljs-comment">// 或 arr := [...]int&#123;1,2,3,4,5&#125;</span><br></code></pre></td></tr></table></figure><p>索引[]，修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr); i++ &#123;<br>arr[i] += <span class="hljs-number">100</span><br>&#125;<br>fmt.Println(arr)  <span class="hljs-comment">// [101 102 103 104 105]</span><br></code></pre></td></tr></table></figure><p>声明并初始化一个2行6列的字符串数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> smap [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span> = [<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]<span class="hljs-type">string</span>&#123;<br>    &#123;<span class="hljs-string">&quot;&amp;quot;&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;&amp;apos;&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;&amp;amp;&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;&amp;gt;&quot;</span>, <span class="hljs-string">&quot;&gt;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;&amp;lt;&quot;</span>, <span class="hljs-string">&quot;&lt;&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;&amp;frasl;&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>切片</p><p>数组的长度不能改变，如果想拼接2个数组，或是获取子数组，需要使用切片。切片是数组的抽象。 切片使用数组作为底层结构。切片包含三个组件：容量，长度和指向底层数组的指针,切片可以随时进行扩展</p><p>声明切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">float32</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 长度为0的切片,不预留额外容量</span><br>slice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">float32</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// [0 0 0] 长度为3容量为5的切片</span><br>fmt.Println(<span class="hljs-built_in">len</span>(slice2), <span class="hljs-built_in">cap</span>(slice2)) <span class="hljs-comment">// 3 </span><br></code></pre></td></tr></table></figure><p>使用切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 添加元素，切片容量可以根据需要自动扩展</span><br>slice2 = <span class="hljs-built_in">append</span>(slice2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [0, 0, 0, 1, 2, 3, 4]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(slice2), <span class="hljs-built_in">cap</span>(slice2)) <span class="hljs-comment">// 7 12</span><br><span class="hljs-comment">// 子切片 [start, end)</span><br>sub1 := slice2[<span class="hljs-number">3</span>:] <span class="hljs-comment">// [1 2 3 4]</span><br>sub2 := slice2[:<span class="hljs-number">3</span>] <span class="hljs-comment">// [0 0 0]</span><br>sub3 := slice2[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">// [0 0 1]</span><br><span class="hljs-comment">// 合并切片</span><br>combined := <span class="hljs-built_in">append</span>(sub1, sub2...) <span class="hljs-comment">// [1, 2, 3, 4, 0, 0, 0]</span><br></code></pre></td></tr></table></figure><ul><li>切片的长度可变，不够时会自动扩展</li><li><code>sub2...</code>是切片解构，将切片解构为N个独立元素。</li></ul></li><li><p>创建动态二维数组（利用切片）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-number">2</span><br>m := <span class="hljs-number">3</span><br><span class="hljs-comment">//动态创建二维数组</span><br>grid := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>    grid[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">000</span><br><span class="hljs-comment">000</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="字典（map）">字典（map）</h3><p>ez</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 仅声明</span><br>m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-comment">// 声明时初始化</span><br>m2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;Sam&quot;</span>: <span class="hljs-string">&quot;Male&quot;</span>,<br><span class="hljs-string">&quot;Alice&quot;</span>: <span class="hljs-string">&quot;Female&quot;</span>,<br>&#125;<br><span class="hljs-comment">// 赋值/修改</span><br>m1[<span class="hljs-string">&quot;Tom&quot;</span>] = <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>需要注意map是无序的。详见：<a href="https://juejin.cn/post/7006197015319166990">【Golang】如何有序地遍历 Map - 掘金 (juejin.cn)</a></p><h3 id="集合（set）">集合（set）</h3><p>如何使用<code>map</code>表示集合，<code>struct&#123;&#125;</code>作用占位符，表示这里不需要一个值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>set := <span class="hljs-built_in">make</span>(Set)<br><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125; &#123;<br>set[item] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>fmt.Println(<span class="hljs-built_in">len</span>(set)) <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">if</span> _, ok := set[<span class="hljs-string">&quot;A&quot;</span>]; ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;A exists&quot;</span>) <span class="hljs-comment">// A exists</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="指针（pointer）">指针（pointer）</h3><p>与c++类似，指针即某个值的地址，类型定义时使用符号<code>*</code>，对一个已经存在的变量，使用 <code>&amp;</code> 获取该变量的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">str := <span class="hljs-string">&quot;Golang&quot;</span><br><span class="hljs-keyword">var</span> p *<span class="hljs-type">string</span> = &amp;str <span class="hljs-comment">// p 是指向 str 的指针</span><br>*p = <span class="hljs-string">&quot;Hello&quot;</span><br>fmt.Println(str) <span class="hljs-comment">// Hello 修改了 p，str 的值也发生了改变</span><br></code></pre></td></tr></table></figure><p>一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。</p><h2 id="流程控制（for-if-switch）">流程控制（for if switch）</h2><h3 id="条件if-else">条件if else</h3><p><code>&#125;else&#123;</code>得在同一行，不能换行写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">age := <span class="hljs-number">18</span><br><span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">18</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Kid&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Adult&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 可以简写为：</span><br><span class="hljs-keyword">if</span> age := <span class="hljs-number">18</span>; age &lt; <span class="hljs-number">18</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Kid&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Adult&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch">switch</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Gender <span class="hljs-type">int8</span><br><span class="hljs-keyword">const</span> (<br>MALE   Gender = <span class="hljs-number">1</span><br>FEMALE Gender = <span class="hljs-number">2</span><br>)<br><br>gender := MALE<br><br><span class="hljs-keyword">switch</span> gender &#123;<br><span class="hljs-keyword">case</span> FEMALE:<br>fmt.Println(<span class="hljs-string">&quot;female&quot;</span>)<br><span class="hljs-keyword">case</span> MALE:<br>fmt.Println(<span class="hljs-string">&quot;male&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br><span class="hljs-comment">// male</span><br></code></pre></td></tr></table></figure><ul><li><p>在这里，使用了<code>type</code> 关键字定义了一个新的类型 Gender。</p></li><li><p>使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举(enum)的概念，一般可以用常量的方式来模拟枚举。</p></li><li><p>和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> gender &#123;<br><span class="hljs-keyword">case</span> FEMALE:<br>fmt.Println(<span class="hljs-string">&quot;female&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> MALE:<br>fmt.Println(<span class="hljs-string">&quot;male&quot;</span>)<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unknown&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// male</span><br><span class="hljs-comment">// unknown</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="for-循环">for 循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">if</span> sum &gt; <span class="hljs-number">50</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>sum += i<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="range遍历">range遍历</h3><ol><li><p>array/slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">words := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;语言&quot;</span>, <span class="hljs-string">&quot;高性能&quot;</span>, <span class="hljs-string">&quot;编程&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> words &#123;<br>    words = <span class="hljs-built_in">append</span>(words, <span class="hljs-string">&quot;test&quot;</span>)<br>    fmt.Println(i, s)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">0 Go<br>1 语言<br>2 高性能<br>3 编程<br></code></pre></td></tr></table></figure><ul><li>变量 words 在循环开始前，仅会计算一次，如果在循环中修改切片的长度不会改变本次循环的次数。</li><li>迭代过程中，每次迭代的下标和值被赋值给变量 i 和 s，第二个参数 s 是可选的。</li><li>针对 nil 切片，迭代次数为 0。</li></ul><p>range 还有另一种只遍历下标的写法，这种写法与 for 几乎没什么差异了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> words &#123;<br>fmt.Println(i, words[i])<br>&#125;<br></code></pre></td></tr></table></figure><p>输出也是一样的。</p><p>若遍历时只关心值，而不关心索引可以这样遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> m2 &#123;<br>fmt.Println(value)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-string">&quot;one&quot;</span>:   <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;two&quot;</span>:   <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    <span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;two&quot;</span>)<br>    m[<span class="hljs-string">&quot;four&quot;</span>] = <span class="hljs-number">4</span><br>    fmt.Printf(<span class="hljs-string">&quot;%v: %v\n&quot;</span>, k, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">one: 1<br>four: 4<br>three: 3<br></code></pre></td></tr></table></figure><ul><li>和切片不同的是，迭代过程中，删除还未迭代到的键值对，则该键值对不会被迭代。</li><li>在迭代过程中，如果创建新的键值对，那么新增键值对，可能被迭代，也可能不会被迭代。</li><li>针对 nil 字典，迭代次数为 0</li></ul></li><li><p>channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    ch &lt;- <span class="hljs-string">&quot;Go&quot;</span><br>    ch &lt;- <span class="hljs-string">&quot;语言&quot;</span><br>    ch &lt;- <span class="hljs-string">&quot;高性能&quot;</span><br>    ch &lt;- <span class="hljs-string">&quot;编程&quot;</span><br>    <span class="hljs-built_in">close</span>(ch)<br>&#125;()<br><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> ch &#123;<br>    fmt.Println(n)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>发送给信道(channel) 的值可以使用 for 循环迭代，直到信道被关闭。</li><li>如果是 nil 信道，循环将永远阻塞。</li></ul></li></ol><h2 id="函数">函数</h2><h3 id="参数与返回值">参数与返回值</h3><p>一个典型的函数定义如下，使用关键字 <code>func</code>，参数可以有多个，返回值也支持有多个。特别地，<code>package main</code> 中的<code>func main()</code> 约定为可执行程序的入口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(param1 Type1, param2 Type2, ...)</span></span> (return1 Type3, ...) &#123;<br>    <span class="hljs-comment">// body</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-type">int</span>, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(num1 <span class="hljs-type">int</span>, num2 <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">return</span> num1 / num2, num1 % num2<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>quo, rem := div(<span class="hljs-number">100</span>, <span class="hljs-number">17</span>)<br>fmt.Println(quo, rem)     <span class="hljs-comment">// 5 15</span><br>fmt.Println(add(<span class="hljs-number">100</span>, <span class="hljs-number">17</span>)) <span class="hljs-comment">// 117</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以给返回值命名，简化 return，例如 add 函数可以改写为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-type">int</span>, num2 <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>ans = num1 + num2<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="错误处理">错误处理</h3><p>如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数<code>os.Open</code>读取文件，<code>os.Open</code> 有2个返回值，第一个是 <code>*File</code>，第二个是 <code>error</code>， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_, err := os.Open(<span class="hljs-string">&quot;filename.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// open filename.txt: no such file or directory</span><br></code></pre></td></tr></table></figure><p>可以通过 <code>errorw.New</code> 返回<strong>自定义的错误</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;error: name is null&quot;</span>)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Hello,&quot;</span>, name)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := hello(<span class="hljs-string">&quot;&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;<br><span class="hljs-comment">// error: name is null</span><br></code></pre></td></tr></table></figure><p>error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。</p><p>在 Python、Java 等语言中有 <code>try...catch</code> 机制，在 <code>try</code> 中捕获各种类型的异常，在 <code>catch</code> 中定义异常处理的行为。Go 语言也提供了类似的机制 <code>defer</code> 和 <code>recover</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(index <span class="hljs-type">int</span>)</span></span> (ret <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Some error happened!&quot;</span>, r)<br>ret = <span class="hljs-number">-1</span><br>&#125;<br>&#125;()<br>arr := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">return</span> arr[index]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(get(<span class="hljs-number">5</span>))<br>fmt.Println(<span class="hljs-string">&quot;finished&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。</li><li>在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。</li></ul><h3 id="传值与传引用">传值与传引用</h3><blockquote><p>兄弟们实锤了奥，go就是值传递，可以确认的是Go语言中所有的传参都是值传递（传值），都是一个副本，一个拷贝。因为拷贝的内容有时候是非引用类型（int、string、struct等这些），这样就在函数中就无法修改原内容数据；有的是引用类型（指针、map、slice、chan等这些），这样就可以修改原内容数据。</p></blockquote><p><a href="https://blog.csdn.net/qq_39397165/article/details/109561839">go语言参数传递到底是传值还是传引用_go run 传入参数-CSDN博客</a></p><h2 id="结构体，方法和接口">结构体，方法和接口</h2><h3 id="结构体和方法">结构体和方法</h3><p>结构体类似于其他语言中的 class，可以在结构体中定义多个字段，为结构体实现方法，实例化等。接下来我们定义一个结构体 Student，并为 Student 添加 name，age 字段，并实现 <code>hello()</code> 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> hello(person <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;hello %s, I am %s&quot;</span>, person, stu.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu := &amp;Student&#123;<br>name: <span class="hljs-string">&quot;Tom&quot;</span>,<br>&#125;<br>msg := stu.hello(<span class="hljs-string">&quot;Jack&quot;</span>)<br>fmt.Println(msg) <span class="hljs-comment">// hello Jack, I am Tom</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>Student&#123;field: value, ...&#125;</code>的形式创建 Student 的实例，字段不需要每个都赋值，没有显性赋值的变量将被赋予默认值，例如 age 将被赋予默认值 0。</li><li>实现方法与实现函数的区别在于，<code>func</code> 和函数名<code>hello</code> 之间，加上该方法对应的实例名 <code>stu</code> 及其类型 <code>*Student</code>，可以通过实例名访问该实例的字段<code>name</code>和其他方法了。</li><li>调用方法通过 <code>实例名.方法名(参数)</code> 的方式。</li><li>这里使用了<code>fmt.Sprintf</code>来构造想要的字符串。</li></ul><p>除此之外，还可以使用 <code>new</code> 实例化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu2 := <span class="hljs-built_in">new</span>(Student)<br>fmt.Println(stu2.hello(<span class="hljs-string">&quot;Alice&quot;</span>)) <span class="hljs-comment">// hello Alice, I am  , name 被赋予默认值&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体与tag">结构体与tag</h3><p>struct字段上还可以额外再加一个属性，用反引号（Esc键下面的那个键）包含的字符串，称之为 Tag，也就是标签。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>    Age  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;age&quot;`</span><br>    Addr <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;addr,omitempty&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可用于美化输出和json序列化。</p><p>详见<a href="https://zhuanlan.zhihu.com/p/258978922">26. Go 语言中结构体的 Tag 用法 - 知乎 (zhihu.com)</a></p><h3 id="接口（interfaces）">接口（interfaces）</h3><p>一般而言，接口定义了一组方法的集合，接口不能被实例化，一个类型可以实现多个接口。</p><p>举一个简单的例子，定义一个接口 <code>Person</code>和对应的方法 <code>getName()</code> 和 <code>getAge()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>getName() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stu *Student)</span></span> getName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> stu.name<br>&#125;<br><br><span class="hljs-keyword">type</span> Worker <span class="hljs-keyword">struct</span> &#123;<br>name   <span class="hljs-type">string</span><br>gender <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *Worker)</span></span> getName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> w.name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> p Person = &amp;Student&#123;<br>name: <span class="hljs-string">&quot;Tom&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br><br>fmt.Println(p.getName()) <span class="hljs-comment">// Tom</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Go 语言中，并不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。</li><li>实例化 <code>Student</code>后，强制类型转换为接口类型 Person。</li></ul><p>在上面的例子中，我们在 main 函数中尝试将 Student 实例类型转换为 Person，如果 Student 没有完全实现 Person 的方法，比如我们将 <code>(*Student).getName()</code> 删掉，编译时会出现如下报错信息。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">*Student does <span class="hljs-keyword">not</span> implement Person (missing getName <span class="hljs-keyword">method</span>)<br></code></pre></td></tr></table></figure><p>但是删除 <code>(*Worker).getName()</code> 程序并不会报错，因为我们并没有在 main 函数中使用。这种情况下我们如何确保某个类型实现了某个接口的所有方法呢？一般可以使用下面的方法进行检测，如果实现不完整，编译期将会报错。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ Person = (*Student)(<span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">var</span> _ Person = (*Worker)(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><ul><li>将空值 nil 转换为 *Student 类型，再转换为 Person 接口，如果转换失败，说明 Student 并没有实现 Person 接口的所有方法。</li><li>Worker 同上。</li></ul><p>实例可以强制类型转换为接口，接口也可以强制类型转换为实例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> p Person = &amp;Student&#123;<br>name: <span class="hljs-string">&quot;Tom&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br><br>stu := p.(*Student) <span class="hljs-comment">// 接口转为实例</span><br>fmt.Println(stu.getAge())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空接口">空接口</h3><p>如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>m[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;Tom&quot;</span><br>m[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span><br>m[<span class="hljs-string">&quot;scores&quot;</span>] = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">98</span>, <span class="hljs-number">99</span>, <span class="hljs-number">85</span>&#125;<br>fmt.Println(m) <span class="hljs-comment">// map[age:18 name:Tom scores:[98 99 85]]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发编程-goroutine">并发编程(goroutine)</h2><h3 id="sync">sync</h3><p>Go 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。</p><p>例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;start to download&quot;</span>, url)<br>time.Sleep(time.Second) <span class="hljs-comment">// 模拟耗时操作</span><br>wg.Done()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> download(<span class="hljs-string">&quot;a.com/&quot;</span> + <span class="hljs-type">string</span>(i+<span class="hljs-string">&#x27;0&#x27;</span>))<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。</li><li>go download()：启动新的协程并发执行 download 函数。</li><li>wg.Wait()：等待所有的协程执行结束。</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">$  time go run .<br>start to download a.com/2<br>start to download a.com/0<br>start to download a.com/1<br>Done!<br><br>real    0m1.563s<br></code></pre></td></tr></table></figure><p>可以看到串行需要 3s 的下载操作，并发后，只需要 1s。</p><h3 id="channel">channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 创建大小为 10 的缓冲信道</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;start to download&quot;</span>, url)<br>time.Sleep(time.Second)<br>ch &lt;- url <span class="hljs-comment">// 将 url 发送给信道</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br><span class="hljs-keyword">go</span> download(<span class="hljs-string">&quot;a.com/&quot;</span> + <span class="hljs-type">string</span>(i+<span class="hljs-string">&#x27;0&#x27;</span>))<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>msg := &lt;-ch <span class="hljs-comment">// 等待信道返回消息。</span><br>fmt.Println(<span class="hljs-string">&quot;finish&quot;</span>, msg)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 channel 信道，可以在协程之间<strong>传递消息</strong>。阻塞等待并发协程返回消息。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ <span class="hljs-built_in">time</span> go run .<br><span class="hljs-built_in">start</span> <span class="hljs-built_in">to</span> download <span class="hljs-keyword">a</span>.com/<span class="hljs-number">2</span><br><span class="hljs-built_in">start</span> <span class="hljs-built_in">to</span> download <span class="hljs-keyword">a</span>.com/<span class="hljs-number">0</span><br><span class="hljs-built_in">start</span> <span class="hljs-built_in">to</span> download <span class="hljs-keyword">a</span>.com/<span class="hljs-number">1</span><br>finish <span class="hljs-keyword">a</span>.com/<span class="hljs-number">2</span><br>finish <span class="hljs-keyword">a</span>.com/<span class="hljs-number">1</span><br>finish <span class="hljs-keyword">a</span>.com/<span class="hljs-number">0</span><br>Done!<br><br>real    <span class="hljs-number">0</span>m1<span class="hljs-number">.528</span>s<br></code></pre></td></tr></table></figure><h2 id="单元测试-unit-test）">单元测试(unit test）</h2><p>假设我们希望测试 package main 下 <code>calc.go</code> 中的函数，要只需要新建 <code>calc_test.go</code> 文件，在<code>calc_test.go</code>中新建测试用例即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// calc.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-type">int</span>, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-comment">// calc_test.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAdd</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> ans := add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); ans != <span class="hljs-number">3</span> &#123;<br>t.Error(<span class="hljs-string">&quot;add(1, 2) should be equal to 3&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>go test</code>，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加<code>-v</code>参数。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">$ go test -v<br><span class="hljs-section">=== RUN   TestAdd</span><br><span class="hljs-bullet">--- </span>PASS: TestAdd (0.00s)<br>PASS<br>ok      example 0.040s<br></code></pre></td></tr></table></figure><h2 id="包-Package-和模块-Modules）">包(Package)和模块(Modules）</h2><h3 id="Package">Package</h3><p>一般来说，<strong>一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到</strong>。</p><p>比如我们新建一个文件 <code>calc.go</code>， <code>main.go</code> 平级，分别定义 add 和 main 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// calc.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-type">int</span>, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-comment">// main.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)) <span class="hljs-comment">// 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>go run main.go</code>，会报错，add 未定义：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">./<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.go</span>:<span class="hljs-number">6</span>:<span class="hljs-number">14</span>: undefined: add<br></code></pre></td></tr></table></figure><p>因为 <code>go run main.go</code> 仅编译 main.go 一个文件，所以命令需要换成</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run main.go calc.go<br>8<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ go run .<br>8<br></code></pre></td></tr></table></figure><p>Go 语言也有 Public 和 Private 的概念，粒度是包。<strong>如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。</strong></p><h3 id="Modules">Modules</h3><p><a href="https://github.com/golang/go/wiki/Modules">Go Modules</a> 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。接下来简单介绍 <code>go mod</code> 的使用。Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。</p><p>在一个空文件夹下，初始化一个 Module</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ <span class="hljs-built_in">go</span> <span class="hljs-built_in">mod</span> init <span class="hljs-built_in">example</span><br><span class="hljs-built_in">go</span>: creating <span class="hljs-built_in">new</span> <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span>: module <span class="hljs-built_in">example</span><br></code></pre></td></tr></table></figure><p>此时，在当前文件夹下生成了<code>go.mod</code>，这个文件记录当前模块的模块名以及所有依赖包的版本。</p><p>接着，我们在当前目录下新建文件 <code>main.go</code>，添加如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;rsc.io/quote&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(quote.Hello())  <span class="hljs-comment">// Ahoy, world!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行 <code>go run .</code>，将会自动触发第三方包 <code>rsc.io/quote</code>的下载，具体的版本信息也记录在了<code>go.mod</code>中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">module</span> example<br><br><span class="hljs-attribute">go</span> <span class="hljs-number">1</span>.<span class="hljs-number">13</span><br><br><span class="hljs-attribute">require</span> rsc.io/quote v3.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>+incompatible<br></code></pre></td></tr></table></figure><p>我们在当前目录，添加一个子 package calc，代码目录如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">demo/<br>   <span class="hljs-string">|--calc/</span><br>      <span class="hljs-string">|--calc.go</span><br>   <span class="hljs-string">|--main.go</span><br></code></pre></td></tr></table></figure><p>在 <code>calc.go</code> 中写入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> calc<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(num1 <span class="hljs-type">int</span>, num2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br></code></pre></td></tr></table></figure><p>在 package main 中如何使用 package cal 中的 Add 函数呢？<code>import 模块名/子目录名</code> 即可，修改后的 main 函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;example/calc&quot;</span><br><br><span class="hljs-string">&quot;rsc.io/quote&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(quote.Hello())<br>fmt.Println(calc.Add(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>))<br>&#125;<br>$ <span class="hljs-keyword">go</span> run .<br>Ahoy, world!<br><span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><h2 id="附-参考">附 参考</h2><ul><li><a href="https://golang.org/">golang 官方文档 - golang.org</a></li><li><a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">goproxy.cn 文档 - github.com</a></li><li><a href="https://github.com/golang/go/wiki/Modules">Go Modules - github.com</a></li></ul><h2 id="常见库">常见库</h2><h3 id="sort">sort</h3><h4 id="排序整数、浮点数和字符串切片">排序整数、浮点数和字符串切片</h4><p>对于 []int, []float, []string 这种元素类型是基础类型的切片使用 sort 包提供的下面几个函数进行排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Ints<br>sort.Floats<br>sort.Strings<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;<br>sort.Ints(s)<br>fmt.Println(s) <span class="hljs-comment">// 输出[1 2 3 4]</span><br></code></pre></td></tr></table></figure><h4 id="二维数组的简易排序">二维数组的简易排序</h4><p>sort.Slice方法有两个参数：待排序的二维数组，以及类似上述Less方法的方法（比较器）。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//定义二维数组</span><br><br><span class="hljs-keyword">var</span> intervals = [][]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;&#125;<br><br><span class="hljs-comment">//对该数组以每行第一个元素升序排列的顺序进行排序</span><br><br>sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><br>　　<span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="二分查找">二分查找</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">index := sort.Search(n <span class="hljs-type">int</span>,f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>) <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><ul><li><p>主要功能</p><p>该函数使用二分查找的方法，会从[0, n)中取出一个值index，index为[0, n)中最小的使函数f(index)为True的值，并且f(index+1)也为True。<br>如果无法找到该index值，则该方法为返回n。</p></li></ul><h3 id="堆heap">堆heap</h3><p><a href="https://zhuanlan.zhihu.com/p/373074591">Go基础：heap的介绍与使用 - 知乎 (zhihu.com)</a></p><p>例题：</p><p><a href="/2023/12/08/leetcode23-12/#1631-最小体力消耗路径">1631. 最小体力消耗路径</a></p><p>比较优美的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span>&#123; x, y, maxDiff <span class="hljs-type">int</span> &#125;<br><span class="hljs-keyword">type</span> hp []point<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Len() <span class="hljs-type">int</span>              &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span>    &#123; <span class="hljs-keyword">return</span> h[i].maxDiff &lt; h[j].maxDiff &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h hp)</span></span> Swap(i, j <span class="hljs-type">int</span>)         &#123; h[i], h[j] = h[j], h[i] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;)   &#123; *h = <span class="hljs-built_in">append</span>(*h, v.(point)) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hp)</span></span> Pop() (v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; a := *h; *h, v = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>], a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]; <span class="hljs-keyword">return</span> &#125;<br></code></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路由标识项目学习记录</title>
    <link href="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1>路由标识</h1><h2 id="docker">docker</h2><h3 id="dockerfile">dockerfile</h3><ul><li><p>build</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker build -t authserver_ubuntu:v3 .<br></code></pre></td></tr></table></figure></li><li><p>run，<code>--network=host</code>是联网功能。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="language-bash"> -it --network=host authserver_ubuntu:v3</span><br></code></pre></td></tr></table></figure></li><li><p>第一次尝试编写的dockerfile，重点在于下载libmysqlclient的库，运行时需要加&amp;，让程序后台运行，才能build成功。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><span class="hljs-keyword">MAINTAINER</span> hey &lt;<span class="hljs-number">3261575578</span>@qq.com&gt;<br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i s@/security.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i s@/snapshot.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install g++ -y</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install libmysqlclient-dev -y</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /AuthServer</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . /AuthServer</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /AuthServer</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> /usr/bin/g++ -g main.cpp -o main -lpthread -I /AuthServer/include /AuthServer/res/*.cpp `mysql_config --cflags --libs`</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> ./main &amp;</span><br></code></pre></td></tr></table></figure></li><li><p>dockerfile的编写可以去run你的基础映像，在里面尝试将代码编译好，然后同样步骤写到dockerfile中，但需要注意build有时无法联网的问题，本人通过修改dns得到解决。下面网站提到可根据docker版本同样添加<code>--network=host</code>，未来可尝试一下。</p><p><a href="http://www.debugself.com/2018/01/17/docker_network/">docker build以及docker run时使用host网络的方法 | 源码先生的调试人生 (debugself.com)</a></p><ul><li><p>DNS有问题</p><p><strong>能ping通ip地址但不能ping通域名</strong></p><p>编辑<code>/etc/docker/daemon.json</code>文件，添加dns信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;dns&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;114.114.114.114&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="基于已有容器创建新镜像">基于已有容器创建新镜像</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">exec</span> -it -net=tap &lt;<span class="hljs-keyword">container</span>&gt; <br></code></pre></td></tr></table></figure><h2 id="debian">debian</h2><h3 id="在gns3添加debian终端">在gns3添加debian终端</h3><ol><li><p><a href="https://gns3.com/marketplace/appliances%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F(.qcow2)%E5%92%8C%E5%BC%95%E5%AF%BC%E6%96%87%E4%BB%B6(.gns3a)">https://gns3.com/marketplace/appliances下载镜像(.qcow2)和引导文件(.gns3a)</a></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231207191205122.png" alt="image-20231207191205122"></p></li></ol><h3 id="扩容">扩容</h3><ol><li><p>确保路由器接入公网，即与NAT相连。</p></li><li><p>右键路由器-&gt;configure-&gt;HDD-&gt;Resize，注意resize直接是increase</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231018170506585.png" alt="image-20231018170506585"></p></li><li><p>参考以下网站解决。</p><p><a href="https://www.cnblogs.com/jrri/p/16591351.html">Debian Linux磁盘扩容 - Jrri - 博客园 (cnblogs.com)</a></p></li><li><p>install时出错：unable to parse xxx可参考以下网站解决。</p><p>[<a href="https://itsfoss.com/unable-to-parse-package-file/">Solved] Unable to parse package file /var/lib/apt/lists (itsfoss.com)</a></p></li><li><p>简单可采用以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo -s<br>fdisk -l 查看文件系统在哪 或 <span class="hljs-built_in">df</span> -h 扩容主体 <br>apt install cloud-guest-utils 或 dpkg -i xxx.deb<br>growpart /dev/vda 3<br>resize2fs /dev/vda3<br><span class="hljs-built_in">df</span> -h 再次检查<br></code></pre></td></tr></table></figure></li></ol><h3 id="配置静态路由">配置静态路由</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">up ip route add 192.168.2.0/24 via 192.168.0.2<br></code></pre></td></tr></table></figure><h3 id="配置ip和默认网关">配置ip和默认网关</h3><ol><li><p>执行下面指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo -s<br>vim /etc/network/interfaces<br><span class="hljs-comment"># 注释掉 &quot;source-directory /run/network/interfaces.d&quot; 这一行</span><br><span class="hljs-built_in">rm</span> /etc/network/interfaces.d/50-cloud-init<br><span class="hljs-comment"># 创建 &quot;/etc/network/interfaces.d/10-ens4&quot;</span><br>vim /etc/network/interfaces.d/10-ens4<br></code></pre></td></tr></table></figure></li><li><p>添加内容,保存并退出编辑器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">auto ens4<br>iface ens4 inet6 static<br>        address 2023:10::1/64<br>        gateway 2023:10::11 <span class="hljs-comment">#注意此处不能有/64，否则sudo systemctl restart networking会失败</span><br>iface ens4 inet static<br>        address 10.10.10.11/24<br>up ip route add 10.10.0.0/16 via 10.10.10.21<br></code></pre></td></tr></table></figure></li><li><p>重新启动网络服务使更改生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart networking<br></code></pre></td></tr></table></figure></li><li><p>查看是否生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip addr<br></code></pre></td></tr></table></figure></li></ol><h3 id="增加网络接口">增加网络接口</h3><ol><li><p>首先增加网络适配器接口数量，右键config——adapter设置为2，用cloud/NAT（GNS3 VM）连接</p></li><li><p>编辑/etc/network/interfaces</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/network/interfaces<br></code></pre></td></tr></table></figure><p>添加内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">auto ens5<br>iface ens5 inet dhcp<br></code></pre></td></tr></table></figure></li><li><p>重新启动网络服务使更改生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart networking<br></code></pre></td></tr></table></figure></li></ol><p>增加网络接口需注意默认网关是如何设置的，本项目中采取默认网关设为外网接口，配置静态路由将内网ip汇聚到内网接口上。</p><h2 id="sonic">sonic</h2><p>其实就是有sonic功能的debian，通过以下命令可以查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> /etc/issue<br></code></pre></td></tr></table></figure><h3 id="isisd开机自启动">isisd开机自启动</h3><h4 id="系统脚本">系统脚本</h4><ol><li><p>创建脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim docker_isisd.sh<br></code></pre></td></tr></table></figure><p>脚本内容如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; start_isisd.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Docker ISISD Service</span><br><span class="hljs-string">After=docker.service</span><br><span class="hljs-string">Requires=docker.service</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">ExecStart=/usr/bin/docker exec -i bgp /bin/bash -c &quot;/usr/lib/frr/isisd -A 127.0.0.1 -d&quot;</span><br><span class="hljs-string">Restart=always</span><br><span class="hljs-string">RestartSec=5</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br>sudo <span class="hljs-built_in">mv</span> start_isisd.service /etc/systemd/system/<br>sudo systemctl daemon-reload<br>sudo systemctl <span class="hljs-built_in">enable</span> start_isisd.service<br><br></code></pre></td></tr></table></figure><blockquote><p>here文档</p><p>如果你需要输入多行文本，可以使用Here文档（Here Document）来实现。Here文档允许你在脚本中直接定义多行文本，并将其写入文件。</p><p>下面是一个示例脚本，演示如何新建一个文件并输入多行文本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">复制代码<span class="hljs-comment">#!/bin/bash</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 创建一个新文件并输入多行文本</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; myfile.txt</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-string">Hello, World!</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-string">This is line 2.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-string">And this is line 3.</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-string">EOF</span></span><br></code></pre></td></tr></table></figure><p>在上面的示例中，使用了<code>cat</code>命令和Here文档的语法。<code>&lt;&lt; EOF</code>表示开始定义Here文档，<code>EOF</code>表示结束Here文档。在这之间的内容就是要输入的多行文本。这里定义了三行文本，并将其写入到名为<code>myfile.txt</code>的文件中。</p><p>如果脚本执行成功，将会在当前目录下创建一个新的文件<code>myfile.txt</code>，其中包含三行文本。</p><p>请注意，Here文档中的EOF可以是任意标识符，只需保证开始和结束的标识符一致即可。</p></blockquote></li><li><p>增加权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> +x docker_isisd.sh<br></code></pre></td></tr></table></figure></li><li><p>执行脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./docker_isisd.sh<br></code></pre></td></tr></table></figure></li></ol><h4 id="修改bgp容器启动设置">修改bgp容器启动设置</h4><ol><li><p>进入bgp容器，进入<code>/usr/share/sonic/templates/supervisord/</code>目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker <span class="hljs-built_in">exec</span> -it bgp /bash/bin<br><span class="hljs-built_in">cd</span> /usr/share/sonic/templates/supervisord/<br></code></pre></td></tr></table></figure></li><li><p>修改<code>supervisor.conf.j2</code>文件</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241126103233938.png" alt="image-20241126103233938"></p></li><li><p>修改<code>critical_processes.j2</code>文件</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241126103253488.png" alt="image-20241126103253488"></p></li></ol><h3 id="配置ip">配置ip</h3><p>指令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config interface ip add Ethernet0 2023:10::11/64<br>sudo config interface ip add Ethernet4 2023:11::11/64<br>sudo config interface startup Ethernet0<br>sudo config interface startup Ethernet4<br>show ipv6 interface<br>sudo config save<br></code></pre></td></tr></table></figure><h3 id="配置路由">配置路由</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config route add prefix 2.2.3.4/32 nexthop 30.0.0.9<br></code></pre></td></tr></table></figure><h3 id="配置isis">配置isis</h3><p>指令如下，注意在GNS3里，sonic-vs内部接口编号对应GNS3拓扑里接口编号×4。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo docker <span class="hljs-built_in">exec</span> -it bgp /bin/bash<br>/usr/lib/frr/isisd -A 127.0.0.1 -d <span class="hljs-comment"># 在bgp容器中启动ISIS</span><br>vtysh进入配置界面<br><span class="hljs-comment"># 配置isis域和所有需要配isis协议的接口</span><br>configure<br>ro isis sonic <span class="hljs-comment"># 这里的 sonic 可以修改，但要与后面的 interface 中的配置保持一</span><br>致。不同路由器可以使用相同的命名<br>net 49.0001.1111.1111.1111.00 <span class="hljs-comment"># 这里设置路由器的 NSAP 地址，可以设置为 49.0001.xxxx.xxxx.xxxx.00</span><br>end<br>configure<br>interface Ethernet0<br>ipv6 ro isis sonic <span class="hljs-comment"># ipv4 对应的命令为 ip ro isis sonic</span><br>end<br>configure<br>interface Ethernet4<br>ipv6 ro isis sonic <span class="hljs-comment"># ipv4 对应的命令为 ip ro isis sonic</span><br>end<br>write<br></code></pre></td></tr></table></figure><h3 id="配置ospf">配置ospf</h3><ol><li><p>启动ospfd</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/bin/docker <span class="hljs-built_in">exec</span> -i bgp /bin/bash -c <span class="hljs-string">&quot;/usr/lib/frr/ospfd -A 127.0.0.1 -d&quot;</span><br></code></pre></td></tr></table></figure><p>若想同时启动isisd和ospfd</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/bin/docker <span class="hljs-built_in">exec</span> -i bgp /bin/bash -c <span class="hljs-string">&quot;/usr/lib/frr/isisd -A 127.0.0.1 -d</span><br><span class="hljs-string">/usr/lib/frr/ospfd -A 127.0.0.1 -d&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置ospf</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">vtysh<br>config<br>ro ospf<br>net 10.2.3.3/24 area 0 <span class="hljs-comment"># 在10.2.3.3端口上开启ospf，区域号为0</span><br>end<br>write<br></code></pre></td></tr></table></figure></li></ol><h3 id="重启lldp">重启lldp</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart lldp<br></code></pre></td></tr></table></figure><h3 id="配置自动登出时间">配置自动登出时间</h3><ol><li><p>TMOUT已存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo -s<br>grep -q TMOUT=3600 /etc/profile  || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;TMOUT=3600&quot;</span> &gt;&gt; /etc/profile<br>sed -i <span class="hljs-string">&#x27;s/^TMOUT=.*/TMOUT=3600/g&#x27;</span> /etc/profile<br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>TMOUT不存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo -s<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;TMOUT=432000&quot;</span> &gt;&gt; /etc/profile<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export TMOUT&quot;</span> &gt;&gt; /etc/profile<br><span class="hljs-built_in">exit</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure></li></ol><h3 id="自动化配置ip，isis">自动化配置ip，isis</h3><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231023135106710.png" alt="image-20231023135106710"></p><ul><li><p>利用sed -i命令去编辑interfaces文件</p><p>注释</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;s/source-directory \/run/# source-directory \/run/g&#x27;</span> /etc/network/interfaces<br></code></pre></td></tr></table></figure><p>添加内容，在第8行后添加</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i -e <span class="hljs-string">&#x27;8a </span><br><span class="hljs-string">auto ens5</span><br><span class="hljs-string">iface ens5 inet dhcp&#x27;</span> /etc/network/interfaces<br></code></pre></td></tr></table></figure></li><li><p>脚本文件中使用sudo -s会中断脚本，故直接sudo 命令比较好。</p></li><li><p>sudo cat &lt;&lt; EOF &gt; 10-ens4无法在权限文件夹创建10-ens4，故需要修改上级目录的权限</p></li><li><p>vtysh无法通过echo -e “xxx” | vtysh和here文档来交互，但可以通过-c命令来解决。</p></li></ul><p>部署步骤：</p><ol><li><p>创建脚本后复制对应脚本内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim init.sh<br></code></pre></td></tr></table></figure></li><li><p>增加权限。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> +x init.sh<br></code></pre></td></tr></table></figure></li><li><p>运行脚本。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">./init.sh<br></code></pre></td></tr></table></figure></li></ol><p>另路由器初始账号密码</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">admin<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">YourPaSsWoRd<br></code></pre></td></tr></table></figure><p>终端账号密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">debian<br></code></pre></td></tr></table></figure><hr><ul><li>更新环回地址</li><li>更新一键复制即可配置</li></ul><hr><ul><li>更新在主机上一键配置，通过telnet来实现，要求按顺序部署gns3上的路由器和终端，先路由器，后终端</li><li>若是在windows生成的文件放到linux执行，需要dos2unix转换一下</li></ul><hr><ul><li><p>更新使用python中的telnetlib来实现对多路由器的命令执行，这样在windows和linux上都可以快速部署。</p></li><li><p>参考</p><ul><li><a href="https://www.cnblogs.com/gmpy/p/11796416.html">python argparse：命令行参数解析详解 - 广漠飘羽 - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/RudeTomatoes/article/details/117003291">python之argparse模块常见用法包含实例(超详细)_python required属性-CSDN博客</a></li><li><a href="https://lanyiyun.blog.csdn.net/article/details/136049472?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-136049472-blog-117910697.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-136049472-blog-117910697.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;utm_relevant_index=3">python telnetlib详解-CSDN博客</a></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> telnetlib<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> argparse<br><br>SEP = os.sep<br><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;telnet gns3 router and execute command&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-H&#x27;</span>, <span class="hljs-string">&#x27;--host&#x27;</span>, default=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;gns3 or gns3vm ip&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-n&#x27;</span>, <span class="hljs-string">&#x27;--num&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, required=<span class="hljs-literal">True</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;number of router&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-s&#x27;</span>, <span class="hljs-string">&#x27;--start_rid&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;start router ID when init&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-P&#x27;</span>, <span class="hljs-string">&#x27;--port&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">5000</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;start gns3 port&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-p&#x27;</span>, <span class="hljs-string">&#x27;--password&#x27;</span>, default=<span class="hljs-string">&quot;YourPaSsWoRd&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;login password&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-f&#x27;</span>, <span class="hljs-string">&#x27;--cmd_file&#x27;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;command file&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&#x27;-i&#x27;</span>, <span class="hljs-string">&#x27;--init&#x27;</span>, action=<span class="hljs-string">&#x27;store_true&#x27;</span>)<br>args = parser.parse_args()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">if</span> args.init:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.num):<br>            tn = telnetlib.Telnet(args.host, args.port + i * <span class="hljs-number">2</span>)<br>            tn.write(<span class="hljs-string">b&quot;admin\n&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.01</span>)<br>            tn.write(args.password.encode(<span class="hljs-string">&quot;ascii&quot;</span>) + <span class="hljs-string">b&quot;\n&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.01</span>)<br>            route_sh = <span class="hljs-string">&quot;out&quot;</span> + SEP + <span class="hljs-string">&quot;r&quot;</span> + <span class="hljs-built_in">str</span>(args.start + i) + <span class="hljs-string">&quot;.sh&quot;</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(route_sh, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>                    tn.write(line.encode(<span class="hljs-string">&quot;ascii&quot;</span>) + <span class="hljs-string">b&quot;\n&quot;</span>)<br>                    time.sleep(<span class="hljs-number">0.01</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&quot;</span>+<span class="hljs-string">&quot;Process: %d / %d&quot;</span>%(i+<span class="hljs-number">1</span>,args.num),end=<span class="hljs-string">&quot;&quot;</span>,flush=<span class="hljs-literal">True</span>)<br>            tn.close()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.num):<br>            tn = telnetlib.Telnet(args.host, args.port + i * <span class="hljs-number">2</span>)<br>            tn.write(<span class="hljs-string">b&quot;admin\n&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.01</span>)<br>            tn.write(args.password.encode(<span class="hljs-string">&quot;ascii&quot;</span>) + <span class="hljs-string">b&quot;\n&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.01</span>)<br>            tn.write(<span class="hljs-string">b&quot;sudo -s\n&quot;</span>)<br>            time.sleep(<span class="hljs-number">0.01</span>)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(args.cmd_file, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                cmd=<span class="hljs-string">&quot;&quot;</span><br>                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>                    line=line.rstrip()<br>                    <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&quot;&quot;</span>:<br>                        cmd +=line<br>                    <span class="hljs-keyword">else</span>:<br>                        cmd += <span class="hljs-string">&quot; &amp;&amp; &quot;</span>+line<br>                    time.sleep(<span class="hljs-number">0.01</span>)<br>                tn.write(cmd.encode(<span class="hljs-string">&quot;ascii&quot;</span>) + <span class="hljs-string">b&quot;\n&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\r&quot;</span>+<span class="hljs-string">&quot;Process: %d / %d&quot;</span>%(i+<span class="hljs-number">1</span>,args.num),end=<span class="hljs-string">&quot;&quot;</span>,flush=<span class="hljs-literal">True</span>)<br>            tn.close()<br><br></code></pre></td></tr></table></figure><p>附上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># author: hey137</span><br><span class="hljs-keyword">import</span> os.path<br><br>ROUTE_NUM = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入路由器数目\n&quot;</span>))<br>TERM_NUM = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入终端数目\n&quot;</span>))<br>SEP = os.sep<br>OUT_PATH = <span class="hljs-string">&quot;.&quot;</span> + SEP + <span class="hljs-string">&quot;out&quot;</span><br>password = <span class="hljs-string">&quot;123&quot;</span><br>MTU = <span class="hljs-number">9000</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_dir</span>(<span class="hljs-params">path</span>):<br>    folder = os.path.exists(path)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> folder:<br>        os.makedirs(path)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_ipv4</span>(<span class="hljs-params">my_id, oid, mask</span>):<br>    <span class="hljs-keyword">if</span> my_id &lt; oid:<br>        ip = <span class="hljs-string">&quot;10.&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">else</span>:<br>        ip = <span class="hljs-string">&quot;10.&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">if</span> mask &gt; <span class="hljs-number">0</span>:<br>        ip = ip + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(mask)<br>    <span class="hljs-keyword">return</span> ip<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_ipv6</span>(<span class="hljs-params">my_id, oid, mask</span>):<br>    <span class="hljs-keyword">if</span> my_id &lt; oid:<br>        ip = <span class="hljs-string">&quot;2023:&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;::&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">else</span>:<br>        ip = <span class="hljs-string">&quot;2023:&quot;</span> + <span class="hljs-built_in">str</span>(oid) + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-built_in">str</span>(my_id) + <span class="hljs-string">&quot;::&quot;</span> + <span class="hljs-built_in">str</span>(my_id)<br>    <span class="hljs-keyword">if</span> mask &gt; <span class="hljs-number">0</span>:<br>        ip = ip + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">str</span>(mask)<br>    <span class="hljs-keyword">return</span> ip<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Terminal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, tid</span>):<br>        <span class="hljs-comment"># tid:term_id</span><br>        self.oid = <span class="hljs-literal">None</span><br>        self.<span class="hljs-built_in">id</span> = tid + ROUTE_NUM<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_ens4_route</span>(<span class="hljs-params">self, oid</span>):<br>        self.oid = oid<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sh</span>(<span class="hljs-params">self</span>):<br>        file_name = OUT_PATH + SEP + <span class="hljs-string">&quot;t&quot;</span> + <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span> - ROUTE_NUM) + <span class="hljs-string">&quot;.sh&quot;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-comment"># 一键复制</span><br>            f.write(<span class="hljs-string">&quot;cat &lt;&lt; EOFSH &gt; init.sh\n&quot;</span>)<br>            pre_order = \<br>                <span class="hljs-string">&quot;&quot;&quot;sudo sed -i -e &#x27;s/source-directory \\/run/# source-directory \\/run/g&#x27; /etc/network/interfaces</span><br><span class="hljs-string">sudo sed -i -e &#x27;8a auto ens5\\niface ens5 inet dhcp&#x27; /etc/network/interfaces</span><br><span class="hljs-string">sudo rm /etc/network/interfaces.d/50-cloud-init</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            f.write(pre_order)<br>            <span class="hljs-comment"># 修改权限</span><br>            chmod = <span class="hljs-string">&quot;sudo chmod 777 /etc/network/interfaces.d\n&quot;</span><br>            f.write(chmod)<br>            <span class="hljs-comment"># 配置ip和默认网关</span><br>            my_ipv6 = make_ipv6(self.<span class="hljs-built_in">id</span>, self.oid, <span class="hljs-number">64</span>)<br>            o_ipv6 = make_ipv6(self.oid, self.<span class="hljs-built_in">id</span>, <span class="hljs-number">0</span>)<br>            ipv4 = make_ipv4(self.<span class="hljs-built_in">id</span>, self.oid, <span class="hljs-number">24</span>)<br>            o_ipv4 = make_ipv4(self.oid, self.<span class="hljs-built_in">id</span>, <span class="hljs-number">0</span>)<br>            ip_config = <span class="hljs-string">&quot;&quot;&quot;sudo cat &lt;&lt; EOF &gt; /etc/network/interfaces.d/10-ens4</span><br><span class="hljs-string">auto ens4</span><br><span class="hljs-string">iface ens4 inet6 static</span><br><span class="hljs-string">address &quot;&quot;&quot;</span> + my_ipv6 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">gateway &quot;&quot;&quot;</span> + o_ipv6 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">iface ens4 inet static</span><br><span class="hljs-string">address &quot;&quot;&quot;</span> + ipv4 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">mtu &quot;&quot;&quot;</span> + <span class="hljs-built_in">str</span>(MTU) + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">up ip route add 10.0.0.0/8 via &quot;&quot;&quot;</span> + o_ipv4 + <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            f.write(ip_config)<br>            restart_net = <span class="hljs-string">&quot;sudo systemctl restart networking\n&quot;</span><br>            f.write(restart_net)<br>            f.write(<span class="hljs-string">&quot;EOFSH\nchmod +x init.sh\n./init.sh\n&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, rid</span>):<br>        <span class="hljs-comment"># rid:router_id</span><br>        self.inter_map = &#123;&#125;<br>        self.<span class="hljs-built_in">id</span> = rid<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_edge</span>(<span class="hljs-params">self, _inter, oid</span>):<br>        <span class="hljs-comment"># oid:other_id</span><br>        self.inter_map[_inter] = oid<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sh</span>(<span class="hljs-params">self</span>):<br>        file_name = OUT_PATH + SEP + <span class="hljs-string">&quot;r&quot;</span> + <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>) + <span class="hljs-string">&quot;.sh&quot;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-comment"># 一键复制</span><br>            f.write(<span class="hljs-string">&quot;cat &lt;&lt; EOFSH &gt; init.sh\n&quot;</span>)<br>            <span class="hljs-comment"># 修改密码</span><br>            change_passwd = <span class="hljs-string">&quot;echo -e \&quot;&quot;</span> + password + <span class="hljs-string">&quot;\n&quot;</span> + password + <span class="hljs-string">&quot;\n\&quot; | sudo passwd admin\n&quot;</span><br>            f.write(change_passwd)<br>            <span class="hljs-comment"># 配置isis自启动</span><br>            start_isis = <span class="hljs-string">&quot;&quot;&quot;cat &lt;&lt; EOF &gt; start_isisd.service</span><br><span class="hljs-string">[Unit]</span><br><span class="hljs-string">Description=Docker ISISD Service</span><br><span class="hljs-string">After=docker.service</span><br><span class="hljs-string">Requires=docker.service</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">ExecStart=/usr/bin/docker exec -i bgp /bin/bash -c &quot;/usr/lib/frr/isisd -A 127.0.0.1 -d&quot;</span><br><span class="hljs-string">Restart=always</span><br><span class="hljs-string">RestartSec=5</span><br><span class="hljs-string"></span><br><span class="hljs-string">[Install]</span><br><span class="hljs-string">WantedBy=multi-user.target</span><br><span class="hljs-string">EOF</span><br><span class="hljs-string">sudo mv start_isisd.service /etc/systemd/system/</span><br><span class="hljs-string">sudo systemctl daemon-reload</span><br><span class="hljs-string">sudo systemctl enable start_isisd.service</span><br><span class="hljs-string">/usr/bin/docker exec -i bgp /bin/bash -c &quot;/usr/lib/frr/isisd -A 127.0.0.1 -d&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            f.write(start_isis)<br>            <span class="hljs-comment"># 配置ip</span><br>            <span class="hljs-keyword">for</span> _inter, oid <span class="hljs-keyword">in</span> self.inter_map.items():<br>                old_id = <span class="hljs-string">&quot;10.0.0.&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">2</span>) + <span class="hljs-string">&quot;/31&quot;</span><br>                ipv4 = make_ipv4(self.<span class="hljs-built_in">id</span>, oid, <span class="hljs-number">24</span>)<br>                ipv6 = make_ipv6(self.<span class="hljs-built_in">id</span>, oid, <span class="hljs-number">64</span>)<br>                remove_ip = <span class="hljs-string">&quot;sudo config interface ip remove Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + old_id + <span class="hljs-string">&quot;\n&quot;</span><br>                add_ipv4 = <span class="hljs-string">&quot;sudo config interface ip add Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + ipv4 + <span class="hljs-string">&quot;\n&quot;</span><br>                add_ipv6 = <span class="hljs-string">&quot;sudo config interface ip add Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + ipv6 + <span class="hljs-string">&quot;\n&quot;</span><br>                change_mtu = <span class="hljs-string">&quot;sudo config interface mtu Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">str</span>(MTU) + <span class="hljs-string">&quot;\n&quot;</span><br>                start_up = <span class="hljs-string">&quot;sudo config interface startup Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot;\n&quot;</span><br>                f.write(remove_ip)<br>                f.write(add_ipv4)<br>                f.write(add_ipv6)<br>                f.write(change_mtu)<br>                f.write(start_up)<br>            <span class="hljs-comment"># loopback_ipv6 = &quot;2023:&quot; + str(self.id) + &quot;::1&quot;</span><br>            <span class="hljs-comment"># add_loopback = &quot;sudo config interface ip add Loopback0&quot; + &quot; &quot; + loopback_ipv6 + &quot;\n&quot;</span><br>            <span class="hljs-comment"># f.write(add_loopback)</span><br>            save = <span class="hljs-string">&quot;sudo config save -y\n&quot;</span><br>            f.write(save)<br>            <span class="hljs-comment"># 配置isis</span><br>            pre_order = <span class="hljs-string">&quot;&quot;&quot;vtysh -c &quot;</span><br><span class="hljs-string">config</span><br><span class="hljs-string">ro isis sonic</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>            <span class="hljs-comment"># net 49.0001.0000.0000.str(rid)(左边补齐0).00</span><br>            net = <span class="hljs-string">&quot;net 49.0001.0000.0000.&quot;</span> + <span class="hljs-string">&quot;0&quot;</span> * (<span class="hljs-number">4</span> - <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>))) + <span class="hljs-built_in">str</span>(self.<span class="hljs-built_in">id</span>) + <span class="hljs-string">&quot;.00\n&quot;</span><br>            f.write(pre_order)<br>            f.write(net)<br>            <span class="hljs-keyword">for</span> _inter <span class="hljs-keyword">in</span> self.inter_map.keys():<br>                enter_inter = <span class="hljs-string">&quot;interface Ethernet&quot;</span> + <span class="hljs-built_in">str</span>(_inter * <span class="hljs-number">4</span>) + <span class="hljs-string">&quot;\n&quot;</span><br>                isis = <span class="hljs-string">&quot;ipv6 ro isis sonic\nip ro isis sonic\n&quot;</span><br>                lfa = <span class="hljs-string">&quot;isis fast-reroute lfa\n&quot;</span><br>                f.write(enter_inter)<br>                f.write(isis)<br>                f.write(lfa)<br>                f.write(<span class="hljs-string">&quot;exit\n&quot;</span>)<br>            <span class="hljs-comment"># f.write(&quot;interface Loopback0\nipv6 ro isis sonic\n&quot;)</span><br>            f.write(<span class="hljs-string">&quot;end\n&quot;</span>)<br>            f.write(<span class="hljs-string">&quot;write\&quot;\n&quot;</span>)<br>            f.write(<span class="hljs-string">&quot;EOFSH\nchmod +x init.sh\n./init.sh\n&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">echo_line</span>(<span class="hljs-params">cmd_str</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;echo \&quot;&quot;</span> + cmd_str + <span class="hljs-string">&quot;\&quot;\nsleep 1 \n&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_linux_host_sh</span>():<br>    file_name = OUT_PATH + SEP + <span class="hljs-string">&quot;linux_host.sh&quot;</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(<span class="hljs-string">&quot;#!/bin/bash\n&quot;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ROUTE_NUM + <span class="hljs-number">1</span>):<br>            f.write(<span class="hljs-string">&quot;# r&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;\n(\n&quot;</span>)<br>            f.write(echo_line(<span class="hljs-string">&quot;admin&quot;</span>))<br>            f.write(echo_line(<span class="hljs-string">&quot;YourPaSsWoRd&quot;</span>))<br>            f.write(<span class="hljs-string">&quot;cmd=$(sed &#x27;/chmod/q&#x27; r&quot;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot;.sh)\n&quot;</span>)<br>            f.write(echo_line(<span class="hljs-string">&quot;$cmd&quot;</span>))<br>            f.write(echo_line(<span class="hljs-string">&quot;chmod +x init.sh&quot;</span>))<br>            f.write(echo_line(<span class="hljs-string">&quot;./init.sh&quot;</span>))<br>            f.write(<span class="hljs-string">&quot;) | telnet 127.0.0.1 &quot;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-number">5000</span>+<span class="hljs-number">2</span>*(i-<span class="hljs-number">1</span>))+<span class="hljs-string">&quot;\n\n&quot;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    make_dir(OUT_PATH)<br>    router = [Router(<span class="hljs-number">0</span>)]<br>    term = [Terminal(<span class="hljs-number">0</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ROUTE_NUM + <span class="hljs-number">1</span>):<br>        router.append(Router(i))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, TERM_NUM + <span class="hljs-number">1</span>):<br>        term.append(Terminal(i))<br>    <span class="hljs-keyword">if</span> TERM_NUM &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入&quot;</span> + <span class="hljs-built_in">str</span>(TERM_NUM) + <span class="hljs-string">&quot;条终端链路信息 格式：（终端n通过路由器a的ei接口与路由器a相连 n inter_ei aID)&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(TERM_NUM):<br>        edge = <span class="hljs-built_in">input</span>()<br>        term_id, inter, r_id = edge.split()<br>        term_id = <span class="hljs-built_in">int</span>(term_id)<br>        r_id = <span class="hljs-built_in">int</span>(r_id)<br>        inter = <span class="hljs-built_in">int</span>(inter)<br>        term[term_id].add_ens4_route(r_id)<br>        router[r_id].add_edge(inter, term[term_id].<span class="hljs-built_in">id</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入路由链路信息，以空行结尾 格式：（路由器a的ei接口与路由器b的ej接口相连aID inter_ei inter_ej bID）&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        edge = <span class="hljs-built_in">input</span>()<br>        <span class="hljs-keyword">if</span> edge == <span class="hljs-string">&quot;&quot;</span>:<br>            <span class="hljs-keyword">break</span><br>        s_router, s_inter, d_inter, d_router = edge.split()<br>        s_router = <span class="hljs-built_in">int</span>(s_router)<br>        s_inter = <span class="hljs-built_in">int</span>(s_inter)<br>        d_router = <span class="hljs-built_in">int</span>(d_router)<br>        d_inter = <span class="hljs-built_in">int</span>(d_inter)<br>        router[s_router].add_edge(s_inter, d_router)<br>        router[d_router].add_edge(d_inter, s_router)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, ROUTE_NUM + <span class="hljs-number">1</span>):<br>        router[i].make_sh()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, TERM_NUM + <span class="hljs-number">1</span>):<br>        term[i].make_sh()<br><br>    make_linux_host_sh()<br><br></code></pre></td></tr></table></figure><h3 id="配置PBR">配置PBR</h3><p>用于解决有时ISIS路由inactive导致的无法连通，目的在于实现10.0.0.0/8以外的目的地址都通过eth0。但目前isis路由inactive的触发条件没有找到，似乎是eth0连接nat后可可能将eth0作为默认路由导致10.0.0.0/8中的地址也去eth0，故ping不通。</p><h4 id="配置">配置</h4><p>如果你希望实现除了10.0.0.0/8的其他网络使用eth0作为默认网关，而10.0.0.0/8网段有多个网关处理的情况，可以考虑使用Policy-Based Routing（PBR）来实现。</p><p>PBR允许你基于源IP地址、目标IP地址、源端口、目标端口或其他匹配条件，来选择不同的路由策略。在这种情况下，你可以设置一个PBR规则，让除了10.0.0.0/8的其他网络流量使用eth0作为默认网关。</p><p>下面是一个简单的PBR配置示例：</p><ol><li><p>创建一个新的路由表，比如表号为100：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;100    eth0&quot;</span> &gt;&gt; /etc/iproute2/rt_tables<br></code></pre></td></tr></table></figure></li><li><p>设置PBR规则，让除了10.0.0.0/8的其他网络流量使用新的路由表：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip rule add from 10.0.0.0/8 table main<br>ip rule add from all table 100<br></code></pre></td></tr></table></figure></li><li><p>在新的路由表（表号为100）中添加默认路由，指向eth0网关：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ip route add default via &lt;eth0_gateway_ip&gt; dev eth0 table 100<br></code></pre></td></tr></table></figure></li></ol><p>这样配置后，除了10.0.0.0/8的其他网络流量将会使用eth0作为默认网关进行通信。</p><p>请替换<code>&lt;eth0_gateway_ip&gt;</code>为你实际的eth0网关IP地址。</p><p>完成以上配置后，重新加载PBR规则并测试网络连接，确保配置生效。这样就可以实现除了10.0.0.0/8的其他网络使用eth0作为默认网关的功能。</p><h4 id="检查">检查</h4><ol><li>使用 <code>ip rule show</code> 命令来查看PBR规则是否正确设置。确保除了10.0.0.0/8的其他网络有一个规则指定使用新创建的路由表（table 100）。</li><li>使用 <code>ip route show table 100</code> 命令来查看新创建的路由表中是否包含了正确的默认路由，指向eth0网关。</li></ol><h3 id="sonic-p4-更换source源">sonic-p4 更换source源</h3><p>原本的源已经过期无法使用</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">deb http://snapshot.debian.org/archive/debian/20210326T030000Z jessie main<br></code></pre></td></tr></table></figure><h3 id="sonic内核版本更换">sonic内核版本更换</h3><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241120111942004.png" alt="image-20241120111942004"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 添加源deb http://security.debian.org/debian-security bullseye-security main </span><br>sudo apt search linux-headers<br>sudo apt-get install linux-headers 下载最新可用的<br><span class="hljs-comment"># 修改Makefile文件</span><br></code></pre></td></tr></table></figure><h3 id="debian旧版本">debian旧版本</h3><ol><li><p><a href="https://deb.sipwise.com/debian/pool/main/l/linux/">Index of /debian/pool/main/l/linux</a>搜索linux-headers-5.10.0-18，下载<code>linux-headers-5.10.0-18-common_5.10.140-1_all.deb</code>和<code>linux-headers-5.10.0-18-amd64_5.10.140-1_amd64.deb</code></p></li><li><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo dpkg -i linux-headers-5.10.0-18-common_5.10.140-1_all.deb<br>sudo dpkg -i linux-headers-5.10.0-18-amd64_5.10.140-1_amd64.deb<br></code></pre></td></tr></table></figure></li></ol><h3 id="sonic架构">sonic架构</h3><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241126111746925.png" alt="image-20241126111746925"></p><h3 id="快速删除默认路由-添加vlan">快速删除默认路由&amp;添加vlan</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Create untagged vlan</span><br>sudo config vlan add 2<br><br><span class="hljs-comment"># Add IP to vlan</span><br>sudo config interface ip add Vlan2 10.2.0.0/24<br><br><span class="hljs-comment"># Remove all default IP settings</span><br>show ip interfaces | <span class="hljs-built_in">tail</span> -n +3 | grep Ethernet | awk <span class="hljs-string">&#x27;&#123;print &quot;sudo config interface ip remove&quot;, $1, $2&#125;&#x27;</span> &gt; oobe.sh; <span class="hljs-built_in">chmod</span> +x oobe.sh; ./oobe.sh<br><br><span class="hljs-comment"># Add all ports to the new vlan</span><br>show interfaces status | <span class="hljs-built_in">tail</span> -n +3 | grep Ethernet | awk <span class="hljs-string">&#x27;&#123;print &quot;sudo config vlan member add -u 2&quot;, $1&#125;&#x27;</span> &gt; oobe.sh; <span class="hljs-built_in">chmod</span> +x oobe.sh; ./oobe.sh<br><br><span class="hljs-comment"># Enable proxy arp, so switch can respond to arp requests from hosts</span><br>sudo config vlan proxy_arp 2 enabled<br><br><span class="hljs-comment"># Save config, so it will be persistent after reboot</span><br>sudo config save -y<br></code></pre></td></tr></table></figure><h3 id="sonic-vpp">sonic-vpp</h3><p><a href="https://ronnievsmith.medium.com/sonic-virtual-switch-with-fd-ios-vector-packet-processor-vpp-on-google-cloud-89f9c62f5fe3">SONiC Virtual Switch with FD.io Vector Packet Processor (VPP) on Google Cloud | by Ronnie Smith | Oct, 2024 | Medium</a></p><ul><li>如何拉取pause镜像<a href="https://blog.csdn.net/catoop/article/details/124167797">国内拉取 gcr.io 镜像（Google Kubernetes 镜像）-CSDN博客</a></li></ul><blockquote><p>tun/tap设备是linux当中的虚拟网络设备，与之前提到的<a href="https://zhida.zhihu.com/search?content_id=131959650&amp;content_type=Article&amp;match_order=1&amp;q=veth&amp;zhida_source=entity">veth</a>，linux网桥等类似，只是另外一端连接的不一样。</p><ul><li>veth设备一端连接协议栈，另外一端连接的是veth设备</li><li>linux网桥一端连接协议栈，另外一端连接设备（可以是网卡，也可以是虚拟设备）</li></ul><p>而这篇文章的主角，tun/tap设备一端连接协议栈，另外一端连接<a href="https://zhida.zhihu.com/search?content_id=131959650&amp;content_type=Article&amp;match_order=1&amp;q=%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F&amp;zhida_source=entity">用户程序</a>，允许用户程序像读写文件一样进行收发数据包。</p></blockquote><h4 id="build">build</h4><p><a href="https://github.com/sonic-net/sonic-platform-vpp">https://github.com/sonic-net/sonic-platform-vpp</a></p><ol><li><p>git clone --recurse-submodules <a href="https://github.com/sonic-net/sonic-buildimage.git">https://github.com/sonic-net/sonic-buildimage.git</a> 无法克隆子模块，采用<a href="https://blog.csdn.net/qq_45523675/article/details/131661935">https://blog.csdn.net/qq_45523675/article/details/131661935</a> 解决，原理是将https协议换成ssh去克隆，ssh要配置好设备上的公钥并提交到github。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-function"><span class="hljs-title">pull_submodule_recursive</span></span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> [ -f <span class="hljs-string">&quot;.gitmodules&quot;</span> ];<span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;.gitmodules found&quot;</span><br>        <span class="hljs-comment"># backup</span><br>        <span class="hljs-built_in">cp</span> .gitmodules .gitmodules.bak<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line<br>        <span class="hljs-keyword">do</span><br>            <span class="hljs-comment"># substitude the https with ssh</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;line&#125;</span> | sed <span class="hljs-string">&#x27;s/https:\/\/github.com\//git@github.com:/g&#x27;</span> &gt;&gt; .new_gitmodules<br>        <span class="hljs-keyword">done</span> &lt; .gitmodules<br>        <span class="hljs-built_in">mv</span> .new_gitmodules .gitmodules<br>        <span class="hljs-comment"># pull current submodules</span><br>        git submodule init<br>        git submodule <span class="hljs-built_in">sync</span><br>        git submodule update<br>        <span class="hljs-comment"># get the directories of current submodules</span><br>        <span class="hljs-built_in">local</span> directories=$(<span class="hljs-built_in">cat</span> .gitmodules | grep path | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br>        <span class="hljs-keyword">for</span> directory <span class="hljs-keyword">in</span> <span class="hljs-variable">$directories</span><br>        <span class="hljs-keyword">do</span><br>            <span class="hljs-keyword">if</span> [ -d <span class="hljs-variable">$directory</span> ];<span class="hljs-keyword">then</span><br>                <span class="hljs-comment"># enter the directory</span><br>                <span class="hljs-built_in">pushd</span> <span class="hljs-variable">$&#123;directory&#125;</span> &gt; /dev/null<br>                <span class="hljs-comment"># pull one submodule and its submodules</span><br>                pull_submodule_recursive<br>                <span class="hljs-comment"># return to the last working directory</span><br>                <span class="hljs-built_in">popd</span> &gt; /dev/null<br>            <span class="hljs-keyword">fi</span><br>        <span class="hljs-keyword">done</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;current submodule has no submodule, return to last directory...&quot;</span><br>    <span class="hljs-keyword">fi</span><br>    <span class="hljs-built_in">return</span> 0<br>&#125;<br><br>pull_submodule_recursive<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># https://liaoxuefeng.com/books/git/remote/index.html</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br><span class="hljs-comment"># 将~/.ssh/id_rsa.pub 下的内容提交到github</span><br>ssh -T git@github.com <span class="hljs-comment"># 验证是否成功</span><br></code></pre></td></tr></table></figure></li><li><p>可通过以下命令确认子模块是否下载完全</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git submodule update --init --recursive<br></code></pre></td></tr></table></figure></li><li><p>执行make configure PLATFORM=vpp时，make中docker在容器中update很慢，<a href="https://blog.csdn.net/peng2hui1314/article/details/124267333">https://blog.csdn.net/peng2hui1314/article/details/124267333</a></p><p>添加 <code>~/.docker/config.json</code>，再重启docker，<code>sudo systemctl restart docker</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;proxies&quot;</span><span class="hljs-punctuation">:</span><br> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;default&quot;</span><span class="hljs-punctuation">:</span><br>   <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;httpProxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;httpsProxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;noProxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*.test.example.com,.example2.com,127.0.0.0/8&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="FRR">FRR</h2><p><a href="https://docs.frrouting.org/en/latest/isisd.html#isis-interface">ISIS — FRR latest documentation (frrouting.org)</a></p><p>注意，以后有关FRRouting的相关内容可以去这个网站查看<a href="https://app.slack.com/client/T4SEHL8CQ/C4TS8E59D">random（频道） - FRRouting - Slack</a>。来自<a href="https://frrouting.org/community/">FRRouting Community – FRRouting</a></p><p>另一方面，多关注github的issue页面。<a href="https://github.com/FRRouting/frr/issues">FRRouting/frr: The FRRouting Protocol Suite (github.com)</a></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231218153819693.png" alt="image-20231218153819693"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">isis fast-reroute lfa<br>isis fast-reroute remote-lfa tunnel mpls-ldp [level-1 | level-2]<br></code></pre></td></tr></table></figure><h3 id="配置TI-LFA">配置TI-LFA</h3><h4 id="ISIS">ISIS</h4><p>有关TI-LFA的详细介绍<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100167260">Segment Routing TI-LFA FRR保护技术 - 华为 (huawei.com)</a></p><p>FRRouting上的配置与SR和TI相关，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs sh">vtysh -c <span class="hljs-string">&quot;</span><br><span class="hljs-string">config</span><br><span class="hljs-string">ro isis sonic</span><br><span class="hljs-string">is-type level-1</span><br><span class="hljs-string">net 49.0001.0000.0000.0006.00</span><br><span class="hljs-string"></span><br><span class="hljs-string">segment-routing on</span><br><span class="hljs-string">segment-routing global-block 16000 23999</span><br><span class="hljs-string">segment-routing node-msd 8</span><br><span class="hljs-string">segment-routing prefix 6.6.6.6/32 index 60</span><br><span class="hljs-string">segment-routing prefix 2001::6/128 index 61</span><br><span class="hljs-string">interface lo</span><br><span class="hljs-string">ip address 6.6.6.6/32</span><br><span class="hljs-string">ipv6 address 2001::6/128</span><br><span class="hljs-string">ip ro isis sonic</span><br><span class="hljs-string">ipv6 ro isis sonic</span><br><span class="hljs-string">isis passive</span><br><span class="hljs-string">exit</span><br><span class="hljs-string"></span><br><span class="hljs-string">interface Ethernet4</span><br><span class="hljs-string">ipv6 ro isis sonic</span><br><span class="hljs-string">ip ro isis sonic</span><br><span class="hljs-string">isis fast-reroute ti-lfa</span><br><span class="hljs-string">exit</span><br><span class="hljs-string">end</span><br><span class="hljs-string">write&quot;</span><br></code></pre></td></tr></table></figure><h4 id="OSPF">OSPF</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config save -y<br>vtysh -c <span class="hljs-string">&quot;</span><br><span class="hljs-string">config</span><br><span class="hljs-string"></span><br><span class="hljs-string">interface Ethernet4</span><br><span class="hljs-string">ip ospf network point-to-point</span><br><span class="hljs-string">exit</span><br><span class="hljs-string">interface lo</span><br><span class="hljs-string">ip address 1.1.1.6/32</span><br><span class="hljs-string">ip ospf passive</span><br><span class="hljs-string">exit</span><br><span class="hljs-string"></span><br><span class="hljs-string">ro ospf</span><br><span class="hljs-string">ospf router-id 1.1.1.6</span><br><span class="hljs-string">net 20.0.0.0/8 area 0.0.0.0</span><br><span class="hljs-string">net 1.1.1.0/24 area 0.0.0.0</span><br><span class="hljs-string">area 0.0.0.0 range 20.0.0.0/8</span><br><span class="hljs-string">area 0.0.0.0 range 1.1.1.0/24</span><br><span class="hljs-string">capability opaque</span><br><span class="hljs-string">mpls-te on</span><br><span class="hljs-string">mpls-te router-address 1.1.1.6</span><br><span class="hljs-string">router-info area 0.0.0.0</span><br><span class="hljs-string">segment-routing on</span><br><span class="hljs-string">segment-routing global-block 16000 24000</span><br><span class="hljs-string">segment-routing node-msd 8</span><br><span class="hljs-string">segment-routing prefix 1.1.1.6/32 index 60</span><br><span class="hljs-string"></span><br><span class="hljs-string">end</span><br><span class="hljs-string">write&quot;</span><br></code></pre></td></tr></table></figure><h3 id="bgp">bgp</h3><p>参考<a href="https://blog.csdn.net/weixin_44900668/article/details/119170147">BGP 基本配置实验（超详细）_bgp实验-CSDN博客</a></p><p><a href="https://docs.frrouting.org/en/latest/bgp.html#clicmd-neighbor-PEER-next-hop-self-force">BGP — FRR latest documentation (frrouting.org)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">vtysh<br>config<br>no route bgp 65100<br>route bgp ASN<br>neighbor X.X.X.X remote-as ASN   ! ebgp的ip地址和asn<br>neighbor X.X.X.X update-source Loopback0 (iBGP)  ！ibgp的loopback地址<br>neighbor X.X.X.X next-hop-self force (iBGP) !tab补不出来，得自己敲，或者进address-family ipv4模式<br>no bgp ebgp-requires-policy<br><br>！可使用peer-group简化配置  neighbor WORD peer-group<br>neighbor ibgp peer-group<br>neighbor ibgp remote-as ASN<br>neighbor ibgp update-source Loopback0<br>neighbor ibgp next-hop-self force<br>neighbor X.X.X.X peer-group ibgp<br>还有activate<br><br></code></pre></td></tr></table></figure><p>重启保存bgp配置[<a href="https://support.edge-core.com/hc/en-us/articles/900000514823--Enterprise-SONiC-FRRouting-and-config-initialization">Enterprise SONiC] FRRouting and config initialization – Edgecore Help Center (edge-core.com)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/sonic/config_db.json<br>1. BGP_NEIGHBOR前加<span class="hljs-string">&quot;//&quot;</span><br>2. 删除<span class="hljs-string">&quot;DEVICE_METADATA&quot;</span>中的bgp_asn一行<br>3. 在<span class="hljs-string">&quot;DEVICE_METADATA&quot;</span>添加<span class="hljs-string">&quot;docker_routing_config_mode&quot;</span>:<span class="hljs-string">&quot;split&quot;</span><br><br><br>sudo sed -i <span class="hljs-string">&#x27;s/&quot;BGP_NEIGHBOR&quot;/&quot;\/\/BGP_NEIGHBOR&quot;/g&#x27;</span> /etc/sonic/config_db.json<br>sudo sed -i <span class="hljs-string">&#x27;s/&quot;bgp_asn&quot;: &quot;65100&quot;,//g&#x27;</span> /etc/sonic/config_db.json<br>sudo sed -i <span class="hljs-string">&#x27;s/&quot;type&quot;: &quot;LeafRouter&quot;/&quot;type&quot;: &quot;LeafRouter&quot;,\n&quot;docker_routing_config_mode&quot;:&quot;split&quot;/g&#x27;</span> /etc/sonic/config_db.json<br></code></pre></td></tr></table></figure><ul><li>bgp只需转发业务路由就好了，不用转发全部区域路由，这样把bgp重分发到isis就可以解决路由黑洞问题了。</li></ul><h2 id="GNS3与vmware">GNS3与vmware</h2><h3 id="下载gns3">下载gns3</h3><p>参考<a href="https://cn.linux-console.net/?p=22052">如何在 Ubuntu 22.04|20.04|18.04 上安装 GNS3 (linux-console.net)</a></p><p>其中这一步是必须的</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231120152630696.png" alt="image-20231120152630696"></p><p>且命令修改如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo usermod -aG ubridge,libvirt,kvm,wireshark <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><p>全部配置完成后需要重启电脑。</p><h3 id="使用python下载gns3">使用python下载gns3</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt update<br>sudo apt install -y python3-pip python3-pyqt5 python3-pyqt5.qtsvg \<br>python3-pyqt5.qtwebsockets \<br>qemu qemu-kvm qemu-utils libvirt-clients libvirt-daemon-system virtinst \<br>wireshark xtightvncviewer apt-transport-https \<br>ca-certificates curl gnupg2 software-properties-common<br></code></pre></td></tr></table></figure><h3 id="vmware的各种连接模式">vmware的各种连接模式</h3><p><a href="https://blog.csdn.net/weixin_46709219/article/details/108590498">虚拟机连网（多台虚拟机互联、虚拟机与真机互联、虚拟机上网）_多台主机的虚拟机互通必须要有网络吗-CSDN博客</a></p><ul><li><p>桥连接模式（VMnet0）：<br>将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。此模式下的虚拟机和自己的依赖主机共同处在同一个网段下，<a href="http://xn--IP192-jq1hs78d92ef7jencovxea285aftbr18k.168.100.xxx">意思就是如果主机的IP是192.168.100.xxx</a>,<a href="http://xn--IP192-4n1hig5gt8dn54bbfap00d6uvptkg1dk34f8i2ccyxb.168.100.xxx">那么虚拟机中的IP地址也将会是192.168.100.xxx</a>,如果需要联网，则网关与DNS需要与主机网卡一致。虚拟机也会占用局域网中的一个IP地址，并且可以和主机同网段的其他真实终端进行相互访问。</p></li><li><p>NAT模式（VMnet8)：<br>VMware会在主机上建立单独的专用网络，用以在主机和虚拟机之间相互通信。虚拟机向外部网络发送的请求数据”包裹”，都会交由NAT网络适配器加上”特殊标记”并以主机的名义转发出去，外部网络返回的响应数据”包裹”，也是先由主机接收，然后交由NAT网络适配器根据”特殊标记”进行识别并转发给对应的虚拟机，因此，虚拟机在外部网络中不必具有自己的IP地址。从外部网络来看，虚拟机和主机在共享一个IP地址（因此，只要主机可以访问Internet虚拟机就可以访问Internet），默认情况下，外部网络终端也无法访问到虚拟机。此外，在一台主机上只允许有一个NAT模式的虚拟网络。因此，同一台主机上的多个采用NAT模式网络连接的虚拟机也是可以相互访问的，但因为NAT模式下的虚拟机不具有真实IP，所以无法和主机同网段的其他真实终端进行相互访问。</p></li><li><p>Host-Only模式(VMnet1)：<br>一种比NAT模式更加封闭的的网络连接模式，它将创建完全包含在主机中的专用网络。仅主机模式的虚拟网络适配器仅对主机可见，并在虚拟机和主机系统之间提供网络连接。相对于NAT模式而言，仅主机模式不具备NAT功能，因此在默认情况下，使用仅主机模式网络连接的虚拟机无法连接到Internet(在主机上安装合适的路由或代理软件，或者在Windows系统的主机上使用Internet连接共享功能，仍然可以让虚拟机连接到Internet或其他网络)。在同一台主机上可以创建多个仅主机模式的虚拟网络，如果多个虚拟机处于同一个仅主机模式网络中，那么它们之间是可以相互通信的；如果它们处于不同的仅主机模式网络，则默认情况下无法进行相互通信(可通过在它们之间设置路由器来实现相互通信)。</p></li></ul><h3 id="gns3vm（ubuntu20-04）配置网卡">gns3vm（ubuntu20.04）配置网卡</h3><p><a href="https://blog.csdn.net/u014129103/article/details/127927064">Ubuntu Server 20.04 网卡启动及配置_ubuntu20.04网卡配置_fghjkl17的博客-CSDN博客</a></p><ol><li><p>修改/etc/netplan/00-installer-config.yaml即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/netplan/00-installer-config.yaml<br></code></pre></td></tr></table></figure></li><li><p>修改相应内容，注意yaml文件对缩进空格严格。如下，本项目中gateway4往下可以不配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">network:</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">ethernets:</span><br>    <span class="hljs-attr">eth0:</span><br>      <span class="hljs-attr">dhcp4:</span> <span class="hljs-literal">no</span><br>      <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">/24</span>]<br>      <span class="hljs-attr">optional:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">gateway4:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>      <span class="hljs-attr">nameservers:</span><br>              <span class="hljs-attr">addresses:</span> [<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>,<span class="hljs-number">8.8</span><span class="hljs-number">.8</span><span class="hljs-number">.8</span>]<br>              <br></code></pre></td></tr></table></figure><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240302133745076.png" alt="image-20240302133745076"></p></li><li><p>应用更改</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo netplan apply<br></code></pre></td></tr></table></figure></li></ol><h3 id="windows配置静态路由">windows配置静态路由</h3><ol><li><p><code>win</code>搜索powershell，管理员模式运行。</p></li><li><p><code>route print</code>寻找下一跳的网卡编号</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231102132525764.png" alt="image-20231102132525764"></p></li><li><p><code>route add</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">route add 目的ip <span class="hljs-attribute">mask</span> 掩码 下一跳 if 网卡编号 -<span class="hljs-selector-tag">p</span>   （-<span class="hljs-selector-tag">p</span>表示永久路由，否则重启该路由就没了）<br></code></pre></td></tr></table></figure><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231102132612024.png" alt="image-20231102132612024"></p></li></ol><h3 id="windows配置MTU">windows配置MTU</h3><ol><li><p><code>win</code>搜索powershell，管理员模式运行。</p></li><li><p>如果是windows11，还需进入网卡适配器</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231110133046953.png" alt="image-20231110133046953"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231110133117432.png" alt="image-20231110133117432"></p><p>但只能修改为9014Bytes以下。</p></li><li><p>输入以下命令，查看MTU</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">netsh interface ipv4 show subinterfaces<br></code></pre></td></tr></table></figure></li><li><p>输入以下命令，修改MTU</p></li></ol>   <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">netsh interface ipv4 <span class="hljs-built_in">set</span> subinterface &quot;需修改的连接名&quot; mtu=<span class="hljs-number">9100</span> store=persistent<br></code></pre></td></tr></table></figure><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231107131449090.png" alt="image-20231107131449090"></p><h3 id="配置有线连接的其他真机与本地真机的gns3vm的sonic路由通信">配置有线连接的其他真机与本地真机的gns3vm的sonic路由通信</h3><h4 id="配置有线连接的其他真机与本地真机">配置有线连接的其他真机与本地真机</h4><ol><li>修改对应网卡上的ipv4配置即可，另两个网卡的ip地址在同一个网段下。</li></ol><h4 id="配置本地真机与虚拟机">配置本地真机与虚拟机</h4><p>因为本项目是在vm上的gns3，所以要去修改vm的网络适配器，而不是在gns3的设置中去增加vmnet5,6,7…并添加到云的特殊接口上去配置（虽然可能也行，但没寻找到成功的方法）。故需要去配置vmware上的网络适配器。</p><ol><li><p>在vmware虚拟网络编辑器上编辑桥接模式的vmnet0，需要选择为本机网线连接的那个网卡。</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231102144701101.png" alt="image-20231102144701101"></p></li><li><p>在gns的虚拟机设置中增加桥接模式的网络适配器，不需要选择复制物理网络连接状态（复制物理网络连接状态是供移动端，无线网络选择的）下图已经添加好了。且注意网络适配器就是云上的eth0，而网络适配器2就是云上的eth1，以此类推。</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231102145308528.png" alt="image-20231102145308528"></p></li><li><p>进入gns3的命令行，按[4.2 gns3vm配置网卡](# gns3vm（ubuntu20.04）配置网卡)的方式去配置新增加的桥接模式的网卡，这里是eth2。</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231102150102198.png" alt="image-20231102150102198"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240325163606930.png" alt="image-20240325163606930"></p></li><li><p>配置sonic路由器的相应接口ip在同一个网段。</p></li><li><p>大功告成，应该可以ping通了，确保防火墙是关闭的状态。</p></li></ol><h4 id="配置ospf或本地静态路由"><s>配置ospf或</s>本地静态路由</h4><ul><li><p>当本地作为服务器时，去配置gns3上的sonic路由器即可，参考<a href="#%E9%85%8D%E7%BD%AEospf">配置ospf</a>。</p></li><li><p>当本地作为终端时，有两种配置方法</p><ul><li><p>在网卡ipv4的配置中，添加默认网关。注意默认网关不是网线另一端的ip，而是网线另一端的gns3上桥接的路由器ip。</p></li><li><p>添加静态路由，参考<a href="#windows%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1">windows配置静态路由</a>，同样注意下一跳不是网线另一端的ip，而是网线另一端的gns3上桥接的路由器ip。如下图中下一跳是10.2.3.2，而不是10.2.3.20</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231106183417418.png" alt="image-20231106183417418"></p></li></ul></li></ul><p>更新：<s>通过修改windows和vmware的MTU的方法，配置ISIS即可。当然，配置本地静态路由还是需要的。</s></p><p><s>参考<a href="#gns3vm%EF%BC%88ubuntu20.04%EF%BC%89%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1">gns3vm配置网卡</a>和<a href="#windows%E9%85%8D%E7%BD%AEMTU">配置windows的mtu</a></s></p><p>通过修改sonic路由的mtu，配置isis即可。</p><ol start="2"><li></li></ol><h3 id="NAT">NAT</h3><p>gns3NAT自带云中所分配的ip和virbr0所属同一个网段。修改可参考下面网站</p><p><a href="https://www.jianshu.com/p/9cce35733e00">命令行如何修改KVM生产的virbr0的地址 - 简书 (jianshu.com)</a></p><ol><li><p>default.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"> vim /etc/libvirt/qemu/networks/default.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">network</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">uuid</span>&gt;</span>d63fbb69-44f0-4f7a-a001-af50092204e8<span class="hljs-tag">&lt;/<span class="hljs-name">uuid</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">forward</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&#x27;nat&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bridge</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;virbr0&#x27;</span> <span class="hljs-attr">stp</span>=<span class="hljs-string">&#x27;on&#x27;</span> <span class="hljs-attr">delay</span>=<span class="hljs-string">&#x27;0&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mac</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&#x27;52:54:00:36:44:41&#x27;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ip</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&#x27;192.168.122.1&#x27;</span> <span class="hljs-attr">netmask</span>=<span class="hljs-string">&#x27;255.255.255.0&#x27;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dhcp</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">range</span> <span class="hljs-attr">start</span>=<span class="hljs-string">&#x27;192.168.122.2&#x27;</span> <span class="hljs-attr">end</span>=<span class="hljs-string">&#x27;192.168.122.254&#x27;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dhcp</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ip</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">network</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改并生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#修改配置文件</span><br>sed -i <span class="hljs-string">&#x27;s/192.168.122/192.168.8/g&#x27;</span> /etc/libvirt/qemu/networks/default.xml<br><span class="hljs-comment">#定义网络</span><br>virsh  net-define /etc/libvirt/qemu/network/default.xml<br><span class="hljs-comment">#停止default网络</span><br>virsh  net-destroy default  <br><span class="hljs-comment">#启动default网络</span><br>virsh  net-start  default<br><span class="hljs-comment">#重启libvirtd</span><br>systemctl restart libvirtd<br></code></pre></td></tr></table></figure></li></ol><hr><p>xml文件的相关解释</p><p><a href="https://www.jianshu.com/p/eac28b175161">libvirt xml文件解析 – Devices - 简书 (jianshu.com)</a></p><blockquote><p><a href="https://documentation.suse.com/zh-cn/sles/15-SP2/html/SLES-all/cha-libvirt-networks.html">SLES 15 SP2 | 虚拟化指南 | 管理网络 (suse.com)</a></p><p>包含 <forward> 元素表示该虚拟网络将连接到物理 LAN。<code>mode</code> 属性指定转发方法。最常用的模式为“nat”（默认模式，表示网络地址转换）、“route”（直接转发到物理网络，不执行地址转换）和“bridge”（在 <code>libvirt</code> 外部配置的网桥）。如果不指定 <forward> 元素，虚拟网络将与其他网络相隔离。有关转发模式的完整列表，请参见 <a href="http://libvirt.org/formatnetwork.html#elementsConnect%E3%80%82">http://libvirt.org/formatnetwork.html#elementsConnect。</a></forward></forward></p></blockquote><h3 id="gns3中导入vmware虚拟机">gns3中导入vmware虚拟机</h3><p><a href="https://docs.gns3.com/docs/emulators/adding-vmware-vms-to-gns3-topologies/">Adding VMware VMs to GNS3 Topologies | GNS3 Documentation</a></p><p>几个要点：</p><ol><li><p>当vmware创建时，需要勾选不使用网络连接。</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240112201139468.png" alt="image-20240112201139468"></p></li><li><p>gns3导入虚拟机后，勾选下面选项。</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240112201243723.png" alt="image-20240112201243723"></p></li><li><p>记得使用gns3去创建vmnet，点击下图configure。</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240112201412783.png" alt="image-20240112201412783"></p></li><li><p>vmware workstation的安装位置应是默认的，这样gns3才能找到。</p></li><li><p>若gns3路由和vm虚拟机直连无法ping通，尝试将对应的vmnet的mtu和子网域改成一致的。</p></li></ol><h3 id="增加gns3vm-的内存">增加gns3vm 的内存</h3><p>setup wizard</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240318150055618.png" alt="image-20240318150055618"></p><h3 id="解决gns3-eth0未配置">解决gns3 eth0未配置</h3><p><a href="https://blog.csdn.net/m0_37828989/article/details/112908637">GNS3 Network Emulator 使用（一）_eth0 is not configured-CSDN博客</a></p><h3 id="疑难杂症">疑难杂症</h3><ol><li><p><strong>链路已经存在</strong></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231107121044655.png" alt="image-20231107121044655"></p><p>解决办法：关闭gns3再打开即可。</p></li><li><p>一些网上搜的linux的东西，sonic路由器上没有</p><p>解决办法，进入<code>/usr/bin/docker exec -it bgp /bin/bash</code>不知道叫什么模式，再试试。</p></li><li><p><strong>桥接好网络后，一配置isis协议就导致桥接的直连网无法ping通。</strong></p><p>解决方法：</p><p>发现通过<code>ping -s 1500 ip</code>的命令也会导致桥接的直连网无法ping通，故怀疑是MTU的设置问题，查看sonic路由上的MTU设置，进入<code>/usr/bin/docker exec -it bgp /bin/bash</code>不知道叫什么模式，输入<code>ifconfig</code>查看MTU，发现是9100，而桥接网卡的MTU是默认值1500</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231107130258825.png" alt="image-20231107130258825"></p><p><s>故参照<a href="#gns3vm%EF%BC%88ubuntu20.04%EF%BC%89%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1">gns3vm配置网卡</a>，修改<code>00-installer-config.yaml</code>内容，配置MTU，如下</s></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231107130825682.png" alt="image-20231107130825682"></p><p><s>同样，<code>sudo netplan apply</code>使配置生效。</s></p><p><s>然后也需要<a href="#windows%E9%85%8D%E7%BD%AEMTU">配置windows的mtu</a>，即这条逻辑网线上的网卡的MTU都应该是9100（以sonic路由器为准）。</s></p><p>以sonic路由器的9100为准会出现问题，例如有的设备无法设置mtu为9100，太大了。故使用命令去修改sonic的mtu更好</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo config inter mtu Ethernet0 1500<br></code></pre></td></tr></table></figure></li><li><p>windows联网状态下怎么确定<code>10.1.2.1</code>是sonic路由器的，而不是某个公网。</p><p>解决方法：通过<code>ping ip -S (指定网卡ip)</code>来指定网卡发送ping包。</p></li><li><p>isis路由inactive</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker restart bgp  <br></code></pre></td></tr></table></figure></li><li><p>gns3vm的cpu利用率很高，但主机cpu利用率却不高。</p><p>解决方法：降低路由器vcpu的数量，太多切换线程反而浪费资源。</p></li><li><p>断电后gns3vm崩溃</p><p><a href="https://blog.csdn.net/weixin_43567724/article/details/107213815">linux下硬盘修复：you are in emergency mode…_you are in emergency mode cdrom挂载失败-CSDN博客</a></p></li></ol><h2 id="linux-宿主机">linux 宿主机</h2><h3 id="通过网线拷贝windows文件">通过网线拷贝windows文件</h3><ol><li><p>配置两端ip在同一网段，能互相ping通。</p></li><li><p>windows中将文件设为共享，增加权限。</p></li><li><p>linux进行如下操作</p><ol><li><p>安装smbclient和cifs-utils，cifs是网络文件系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt install smbclient cifs-utils<br></code></pre></td></tr></table></figure></li><li><p>创建挂载点，文件名可更换。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> /mnt/smb<br></code></pre></td></tr></table></figure></li><li><p>挂载windows共享文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mount -t cifs -o username=<span class="hljs-string">&quot;windos用户名&quot;</span>,password=<span class="hljs-string">&quot;windows密码&quot;</span> //windows_ip/共享文件路径 /mnt/smb<br></code></pre></td></tr></table></figure></li></ol></li><li><p>然后即可复制文件</p></li></ol><h3 id="利用scp传输文件">利用scp传输文件</h3><p><a href="https://cloud.tencent.com/developer/article/2292900">如何在Linux系统中使用SCP命令传输文件和文件夹？-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h3 id="查看配置ipv4，ipv6路由">查看配置ipv4，ipv6路由</h3><p><a href="https://blog.csdn.net/LJ511100/article/details/123851574">linux和windows配置IPV4/IPV6地址、静态路由、查看路由、ping命令_ipv4和ipv6怎么ping-CSDN博客</a></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240108210707405.png" alt="image-20240108210707405"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240108210729069.png" alt="image-20240108210729069"></p><ul><li><p>驭数终端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo ip addr add 192.168.10.103/24 dev eth1<br>sudo ip addr del 192.168.10.103/24 dev eth1<br>重启网络服务<br></code></pre></td></tr></table></figure></li></ul><h3 id="重启网络服务">重启网络服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo service networking restart<br></code></pre></td></tr></table></figure><h3 id="无管理口，重启dhcp">无管理口，重启dhcp</h3><p>使用dhclient命令分配ip</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo dhclient eth0<br></code></pre></td></tr></table></figure><h3 id="修改dns">修改dns</h3><ol><li><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/resolv.conf<br></code></pre></td></tr></table></figure></li><li><p>重启网络服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo systemctl restart networking.service<br></code></pre></td></tr></table></figure></li></ol><h3 id="一键换国内源">一键换国内源</h3><p><a href="https://www.cnblogs.com/liuguanglin/p/debian11_repo.html">Debian 11 (bullseye) 国内软件源 - Guanglin - 博客园 (cnblogs.com)</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sed -i <span class="hljs-string">&quot;s@http://\(deb\|security\).debian.org@https://mirrors.tencent.com@g&quot;</span> /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>不行换这个</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib<br>deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib<br>deb https://mirrors.aliyun.com/debian-security/ bullseye-security main<br>deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main<br>deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib<br>deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib<br>deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib<br>deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib<br></code></pre></td></tr></table></figure><h3 id="ubuntu16-04系统时间错误导致wifi登录认证失败">ubuntu16.04系统时间错误导致wifi登录认证失败</h3><p>[12.10 - How to fix wrong system time and date? - Ask Ubuntu](<a href="https://askubuntu.com/questions/214246/how-to-fix-wrong-system-time-and-date#:~:text=This">https://askubuntu.com/questions/214246/how-to-fix-wrong-system-time-and-date#:~:text=This</a> works for Ubuntu 16.04 Stop the ntp,if not just do sudo apt-get install ntp)</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20240415105954981.png" alt="image-20240415105954981"></p><h3 id="linux内核不支持ipv6">linux内核不支持ipv6</h3><p><a href="https://www.cnblogs.com/5201351/p/17122078.html">关于Linux从内核启动选项中开启对ipv6的支持 - 520_1351 - 博客园 (cnblogs.com)</a></p><p>体现为输入<code>route -A inet6</code>命令时显示<code>not supported</code>字样。</p><p>解决方法：修改文件<code>/boot/grub2/grubenv</code>或<code>/boot/grub/grub.cfg</code>中的<code>ipv6.disable=1</code>为<code>ipv6.disab</code></p><p><code>le=0</code>。</p><h3 id="ipv6默认地址">ipv6默认地址</h3><p>ipv6默认地址（fe80开头）不能删除，会影响ipv6 isis的正常运行。fe80开头是全球单播链路地址啥的</p><h3 id="安装gcc，gdb，g-make">安装gcc，gdb，g++,make</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># build包含g++，gcc，make</span><br>sudo apt-get install build-essential <br>sudo apt-get install gdb<br></code></pre></td></tr></table></figure><h3 id="make小妙招">make小妙招</h3><p>可以看make install实际上执行了什么命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make install --just-print<br></code></pre></td></tr></table></figure><h3 id="sonic-p4版本无法进行apt-get-update操作">sonic-p4版本无法进行apt-get update操作</h3><p>下载源已过期，更换下载源为</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">deb http://snapshot.debian.org/archive/debian/20210326T030000Z jessie main<br></code></pre></td></tr></table></figure><h3 id="ubuntu盒盖不休眠">ubuntu盒盖不休眠</h3><p><a href="https://blog.csdn.net/aaaccc444/article/details/135211422?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-135211422-blog-114102284.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">Ubuntu20.04-设置合上盖子电脑不熄屏，不休眠等_ubuntu设置合盖运行-CSDN博客</a></p><h3 id="更换python版本">更换python版本</h3><p><a href="https://blog.csdn.net/qq_43744723/article/details/122090500">Ubuntu下完美切换Python版，即设置系统默认的python版本(亲测有效)_ubuntu如何使用默认python3.9-CSDN博客</a></p><h3 id="linux环境离线安装apt库">linux环境离线安装apt库</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># https://packages.debian.org/sid/cloud-guest-utils</span><br><span class="hljs-comment"># https://ubuntu.pkgs.org/20.04/ubuntu-universe-amd64/vlc_3.0.9.2-1_amd64.deb.html</span><br>sudo dpkg -i<br></code></pre></td></tr></table></figure><h3 id="linux中如何安装-deb文件">linux中如何安装.deb文件</h3><ol><li>下载Debian程序的.deb文件，例如hello.deb。</li><li>打开终端并切换到.deb文件所在的目录。</li><li>运行以下命令来安装.deb文件：<br><code>sudo dpkg -i hello.deb</code></li><li>如果出现依赖性错误，请运行以下命令来安装缺少的依赖项：<br><code>sudo apt-get install -f</code></li><li>运行程序：<br><code>hello</code></li></ol><h3 id="linux环境离线安装python第三方库">linux环境离线安装python第三方库</h3><ol><li><a href="https://pypi.org/%E7%BD%91%E7%AB%99%E6%90%9C%E7%B4%A2setuptools%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%60tar.gz%60%E6%96%87%E4%BB%B6%E3%80%82">https://pypi.org/网站搜索setuptools，下载对应`tar.gz`文件。</a></li><li>将该文件传输到linux环境中。</li><li>解压：<code>tar -zxvf *.tar.gz</code></li><li>进入解压目录，运行命令：<code>sudo python setup.py install</code></li><li>类似前四步，下载其他第三方库。需要先下载setuptools才能这样下载其他第三方库。</li></ol><p>如果上面方法不行，但包存在<code>.whl</code>文件的话，可以尝试一下能否下载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo pip3 install *.whl<br></code></pre></td></tr></table></figure><h2 id="远程连接">远程连接</h2><h3 id="mobaXterm远程连接vnc">mobaXterm远程连接vnc</h3><p><a href="https://blog.csdn.net/oushaojun2/article/details/134184994">MobaXterm使用VNC远程显示和控制ubuntu桌面_ubuntu远程工具mobaxterm连接-CSDN博客</a></p><h3 id="ubuntu18-04开启vnc">ubuntu18.04开启vnc</h3><p><a href="https://blog.csdn.net/langyou0/article/details/107959002">Ubuntu18.04 最简单远程桌面_ubuntu18.04远程登录vnc-CSDN博客</a></p><h3 id="ubuntu系统下todesk无法联网">ubuntu系统下todesk无法联网</h3><p><a href="https://blog.csdn.net/qq_41786546/article/details/135255189">Ubuntu系统Todesk远程控制：网络连接不上问题解决办法_ubuntu todesk 无法联网-CSDN博客</a></p><ol><li>先关闭todesk</li><li>命令行关闭服务：sudo systemctl stop todeskd.service</li><li>找到 /opt/todesk/config/todeskd.conf 这个文件，并将其删除(sudo rm -r 文件名”)，</li><li>命令行重新启动服务：sudo systemctl start todeskd.service</li><li>重新启动todesk。</li></ol><h3 id="ssh-zerotier远程连接">ssh &amp; zerotier远程连接</h3><p><a href="https://blog.csdn.net/pariese/article/details/111604340">Windows 10 开启ssh服务_windows ssh-CSDN博客</a></p><ol><li>ssh需要在同一网段下连接，否则需要内网穿透（将你的个人ip暴露在互联网中）。</li><li>ssh有用户密码和公钥私钥两种验证方式。</li></ol><hr><p>想到新方法，利用蒲公英组网（这是之前打游戏的方案XD）</p><ol><li><p>下载蒲公英客户端<a href="https://pgy.oray.com/download/">贝锐蒲公英软件客户端最新版官方下载，蒲公英联机组网平台软件下载 - 贝锐蒲公英官网 (oray.com)</a></p></li><li><p>登录账号</p><p>uid: 55384583:004</p><p>password: admin1</p></li><li><p>ssh连接宿主机</p></li><li><p>ssh连接路由器和终端</p></li></ol><hr><p>会出现ping不通但能ssh通的情况，这是防ping策略。</p><hr><p>更好的组网，免费版支持25个用户。</p><p><a href="https://blog.csdn.net/qq_44928822/article/details/128777173?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-128777173-blog-119845679.235%5Ev39%5Epc_relevant_default_base&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">【Linux简单入门】006SSH远程连接，内网穿透_ssh 内网穿透-CSDN博客</a></p><ol><li><p><a href="https://www.zerotier.com/">zerotier用户中心</a>创建用户，新建networks，获取<code>Network ID</code></p></li><li><p>下载客户端并加入网络</p><ul><li><p>windows</p><ol><li><p>下载zerotier[<a href="https://www.zerotier.com/download/">Download (zerotier.com)</a>](<a href="https://pgy.oray.com/download/">https://pgy.oray.com/download/</a>)</p></li><li><p>点击join new network</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20231214121742240.png" alt="image-20231214121742240"></p></li><li><p>输入<code>Network ID</code></p></li></ol></li><li><p>linux</p><ol><li><p>输入以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 下载zerotier客户端</span><br>curl -s https://install.zerotier.com | sudo bash<br><span class="hljs-comment"># 加入刚刚创建的网络</span><br>sudo zerotier-cli <span class="hljs-built_in">join</span> b6079f73c60b1fdf<br></code></pre></td></tr></table></figure></li><li><p>其他相关命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 其他命令</span><br><span class="hljs-comment"># 加入刚刚创建的网络</span><br>sudo zerotier-cli <span class="hljs-built_in">join</span> Network ID<br><span class="hljs-comment">#离开</span><br>sudo zerotier-cli leave Network ID<br><span class="hljs-comment">#连接列表</span><br>sudo zerotier-cli listnetworks<br><span class="hljs-comment"># 启动</span><br>sudo systemctl start zerotier-one.service<br><span class="hljs-comment"># 停止</span><br>sudo systemctl stop zerotier-one.service<br><span class="hljs-comment"># 打开开机自启</span><br>sudo systemctl <span class="hljs-built_in">enable</span> zerotier-one.service<br><span class="hljs-comment"># 关闭开机自启</span><br>sudo systemctl <span class="hljs-built_in">disable</span> zerotier-one.service<br></code></pre></td></tr></table></figure></li></ol></li></ul></li></ol><h3 id="能ping通但不能SSH">能ping通但不能SSH</h3><ol><li>检查需要SSH的机器有没有开启ssh服务，ubuntu需要下载openssh-server</li><li>保持mtu一致</li></ol><h3 id="windows中ssh注意事项">windows中ssh注意事项</h3><ol><li><p>windows作为服务器需要开启openssh server，在管理员模式下的powershell下输入以下指令。参考<a href="https://www.cnblogs.com/suv789/p/18635440">在 Windows 10 和 Windows 11 中，可以使用 OpenSSH 来进行 SSH 连接和远程管理。Windows 10 和 Windows 11 都已经内置了 OpenSSH 客户端和服务器，因此无需安装额外的第三方 SSH 工具。你可以通过命令行工具（如 PowerShell 或 Command Prompt）来使用 OpenSSH。 - suv789 - 博客园</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 OpenSSH 服务器</span><br>Add-WindowsFeature -Name OpenSSH.Server<br><br><span class="hljs-comment"># 启动并设置 OpenSSH 服务器开机自启</span><br>Start-Service sshd<br>Set-Service -Name sshd -StartupType <span class="hljs-string">&#x27;Automatic&#x27;</span><br><br><span class="hljs-comment"># 配置防火墙以允许 SSH 连接</span><br>New-NetFirewallRule -Name sshd -DisplayName <span class="hljs-string">&#x27;OpenSSH Server (sshd)&#x27;</span> -Enabled True -Protocol TCP -Action Allow -LocalPort 22<br></code></pre></td></tr></table></figure></li><li><p>windows的ssh会因为你的windows主机是否登录了微软账号而采取不同的验证账户：如果登录，则使用微软的用户名（即命令行里看到的用户名）和密码；如果未登录，则使用登录界面使用的用户名和PIN码即可登录。</p></li><li><p>若使用微软账号却又不知道其密码，可以使用公钥来配置免密登录，参考<a href="https://zhuanlan.zhihu.com/p/111812831">多台WIN10之间的SSH免密登录 - 知乎</a></p><ol><li><p>在客户端使用<code>ssh-keygen -t rsa</code>生成公钥，将<code>C:\Users\your_userName\.ssh</code>里的<code>id_rsa.pub</code>中的内容复制，这是客户端的公钥。</p></li><li><p>将客户端的公钥复制到<code>C:\Users\your_userName\.ssh\authorized_keys</code>，没有则创建。</p></li><li><p>修改<code>C:\Programdata\ssh\sshd_config</code>文件内容。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># Start-Process Notepad C:\Programdata\ssh\sshd_config</span><br><br><span class="hljs-comment">#确保以下3条没有被注释</span><br>PubkeyAuthentication <span class="hljs-built_in">yes</span><br>AuthorizedKeysFile.ssh/authorized_keys<br>PasswordAuthentication no<br><br><span class="hljs-comment">#确保以下2条有注释掉</span><br><span class="hljs-comment">#Match Group administrators</span><br><span class="hljs-comment">#       AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys</span><br></code></pre></td></tr></table></figure></li><li><p>重启sshd，<code>Restart-Service sshd</code></p></li></ol></li></ol><h3 id="ssh虚拟机ubuntu">ssh虚拟机ubuntu</h3><p>虚拟机采用桥接模式，桥接到宿主机的无线网卡，注意需要选择<code>复制物理网络状态</code>这个选项。然后在ubuntu虚拟机中分配wifi的ip地址，在同一局域网的其他主机就可以ssh了（虚拟机需要配置ssh server）。</p><h2 id="QEMU">QEMU</h2><ol><li><p>gns3qemu命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/bin/qemu-system-x86_64 -name sonic-vs-6 -m 4096M -smp cpus=2,sockets=1 -enable-kvm -machine smm=off -boot order=d -drive file=/home/bupt/GNS3/projects/TILFA/project-files/qemu/1677e622-9ecc-40bc-a09e-3d3c4cd0f88b/hda_disk.qcow2,<span class="hljs-keyword">if</span>=virtio,index=0,media=disk,<span class="hljs-built_in">id</span>=drive0 -uuid 1677e622-9ecc-40bc-a09e-3d3c4cd0f88b -serial telnet:127.0.0.1:5011,server,nowait -monitor tcp:127.0.0.1:41753,server,nowait -net none <br>-device e1000,mac=0c:77:e6:22:00:00,netdev=gns3-0 -netdev socket,<span class="hljs-built_in">id</span>=gns3-0,udp=127.0.0.1:10117,localaddr=127.0.0.1:10116 <br>-device e1000,mac=0c:77:e6:22:00:01,netdev=gns3-1 -netdev socket,<span class="hljs-built_in">id</span>=gns3-1,udp=127.0.0.1:10119,localaddr=127.0.0.1:10118 <br>-device e1000,mac=0c:77:e6:22:00:02,netdev=gns3-2 -netdev socket,<span class="hljs-built_in">id</span>=gns3-2,udp=127.0.0.1:10121,localaddr=127.0.0.1:10120 <br>-device e1000,mac=0c:77:e6:22:00:03,netdev=gns3-3 -netdev socket,<span class="hljs-built_in">id</span>=gns3-3,udp=127.0.0.1:10123,localaddr=127.0.0.1:10122 <br>-device e1000,mac=0c:77:e6:22:00:04,netdev=gns3-4 -netdev socket,<span class="hljs-built_in">id</span>=gns3-4,udp=127.0.0.1:10125,localaddr=127.0.0.1:10124 <br>-device e1000,mac=0c:77:e6:22:00:05,netdev=gns3-5 -netdev socket,<span class="hljs-built_in">id</span>=gns3-5,udp=127.0.0.1:10127,localaddr=127.0.0.1:10126 <br>-device e1000,mac=0c:77:e6:22:00:06,netdev=gns3-6 -netdev socket,<span class="hljs-built_in">id</span>=gns3-6,udp=127.0.0.1:10129,localaddr=127.0.0.1:10128 <br>-device e1000,mac=0c:77:e6:22:00:07,netdev=gns3-7 -netdev socket,<span class="hljs-built_in">id</span>=gns3-7,udp=127.0.0.1:10131,localaddr=127.0.0.1:10130 <br>-device e1000,mac=0c:77:e6:22:00:08,netdev=gns3-8 -netdev socket,<span class="hljs-built_in">id</span>=gns3-8,udp=127.0.0.1:10133,localaddr=127.0.0.1:10132 <br>-device e1000,mac=0c:77:e6:22:00:09,netdev=gns3-9 -netdev socket,<span class="hljs-built_in">id</span>=gns3-9,udp=127.0.0.1:10135,localaddr=127.0.0.1:10134 -display none<br></code></pre></td></tr></table></figure></li><li><p>多网卡qemu命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">qemu-system-x86_64 -enable-kvm -cpu host -nographic -name sonic-simulator_1 -m 2048M -smp cpus=2 -drive file=sonic-vs-2.img,index=0,media=disk,<span class="hljs-built_in">id</span>=drive0 -serial telnet:127.0.0.1:5002,server,nowait -monitor tcp:127.0.0.1:44002,server,nowait -net nic,macaddr=52:54:00:12:34:20 -net tap,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown<br><br>++ ifconfig<br>++ grep -ci br0<br>+ br0_exist_flag=2<br>+ <span class="hljs-string">&#x27;[&#x27;</span> 2 -eq 0 <span class="hljs-string">&#x27;]&#x27;</span><br>+ sudo tunctl -t tap3 -u root<br>TUNSETIFF: Device or resource busy<br>+ sudo ifconfig tap3 up<br>+ sudo brctl addif br0 tap3<br></code></pre></td></tr></table></figure></li></ol><h3 id="qemu联网">qemu联网</h3><p><a href="https://blog.csdn.net/a985588764/article/details/129685202">如何配置 QEMU 虚拟机网络_qemu虚拟机网络配置-CSDN博客</a></p><p><a href="https://blog.csdn.net/cuigelasi/article/details/78417027">centos7 删除网桥和网卡_centos删除网桥-CSDN博客</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt-get install bridge-utils        <span class="hljs-comment"># 虚拟网桥工具</span><br><br>ifconfig &lt;你的网卡名称(能上网的那张)&gt; down    <span class="hljs-comment"># 首先关闭宿主机网卡接口</span><br>brctl addbr br0                     <span class="hljs-comment"># 添加名为 br0 的网桥</span><br>brctl addif br0 &lt;你的网卡名称&gt;        <span class="hljs-comment"># 在 br0 中添加一个接口</span><br>brctl stp br0 off                   <span class="hljs-comment"># 如果只有一个网桥，则关闭生成树协议</span><br>brctl setfd br0 1                   <span class="hljs-comment"># 设置 br0 的转发延迟</span><br>brctl sethello br0 1                <span class="hljs-comment"># 设置 br0 的 hello 时间</span><br>ifconfig br0 0.0.0.0 promisc up     <span class="hljs-comment"># 启用 br0 接口</span><br>ifconfig &lt;你的网卡名称&gt; 0.0.0.0 promisc up    <span class="hljs-comment"># 启用网卡接口</span><br>dhclient br0                        <span class="hljs-comment"># 从 dhcp 服务器获得 br0 的 IP 地址</span><br>brctl show br0                      <span class="hljs-comment"># 查看虚拟网桥列表</span><br>brctl showstp br0                   <span class="hljs-comment"># 查看 br0 的各接口信息</span><br><br>tunctl -t tap0 -u root              <span class="hljs-comment"># 创建一个 tap0 接口，只允许 root 用户访问</span><br>brctl addif br0 tap0                <span class="hljs-comment"># 在虚拟网桥中增加一个 tap0 接口</span><br>ifconfig tap0 0.0.0.0 promisc up    <span class="hljs-comment"># 启用 tap0 接口</span><br>brctl showstp br0                   <span class="hljs-comment"># 显示 br0 的各个接口</span><br><br>sudo iptables -t nat -A POSTROUTING -o br0 -j MASQUERADE <span class="hljs-comment">#配置NAT，否则qemu将无法ping通baidu.com，但是能解析域名。这条规则的意思是，来自 192.168.5.0/24，且从 ens33 出去的包，要进行 NAT，同时会对返回的包进行 NAT。如果只有一个子网， -s 192.168.5.0/24 可以省略。若要删除该规则，将-A 改为 -D 即可</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Mculover666/article/details/105664454">Qemu连接外网的配置方法_qemu虚拟机 net访问-CSDN博客</a></p><h3 id="qemu配置qemu-ifup使用nat联网">qemu配置qemu-ifup使用nat联网</h3><p><a href="https://wiki.qemu.org/Documentation/Networking/NAT">Documentation/Networking/NAT - QEMU</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Copyright IBM, Corp. 2010  </span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Authors:</span><br><span class="hljs-comment">#  Anthony Liguori &lt;aliguori@us.ibm.com&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This work is licensed under the terms of the GNU GPL, version 2.  See</span><br><span class="hljs-comment"># the COPYING file in the top-level directory.</span><br><br><span class="hljs-comment"># Set to the name of your bridge</span><br>BRIDGE=br0<br><br><span class="hljs-comment"># Network information</span><br>NETWORK=192.168.53.0<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.53.1<br>DHCPRANGE=192.168.53.2,192.168.53.254<br><br><span class="hljs-comment"># Optionally parameters to enable PXE support</span><br>TFTPROOT=<br>BOOTP=<br><br><span class="hljs-function"><span class="hljs-title">do_brctl</span></span>() &#123;<br>    brctl <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">do_ifconfig</span></span>() &#123;<br>    ifconfig <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">do_dd</span></span>() &#123;<br>    <span class="hljs-built_in">dd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">do_iptables_restore</span></span>() &#123;<br>    iptables-restore <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">do_dnsmasq</span></span>() &#123;<br>    dnsmasq <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">check_bridge</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> do_brctl show | grep <span class="hljs-string">&quot;^<span class="hljs-variable">$1</span>&quot;</span> &gt; /dev/null 2&gt; /dev/null; <span class="hljs-keyword">then</span><br><span class="hljs-built_in">return</span> 1<br>    <span class="hljs-keyword">else</span><br><span class="hljs-built_in">return</span> 0<br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">create_bridge</span></span>() &#123;<br>    do_brctl addbr <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    do_brctl stp <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> off<br>    do_brctl setfd <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 0<br>    do_ifconfig <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$GATEWAY</span>&quot;</span> netmask <span class="hljs-string">&quot;<span class="hljs-variable">$NETMASK</span>&quot;</span> up<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">enable_ip_forward</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> 1 | do_dd of=/proc/sys/net/ipv4/ip_forward &gt; /dev/null<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">add_filter_rules</span></span>() &#123;<br>do_iptables_restore &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string"># Generated by iptables-save v1.3.6 on Fri Aug 24 15:20:25 2007</span><br><span class="hljs-string">*nat</span><br><span class="hljs-string">:PREROUTING ACCEPT [61:9671]</span><br><span class="hljs-string">:POSTROUTING ACCEPT [121:7499]</span><br><span class="hljs-string">:OUTPUT ACCEPT [132:8691]</span><br><span class="hljs-string">-A POSTROUTING -s $NETWORK/$NETMASK -j MASQUERADE </span><br><span class="hljs-string">COMMIT</span><br><span class="hljs-string"># Completed on Fri Aug 24 15:20:25 2007</span><br><span class="hljs-string"># Generated by iptables-save v1.3.6 on Fri Aug 24 15:20:25 2007</span><br><span class="hljs-string">*filter</span><br><span class="hljs-string">:INPUT ACCEPT [1453:976046]</span><br><span class="hljs-string">:FORWARD ACCEPT [0:0]</span><br><span class="hljs-string">:OUTPUT ACCEPT [1605:194911]</span><br><span class="hljs-string">-A INPUT -i $BRIDGE -p tcp -m tcp --dport 67 -j ACCEPT </span><br><span class="hljs-string">-A INPUT -i $BRIDGE -p udp -m udp --dport 67 -j ACCEPT </span><br><span class="hljs-string">-A INPUT -i $BRIDGE -p tcp -m tcp --dport 53 -j ACCEPT </span><br><span class="hljs-string">-A INPUT -i $BRIDGE -p udp -m udp --dport 53 -j ACCEPT </span><br><span class="hljs-string">-A FORWARD -i $1 -o $1 -j ACCEPT </span><br><span class="hljs-string">-A FORWARD -s $NETWORK/$NETMASK -i $BRIDGE -j ACCEPT </span><br><span class="hljs-string">-A FORWARD -d $NETWORK/$NETMASK -o $BRIDGE -m state --state RELATED,ESTABLISHED -j ACCEPT </span><br><span class="hljs-string">-A FORWARD -o $BRIDGE -j REJECT --reject-with icmp-port-unreachable </span><br><span class="hljs-string">-A FORWARD -i $BRIDGE -j REJECT --reject-with icmp-port-unreachable </span><br><span class="hljs-string">COMMIT</span><br><span class="hljs-string"># Completed on Fri Aug 24 15:20:25 2007</span><br><span class="hljs-string">EOF</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">start_dnsmasq</span></span>() &#123;<br>    do_dnsmasq \<br>--strict-order \<br>--except-interface=lo \<br>--interface=<span class="hljs-variable">$BRIDGE</span> \<br>--listen-address=<span class="hljs-variable">$GATEWAY</span> \<br>--bind-interfaces \<br>--dhcp-range=<span class="hljs-variable">$DHCPRANGE</span> \<br>--conf-file=<span class="hljs-string">&quot;&quot;</span> \<br>--pid-file=/var/run/qemu-dnsmasq-<span class="hljs-variable">$BRIDGE</span>.pid \<br>--dhcp-leasefile=/var/run/qemu-dnsmasq-<span class="hljs-variable">$BRIDGE</span>.leases \<br>--dhcp-no-override \<br><span class="hljs-variable">$&#123;TFTPROOT:+&quot;--enable-tftp&quot;&#125;</span> \<br><span class="hljs-variable">$&#123;TFTPROOT:+&quot;--tftp-root=$TFTPROOT&quot;&#125;</span> \<br><span class="hljs-variable">$&#123;BOOTP:+&quot;--dhcp-boot=$BOOTP&quot;&#125;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">setup_bridge_nat</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> check_bridge <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ; <span class="hljs-keyword">then</span><br>create_bridge <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>enable_ip_forward<br>add_filter_rules <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>start_dnsmasq <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">setup_bridge_vlan</span></span>() &#123;<br>    <span class="hljs-keyword">if</span> check_bridge <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ; <span class="hljs-keyword">then</span><br>create_bridge <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>start_dnsmasq <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-keyword">fi</span><br>&#125;<br><br>setup_bridge_nat <span class="hljs-string">&quot;<span class="hljs-variable">$BRIDGE</span>&quot;</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ; <span class="hljs-keyword">then</span><br>    do_ifconfig <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 0.0.0.0 up<br>    do_brctl addif <span class="hljs-string">&quot;<span class="hljs-variable">$BRIDGE</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="iperf测试">iperf测试</h3><p>qemu sonic eth0-eth0</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241021144217029.png" alt="image-20241021144217029"></p><p>qemu sonic eth0-eth0 promisc模式下</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125155602492.png" alt="image-20241125155602492"></p><p>gns3 sonic eth0-eth0</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125160521387.png" alt="image-20241125160521387"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125160616662.png" alt="image-20241125160616662"></p><p>gns3 sonic-vpp eth0-eth0</p><p><a href="https://ronnievsmith.medium.com/sonic-virtual-switch-with-fd-ios-vector-packet-processor-vpp-on-google-cloud-89f9c62f5fe3">SONiC Virtual Switch with FD.io Vector Packet Processor (VPP) on Google Cloud | by Ronnie Smith | Oct, 2024 | Medium</a></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125161215585.png" alt="image-20241125161215585"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125161236418.png" alt="image-20241125161236418"></p><p>gns3 sonic Ethernet0-Ethernet0</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241021144643328.png" alt="image-20241021144643328"></p><p>gns3 portchannel</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125110147812.png" alt="image-20241125110147812"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125110254727.png" alt="image-20241125110254727"></p><p>gns3 连接前</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125161909767.png" alt="image-20241125161909767"></p><p>连接后</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241125161943211.png" alt="image-20241125161943211"></p><p>docker-sonic-p4</p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241126104338519.png" alt="image-20241126104338519"></p><p><img src="/2023/10/23/%E8%B7%AF%E7%94%B1%E6%A0%87%E8%AF%86%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/image-20241126104149243.png" alt="image-20241126104149243"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>路由标识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
      <tag>debian</tag>
      
      <tag>gns3</tag>
      
      <tag>sonic</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode23/10</title>
    <link href="/2023/10/21/leetcode23-10/"/>
    <url>/2023/10/21/leetcode23-10/</url>
    
    <content type="html"><![CDATA[<h1>23/10 力扣每日一题</h1><h2 id="2316-统计无向图中无法互相到达点对数"><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">2316. 统计无向图中无法互相到达点对数</a></h2><p>给你一个整数 <code>n</code> ，表示一张 <strong>无向图</strong> 中有 <code>n</code> 个节点，编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>无向</strong> 边。</p><p>请你返回 <strong>无法互相到达</strong> 的不同 <strong>点对数目</strong> 。</p><ul><li><p>个人思路：利用查并集去找出每个联通分量的大小，然后两两相乘相加为答案。实际编码过程中对查并集如何构造忘得差不多了。</p></li><li><p>官解注释（并查集）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parents;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sizes;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">parents</span>(n), <span class="hljs-built_in">sizes</span>(n, <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">iota</span>(parents.<span class="hljs-built_in">begin</span>(), parents.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//C++中 iota() 是用来批量递增赋值vector的元素的。注意，此处不是itoa，将整形转换为字符串的函数。</span><br>        <span class="hljs-comment">//两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值。第三个指定的值会被保存到序列的第一个元素中。保存在第一个元素后的值是通过对前面的值运用自增运算符得到的。</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (parents[x] == x) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> parents[x] = <span class="hljs-built_in">Find</span>(parents[x]); <span class="hljs-comment">//缩短路径</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rx = <span class="hljs-built_in">Find</span>(x), ry = <span class="hljs-built_in">Find</span>(y);<br>        <span class="hljs-keyword">if</span> (rx != ry) &#123;<br>            <span class="hljs-keyword">if</span> (sizes[rx] &gt; sizes[ry]) &#123; <span class="hljs-comment">//按size合并，减少树的深度</span><br>                parents[ry] = rx;<br>                sizes[rx] += sizes[ry]; <span class="hljs-comment">//如果是秩的话，就是两者相等时再++</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parents[rx] = ry;<br>                sizes[ry] += sizes[rx];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetSize</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sizes[x];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;edge : edges) &#123;<br>            uf.<span class="hljs-built_in">Union</span>(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            res += n - uf.<span class="hljs-built_in">GetSize</span>(uf.<span class="hljs-built_in">Find</span>(i)); <span class="hljs-comment">//这儿与我的思路不同，直接按每一个联通分量来说，其他点都是与该联通分量不相连的。但答案别忘了除二。</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>该题还可以深搜</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countPairs</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span>, edges: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        graph = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> edges:<br>            graph[x].append(y)<br>            graph[y].append(x) <br><br>        visited = [<span class="hljs-literal">False</span>] * n<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>            visited[x] = <span class="hljs-literal">True</span> <br>            count = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> graph[x]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[y]:<br>                    count += dfs(y)<br>            <span class="hljs-keyword">return</span> count<br><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]: <br>                count = dfs(i)<br>                res += count * (n - count)<br>        <span class="hljs-keyword">return</span> res // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="1402-做菜顺序"><a href="https://leetcode.cn/problems/reducing-dishes/">1402. 做菜顺序</a></h2><blockquote><p>一个厨师收集了他 <code>n</code> 道菜的满意程度 <code>satisfaction</code> ，这个厨师做出每道菜的时间都是 1 单位时间。</p><p>一道菜的 「 <strong>like-time 系数</strong> 」定义为烹饪这道菜结束的时间（包含之前每道菜所花费的时间）乘以这道菜的满意程度，也就是 <code>time[i]</code>*<code>satisfaction[i]</code> 。</p><p>返回厨师在准备了一定数量的菜肴后可以获得的最大 <strong>like-time 系数</strong> 总和。</p><p>你可以按 <strong>任意</strong> 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p></blockquote><ul><li><p>个人思路：</p><p>暂无，maybe动态规划？针对每一道菜有选择和位置的问题。</p><p>看了一眼标签，有贪心排序动规。对于正数like一定选择，且应按从小到大排序，而负数的选择情况仅在将其放在前几位可以使总体满意程度增加的情况，且负数一定从绝对值小的开始考虑。这样的话，对like全部排序，然后从右往左看是否选择负数即可。</p><p>仔细一想，将正数向右移一位，正数的贡献程度其实就是满意度整体加了一个全体正数的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSatisfaction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;satisfaction)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; plus;<br>        vector&lt;<span class="hljs-type">int</span>&gt; neg;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : satisfaction)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                plus.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                neg.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(plus.<span class="hljs-built_in">begin</span>(), plus.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(neg.<span class="hljs-built_in">rbegin</span>(), neg.<span class="hljs-built_in">rend</span>()); <span class="hljs-comment">// 从大到小排，便于遍历</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, plus_sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; plus.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            ans += (i + <span class="hljs-number">1</span>) * plus[i];<br>            plus_sum += plus[i];<br>        &#125;<br>        <span class="hljs-type">int</span> neg_sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; neg.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            neg_sum += neg[i];<br>            <span class="hljs-keyword">if</span> (neg_sum + plus_sum &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                ans += neg_sum + plus_sum;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过，good。这是贪心的思路。</p></li><li><p>官解（贪心）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSatisfaction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; satisfaction)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(satisfaction.<span class="hljs-built_in">begin</span>(), satisfaction.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-type">int</span> presum = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> si: satisfaction) &#123;<br>            <span class="hljs-keyword">if</span> (presum + si &gt; <span class="hljs-number">0</span>) &#123;<br>                presum += si;<br>                ans += presum;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>更为简洁，一次遍历。</p></li><li><p>官解（动规）</p><p>其实排序这一点想到之后，对于每个菜品就只有选择与否的问题了。可设dp[i][j] 表示前 i 道菜中选择 j 道菜时可以得到的最大喜爱时间，且满足 i≥j,对第i道菜有两种情况：</p><ul><li>第j次选择第i道菜，dp[i][j]=max(dp[i][j],dp[i-1]]j-1]+i*satisfaction[j]</li><li>第j次不选择第i道菜，dp[i][j]=max(dp[i][j],dp[i-1][j])</li></ul><p>综上</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>i</mi><mo>×</mo><mi>s</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>s</mi><mi>f</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i][j]=max(dp[i−1][j],dp[i−1][j−1]+i×satisfaction[j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">])</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSatisfaction</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; satisfaction)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = satisfaction.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">sort</span>(satisfaction.<span class="hljs-built_in">begin</span>(), satisfaction.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + satisfaction[i - <span class="hljs-number">1</span>] * j;<br>                <span class="hljs-keyword">if</span> (j &lt; i) &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j]);<br>                &#125;<br>                res = <span class="hljs-built_in">max</span>(res, dp[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="2678-老人的数目"><a href="https://leetcode.cn/problems/number-of-senior-citizens/">2678. 老人的数目</a></h2><blockquote><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>details</code> 。<code>details</code> 中每个元素都是一位乘客的信息，信息用长度为 <code>15</code> 的字符串表示，表示方式如下：</p><ul><li>前十个字符是乘客的手机号码。</li><li>接下来的一个字符是乘客的性别。</li><li>接下来两个字符是乘客的年龄。</li><li>最后两个字符是乘客的座位号。</li></ul><p>请你返回乘客中年龄 <strong>严格大于 60 岁</strong> 的人数。</p></blockquote><p>EZ</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">age = <span class="hljs-built_in">atoi</span>(d.<span class="hljs-built_in">substr</span>(<span class="hljs-number">11</span>, <span class="hljs-number">2</span>).<span class="hljs-built_in">c_str</span>());<br></code></pre></td></tr></table></figure><h2 id="1155-掷骰子等于目标和的方法数"><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子等于目标和的方法数</a></h2><blockquote><p>这里有 <code>n</code> 个一样的骰子，每个骰子上都有 <code>k</code> 个面，分别标号为 <code>1</code> 到 <code>k</code> 。</p><p>给定三个整数 <code>n</code> , <code>k</code> 和 <code>target</code> ，返回可能的方式(从总共 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">k^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>种方式中)滚动骰子的数量，使正面朝上的数字之和等于 <code>target</code> 。</p><p>答案可能很大，你需要对 <code>1e9 + 7</code> <strong>取模</strong> 。</p></blockquote><ul><li><p>个人思路：dp，<code>dp[n][t]</code>表示<code>n</code>个骰子使正面朝上数字之和为<code>t</code>的方式数则</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo>−</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n][t]=dp[n-1][t-1]+dp[n-1][t-2]+...+dp[n-1][t-k] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></span></p><p>编程采用前缀和更易于计算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mi>d</mi><mi>p</mi><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>t</mi><mo>−</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[n][t]=dpsum[n-1][t-1]-dpsum[n-1][t-k-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>且</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo fence="true">{</mo><mtable rowspacing="0.16em" columnalign="left right" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>k</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>i</mi><mo>&gt;</mo><mi>k</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mstyle></mtd><mtd class="mtr-glue"></mtd><mtd class="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}\left\{             \begin{array}{lr}             dp[1][i]=1, &amp; i&lt;=k  \\             dp[1][i]=0, &amp; i&gt;k\\             \end{array}\right.\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">1</span><span class="mpunct">,</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord">0</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.45em;"><span class="pstrut" style="height:3.45em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span></span></p><p>编程需注意k和t的大小关系，因为我们的dp大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">n\times t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>。</p><p>但样例不通过，查看官解后发现两个地方出了错，一是边界情况出错，应是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0][0]=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>；二是没在前缀和相减的时候正确取模，导致出现负数。原本是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (j - k - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    dp[i][j] = dp_sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    dp[i][j] = dp_sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - dp_sum[i - <span class="hljs-number">1</span>][j - k - <span class="hljs-number">1</span>] ;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改正确为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (j - k - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    dp[i][j] = dp_sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    dp[i][j] = (dp_sum[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] - dp_sum[i - <span class="hljs-number">1</span>][j - k - <span class="hljs-number">1</span>] + MOD) % MOD;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解：思路正确，细节没处理好，官解甚至直接加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(target + <span class="hljs-number">1</span>));<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= k; ++x) &#123;<br>                    <span class="hljs-keyword">if</span> (j - x &gt;= <span class="hljs-number">0</span>) &#123;<br>                        f[i][j] = (f[i][j] + f[i - <span class="hljs-number">1</span>][j - x]) % mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][target];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1000000007</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但有进一步优化，发现当前状态仅由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i-1][...]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">...</span><span class="mclose">]</span></span></span></span>而来，故可使用两个一维数组，存储当前状态和上一次状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">g</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= target; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= k; ++x) &#123;<br>                    <span class="hljs-keyword">if</span> (j - x &gt;= <span class="hljs-number">0</span>) &#123;<br>                        g[j] = (g[j] + f[j - x]) % mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            f = <span class="hljs-built_in">move</span>(g);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[target];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1000000007</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>再进一步可以发现，f(i,j)均由f(i-1,k)且<strong>k严格小于j</strong>而来，故可以逆序计算f(i,j)，f(i,k)的状态就是上一次的状态。故只需要使用一个一维数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                f[j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt;= k; ++x) &#123;<br>                    <span class="hljs-keyword">if</span> (j - x &gt;= <span class="hljs-number">0</span>) &#123;<br>                        f[j] = (f[j] + f[j - x]) % mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[target];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1000000007</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>官解中的<code>static constexpr</code>用于初始化静态类成员变量</p></li></ul><h2 id="2698-求一个整数的惩罚数"><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/">2698. 求一个整数的惩罚数</a></h2><blockquote><p>给你一个正整数 <code>n</code> ，请你返回 <code>n</code> 的 <strong>惩罚数</strong> 。</p><p><code>n</code> 的 <strong>惩罚数</strong> 定义为所有满足以下条件 <code>i</code> 的数的平方和：</p><ul><li><code>1 &lt;= i &lt;= n</code></li><li><code>i * i</code> 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 <code>i</code> 。</li></ul></blockquote><ul><li><p>个人思路：</p><p>首先，满足条件的i是固定的，如</p><blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">-<span class="hljs-number"> 1 </span>，因为<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 1 </span>= 1<br>-<span class="hljs-number"> 9 </span>，因为<span class="hljs-number"> 9 </span>*<span class="hljs-number"> 9 </span>=<span class="hljs-number"> 81 </span>，且<span class="hljs-number"> 81 </span>可以分割成<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 1 </span>。<br>-<span class="hljs-number"> 10 </span>，因为<span class="hljs-number"> 10 </span>*<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 100 </span>，且<span class="hljs-number"> 100 </span>可以分割成<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 0 </span>。<br>-<span class="hljs-number"> 36 </span>，因为<span class="hljs-number"> 36 </span>*<span class="hljs-number"> 36 </span>=<span class="hljs-number"> 1296 </span>，且<span class="hljs-number"> 1296 </span>可以分割成<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 29 </span>+<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure></blockquote><p>重点在于数的分割，若干连续，感觉是一个dfs，dfs(n)表示n分割后的和，返回值是一个数组（集合），可以维护一个整形到集合的map来记忆化搜索。</p><p>可行，但还是超时了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, set&lt;<span class="hljs-type">int</span>&gt;&gt; i2s;<br>    <span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set_add</span><span class="hljs-params">(set&lt;<span class="hljs-type">int</span>&gt; a, set&lt;<span class="hljs-type">int</span>&gt; b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ai : a)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> bi : b)<br>            &#123;<br>                res.<span class="hljs-built_in">insert</span>(ai + bi);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (i2s.<span class="hljs-built_in">count</span>(n))<br>        &#123;<br>            <span class="hljs-keyword">return</span> i2s[n];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> i2s[n] = set&lt;<span class="hljs-type">int</span>&gt;&#123;n&#125;;<br>        &#125;<br>        set&lt;<span class="hljs-type">int</span>&gt; res&#123;n&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &lt; n; i *= <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> one = n / i, other = n % i;<br>            set&lt;<span class="hljs-type">int</span>&gt; temp = <span class="hljs-built_in">set_add</span>(<span class="hljs-built_in">dfs</span>(one), <span class="hljs-built_in">dfs</span>(other));<br>            <span class="hljs-built_in">set_union</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(res, res.<span class="hljs-built_in">begin</span>()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> i2s[n] = res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">punishmentNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> ii = i * i;<br>            set&lt;<span class="hljs-type">int</span>&gt; temp = <span class="hljs-built_in">dfs</span>(ii);<br>            <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">count</span>(i))<br>            &#123;<br>                ans += ii;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>学习一个c++，set求并集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">set_union</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(res, res.<span class="hljs-built_in">begin</span>()));<br></code></pre></td></tr></table></figure><p><img src="/2023/10/21/leetcode23-10/image-20231025112205483.png" alt="image-20231025112205483"></p><p>尝试使用unorder_set，反而不如之前。</p><p><img src="/2023/10/21/leetcode23-10/image-20231025112431284.png" alt="image-20231025112431284"></p></li><li><p>官解</p><p>也是深搜，但是是这样定义的，bool dfs(string &amp;s, int pos, int tot, int target)，其中也有一个剪枝处理，当当前和大于数时就break了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> tot, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == s.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> tot == target;<br>        &#125; <br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            sum = sum * <span class="hljs-number">10</span> + s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (sum + tot &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(s, i + <span class="hljs-number">1</span>, sum + tot, target)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">punishmentNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            string s = <span class="hljs-built_in">to_string</span>(i * i);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, i)) &#123;<br>                res += i * i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>个人改进</p><p>确实轻松很多，注意一个微妙的错误，dfs(other,target-one)是错的，dfs(one,target-other)则是正确的，体现在100的判断上有所不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @lc app=leetcode.cn id=2698 lang=cpp</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * [2698] 求一个整数的惩罚数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// @lc code=start</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == target)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &lt; n; i *= <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> one = n / i, other = n % i;<br>            <span class="hljs-keyword">if</span> (other &gt;= target)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 原来是break，错误</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(one, target - other)) <span class="hljs-comment">// 原来是dfs(other,target-one),错误</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">punishmentNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i * i, i))<br>            &#123;<br>                ans += i * i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// @lc code=end</span><br><br></code></pre></td></tr></table></figure></li></ul><h2 id="2520-统计能整除数字的位数"><a href="https://leetcode.cn/problems/count-the-digits-that-divide-a-number/">2520. 统计能整除数字的位数</a></h2><blockquote><p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p><p>如果满足 <code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p></blockquote><ul><li><p>个人思路</p><p>EZ</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-built_in">to_string</span>(num);<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>不转字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = num, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (num % (t % <span class="hljs-number">10</span>) == <span class="hljs-number">0</span>) &#123;<br>            res += <span class="hljs-number">1</span>;<br>        &#125;<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="1465-切割后面积最大的蛋糕"><a href="https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/">1465. 切割后面积最大的蛋糕</a></h2><blockquote><p>矩形蛋糕的高度为 <code>h</code> 且宽度为 <code>w</code>，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中：</p><ul><li><code>horizontalCuts[i]</code> 是从矩形蛋糕顶部到第 <code>i</code> 个水平切口的距离</li><li><code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 <code>j</code> 个竖直切口的距离</li></ul><p>请你按数组 <em><code>horizontalCuts</code></em> 和 <em><code>verticalCuts</code></em> 中提供的水平和竖直位置切割后，请你找出 <strong>面积最大</strong> 的那份蛋糕，并返回其 <strong>面积</strong> 。由于答案可能是一个很大的数字，因此需要将结果 <strong>对</strong> <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p><img src="/2023/10/21/leetcode23-10/image-20231027100154766.png" alt="image-20231027100154766"></p></blockquote><ul><li><p>个人思路：排序，贪心秒了。以后尝试用go语言来写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(h <span class="hljs-type">int</span>, w <span class="hljs-type">int</span>, horizontalCuts []<span class="hljs-type">int</span>, verticalCuts []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>hmax, vmax := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>pre := <span class="hljs-number">0</span><br>sort.Ints(horizontalCuts)<br>sort.Ints(verticalCuts)<br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> horizontalCuts &#123;<br><span class="hljs-keyword">if</span> num-pre &gt; hmax &#123;<br>hmax = num - pre<br>&#125;<br>pre = num<br>&#125;<br>hmax = max(hmax, h-pre)<br>pre = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> verticalCuts &#123;<br><span class="hljs-keyword">if</span> num-pre &gt; vmax &#123;<br>vmax = num - pre<br>&#125;<br>pre = num<br>&#125;<br>vmax = max(vmax, w-pre)<br><span class="hljs-keyword">return</span> hmax * vmax % (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>写了个函数简化了上面代码，没什么区别。</p></li></ul><h2 id="2558-从数量最多的堆取走礼物"><a href="https://leetcode.cn/problems/take-gifts-from-the-richest-pile/">2558. 从数量最多的堆取走礼物</a></h2><blockquote><p>给你一个整数数组 <code>gifts</code> ，表示各堆礼物的数量。每一秒，你需要执行以下操作：</p><ul><li>选择礼物数量最多的那一堆。</li><li>如果不止一堆都符合礼物数量最多，从中选择任一堆即可。</li><li>选中的那一堆留下平方根数量的礼物（向下取整），取走其他的礼物。</li></ul><p>返回在 <code>k</code> 秒后剩下的礼物数量*。*</p></blockquote><ul><li><p>个人思路</p><p>ez</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pickGifts</span><span class="hljs-params">(gifts []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int64</span><br>ans = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>sort.Sort(sort.Reverse(sort.IntSlice(gifts)))<br>gifts[<span class="hljs-number">0</span>] = <span class="hljs-type">int</span>(math.Floor(math.Sqrt(<span class="hljs-type">float64</span>(gifts[<span class="hljs-number">0</span>]))))<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> gifts &#123;<br>ans += <span class="hljs-type">int64</span>(v)<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>如何从大到小排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Sort(sort.Reverse(sort.IntSlice(gifts)))<br></code></pre></td></tr></table></figure></li><li><p>向下取整，开方</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">math.Floor(math.Sqrt(<span class="hljs-type">float64</span>(gifts[<span class="hljs-number">0</span>])))<br></code></pre></td></tr></table></figure></li></ul></li><li><p>官解</p><p>是堆！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pickGifts</span><span class="hljs-params">(gifts []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    q := &amp;pq&#123;&#125;<br><span class="hljs-keyword">for</span> _, gift := <span class="hljs-keyword">range</span> gifts &#123;<br>q.Push(gift)<br>&#125;<br>    heap.Init(q)<br>    <span class="hljs-keyword">for</span> k &gt; <span class="hljs-number">0</span> &#123;<br>        x := heap.Pop(q).(<span class="hljs-type">int</span>)<br>        heap.Push(q, <span class="hljs-type">int</span>(math.Floor(math.Sqrt(<span class="hljs-type">float64</span>(x)))))<br>        k--<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> res <span class="hljs-type">int64</span><br><span class="hljs-keyword">for</span> q.Len() &gt; <span class="hljs-number">0</span> &#123;<br>res += <span class="hljs-type">int64</span>(q.Pop().(<span class="hljs-type">int</span>))<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-keyword">type</span> pq []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q pq)</span></span> Len() <span class="hljs-type">int</span> &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q) <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q pq)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <br>    <span class="hljs-keyword">return</span> q[i] &gt; q[j] <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q pq)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; <br>    q[i], q[j] = q[j], q[i] <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *pq)</span></span> Push(v <span class="hljs-keyword">interface</span>&#123;&#125;) &#123; <br>    *q = <span class="hljs-built_in">append</span>(*q, v.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *pq)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    n := <span class="hljs-built_in">len</span>(*q)<br>    res := (*q)[n - <span class="hljs-number">1</span>]<br>    *q = (*q)[<span class="hljs-number">0</span> : n - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="274-H-指数"><a href="https://leetcode.cn/problems/h-index/">274. H 指数</a></h2><blockquote><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code> 指数</strong>。</p><p>根据维基百科上 <a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：<code>h</code> 代表“高引用次数” ，一名科研人员的 <code>h</code> <strong>指数</strong> 是指他（她）至少发表了 <code>h</code> 篇论文，并且每篇论文 <strong>至少</strong> 被引用 <code>h</code> 次。如果 <code>h</code> 有多种可能的值，<strong><code>h</code> 指数</strong> 是其中最大的那个。</p></blockquote><ul><li><p>个人思路</p><p>从小到大排序，从头遍历，若c[i]大于n-i（n是发表论文的数量）,则h=n-i。一遍过，ez</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(citations []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>sort.Ints(citations)<br>ans := <span class="hljs-number">0</span><br>n := <span class="hljs-built_in">len</span>(citations)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> citations[i] &gt;= n-i &#123;<br>ans = n - i<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>官解</p><p>计数和二分也可解。</p></li></ul><h2 id="275-H-指数-II"><a href="https://leetcode.cn/problems/h-index-ii/">275. H 指数 II</a></h2><blockquote><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数，<code>citations</code> 已经按照 <strong>升序排列</strong> 。计算并返回该研究者的 h 指数。</p><p><a href="https://baike.baidu.com/item/h-index/3991452?fr=aladdin">h 指数的定义</a>：h 代表“高引用次数”（high citations），一名科研人员的 <code>h</code> 指数是指他（她）的 （<code>n</code> 篇论文中）<strong>总共</strong>有 <code>h</code> 篇论文分别被引用了<strong>至少</strong> <code>h</code> 次。</p><p>请你设计并实现对数时间复杂度的算法解决此问题。</p></blockquote><p>与昨天的题面基本一样，只是已经升序排列，并且要求对数时间复杂度解决。</p><ul><li><p>个人思路</p><p>按昨日题解的计数解决。不过这里已经升序，计数优化不大。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(citations []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>ci_freq := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">int</span><br>clen := <span class="hljs-built_in">len</span>(citations)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; clen; i++ &#123;<br><span class="hljs-keyword">if</span> citations[i] &gt; clen &#123;<br>ci_freq[clen]++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ci_freq[citations[i]]++<br>&#125;<br>&#125;<br>acc := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := clen; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> val, ok := ci_freq[i]; ok &#123;<br>acc += val<br><span class="hljs-comment">// fmt.Println(acc)</span><br>&#125;<br><span class="hljs-keyword">if</span> acc &gt;= i &#123;<br>ans = i<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p>使用二分查找的思路去写，重点在于<code>clen-left</code>，以及各值的确定，如</p><ul><li><code>right</code>为何是<code>clen-1</code>？</li><li>循环判断条件为何是<code>left&lt;=right</code>？</li><li>二分判断条件为何是<code>citations[mid]&gt;=clen-mid</code>？<code>clen-mid</code>的意义是什么？</li><li>为何是<code>right=mid-1</code>和<code>left=mid+1</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hIndex</span><span class="hljs-params">(citations []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> left, right <span class="hljs-type">int</span><br>clen := <span class="hljs-built_in">len</span>(citations)<br><span class="hljs-keyword">for</span> left, right = <span class="hljs-number">0</span>, clen<span class="hljs-number">-1</span>; left &lt;= right; &#123;<br>mid := (left + right) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> citations[mid] &gt;= clen-mid &#123;<br>right = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>left = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> clen - left<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2003-每棵子树内缺失的最小基因值"><a href="https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/">2003. 每棵子树内缺失的最小基因值</a></h2><blockquote><p>有一棵根节点为 <code>0</code> 的 <strong>家族树</strong> ，总共包含 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 <code>0</code> 是 <strong>根</strong> ，所以 <code>parents[0] == -1</code> 。</p><p>总共有 <code>105</code> 个基因值，每个基因值都用 <strong>闭区间</strong> <code>[1, 105]</code> 中的一个整数表示。给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是节点 <code>i</code> 的基因值，且基因值 <strong>互不相同</strong> 。</p><p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code> 是以节点 <code>i</code> 为根的子树内 <strong>缺失</strong> 的 <strong>最小</strong> 基因值。</p><p>节点 <code>x</code> 为根的 <strong>子树</strong> 包含节点 <code>x</code> 和它所有的 <strong>后代</strong> 节点。</p></blockquote><ul><li><p>个人思路</p><p>感觉不能用dp，因为根节点的最小缺失基因可能比子节点的最小缺失基因还大。（划去）</p><p>等等，以1为基因值的节点的所有子树的最小缺失基因值均是1，而包含这个节点的树的最小缺失基因值大于等于1。</p><p>~~但以n为基因值（n&gt;1)的节点的所有子树的最小缺失基因值不一定是n，而是<strong>小于等于n</strong>（因为若子树的最小缺失基因值大于n，说明该子树已包含基因值为n的节点，与前提矛盾，基因值互不相同）；而包含这个节点的树的最小缺失基因值可能大于n（说明以n为基因值的节点的最小缺失基因值就是n），也可能小于n。~~不对，仅靠小于等于n无法判断。</p><p>~~换一个思路,从底向上去考虑。叶子节点的最小缺失基因值是容易得到的（若节点基因值不是1，则是1；否则是2），那么考虑一个节点，其孩子节点的最小缺失基因值已经得出，则该节点的最小缺失基因值（smallest missing value，后简称为smv，基因值就是v）一定大于等于孩子节点的smv的最大值，可先假设为t，此时再从小到大考虑孩子节点的v，若正好是t，则t++，最后该节点的smv就是自加后的t。~~不光依赖于孩子节点，还依赖于其所有子节点的v</p><p>不要想这种投机取巧的思维，回到最原始的思路上，我们求一个节点的smv，需要遍历其子树的v并上自己的v，然后再求smv即可。可维护一个vs数组，表示以该节点为根节点的树的所有v的集合，且其正好是孩子节点的vs相加（并集）。<s>可以深度优先搜索，配合记忆化</s>那么我们可以拓扑排序，从树的叶子节点开始从下往上计算vs和smv（下面代码中smv是ans数组）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestMissingValueSubtree</span><span class="hljs-params">(parents []<span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(parents)<br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>childs := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>childs[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, n)<br>&#125;<br>child_num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><br>vs := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>vs[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, n)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>child_num[parents[i]]++<br>childs[parents[i]] = <span class="hljs-built_in">append</span>(childs[parents[i]], i)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>vs[i] = <span class="hljs-built_in">append</span>(vs[i], nums[i])<br><span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">1</span> &#123;<br>ans[i] = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[i] = <span class="hljs-number">2</span><br>&#125;<br>&#125;<br>queue := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> child_num[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>child_num[i] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>now_node := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> ; ; now_node, queue = queue[<span class="hljs-number">0</span>], queue[<span class="hljs-number">1</span>:] &#123;<br>max_smv := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(childs[now_node]); i++ &#123;<br>vs[now_node] = <span class="hljs-built_in">append</span>(vs[now_node], vs[childs[now_node][i]]...)<br><span class="hljs-keyword">if</span> max_smv &lt; ans[childs[now_node][i]] &#123;<br>max_smv = ans[childs[now_node][i]]<br>&#125;<br><span class="hljs-keyword">for</span> j := max_smv; j &lt;= <span class="hljs-number">1e5</span>; j++ &#123;<br>flag := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(vs[now_node]); k++ &#123;<br><span class="hljs-keyword">if</span> j == vs[now_node][k] &#123;<br>flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> flag == <span class="hljs-literal">false</span> &#123;<br>ans[now_node] = j<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> parents[now_node] != <span class="hljs-number">-1</span> &#123;<br>child_num[parents[now_node]]--<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> child_num[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>child_num[i] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试换成<code>type Set map[int]struct&#123;&#125;</code>，不超时了，但爆内存了。。</p><p><img src="/2023/10/21/leetcode23-10/image-20231031141613056.png" alt="image-20231031141613056"></p><p>即使即使回收不需要的map内容，仍超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestMissingValueSubtree</span><span class="hljs-params">(parents []<span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(parents)<br>ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>childs := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>childs[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, n)<br>&#125;<br>child_num := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><br>vs := <span class="hljs-built_in">make</span>([]Set, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>vs[i] = <span class="hljs-built_in">make</span>(Set)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>child_num[parents[i]]++<br>childs[parents[i]] = <span class="hljs-built_in">append</span>(childs[parents[i]], i)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>vs[i][nums[i]] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">if</span> nums[i] != <span class="hljs-number">1</span> &#123;<br>ans[i] = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[i] = <span class="hljs-number">2</span><br>&#125;<br>&#125;<br>queue := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> child_num[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>child_num[i] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>now_node := queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> ; ; now_node, queue = queue[<span class="hljs-number">0</span>], queue[<span class="hljs-number">1</span>:] &#123;<br>max_smv := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(childs[now_node]); i++ &#123;<br><span class="hljs-keyword">for</span> k, _ := <span class="hljs-keyword">range</span> vs[childs[now_node][i]] &#123;<br>vs[now_node][k] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>vs[childs[now_node][i]] = <span class="hljs-built_in">make</span>(Set) <span class="hljs-comment">//回收map内存</span><br><span class="hljs-keyword">if</span> max_smv &lt; ans[childs[now_node][i]] &#123;<br>max_smv = ans[childs[now_node][i]]<br>&#125;<br>&#125;<br><span class="hljs-comment">// fmt.Printf(&quot;now_node:%d\n&quot;, now_node)</span><br><span class="hljs-comment">// fmt.Printf(&quot;queue:%v\n&quot;, queue)</span><br><span class="hljs-comment">// fmt.Printf(&quot;max_smv:%d\n&quot;, max_smv)</span><br><span class="hljs-comment">// fmt.Printf(&quot;vs:%v\n&quot;, vs)</span><br><span class="hljs-keyword">for</span> j := max_smv; j &lt;= <span class="hljs-number">1e5</span>; j++ &#123;<br><span class="hljs-keyword">if</span> _, ok := vs[now_node][j]; ok == <span class="hljs-literal">false</span> &#123;<br>ans[now_node] = j<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> parents[now_node] != <span class="hljs-number">-1</span> &#123;<br>child_num[parents[now_node]]--<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> child_num[i] == <span class="hljs-number">0</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>child_num[i] = <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/10/21/leetcode23-10/image-20231031143221474.png" alt="image-20231031143221474"></p></li><li><p>另，注意力扣代码应位于<code>// @lc code=start</code>之下</p></li><li><p>go语言中用于快速print一个数组或是字典的方式<code>%v</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;queue:%v\n&quot;</span>, queue)<br></code></pre></td></tr></table></figure></li><li><p>官解</p><h4 id="深度优先搜索-启发式合并">深度优先搜索 + 启发式合并</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestMissingValueSubtree</span><span class="hljs-params">(parents []<span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(parents)<br>    children := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        children[parents[i]] = <span class="hljs-built_in">append</span>(children[parents[i]], i)<br>    &#125;<br><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        res[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> (<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>)<br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node <span class="hljs-type">int</span>)</span></span> (<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>) &#123;<br>        geneSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;nums[node]:<span class="hljs-literal">true</span>&#125;<br>        <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children[node] &#123;<br>            childGeneSet, y := dfs(child)<br>            res[node] = max(res[node], y)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(childGeneSet) &gt; <span class="hljs-built_in">len</span>(geneSet) &#123;  <span class="hljs-comment">//剪枝操作，大部分情况下条件为真</span><br>                geneSet, childGeneSet = childGeneSet, geneSet<br>            &#125;<br>            <span class="hljs-keyword">for</span> gene, _ := <span class="hljs-keyword">range</span> childGeneSet &#123;<br>                geneSet[gene] = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//不用判断key值是否存在？</span><br>        <span class="hljs-keyword">for</span> geneSet[res[node]] &#123;<br>            res[node]++<br>        &#125;<br>        <span class="hljs-keyword">return</span> geneSet, res[node]<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br></code></pre></td></tr></table></figure><p>深度优先搜索</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">smallestMissingValueSubtree</span><span class="hljs-params">(parents []<span class="hljs-type">int</span>, nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(parents)<br>    children := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        children[parents[i]] = <span class="hljs-built_in">append</span>(children[parents[i]], i)<br>    &#125;<br><br>    geneSet, visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> visited[node] &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        visited[node] = <span class="hljs-literal">true</span><br>        geneSet[nums[node]] = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children[node] &#123;<br>            dfs(child)<br>        &#125;<br>    &#125;<br><br>    res, node, iNode := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n), <span class="hljs-number">-1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        res[i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">1</span> &#123;<br>            node = i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> node != <span class="hljs-number">-1</span> &#123;<br>        dfs(node)<br>        <span class="hljs-keyword">for</span> geneSet[iNode] &#123;<br>            iNode++<br>        &#125;<br>        res[node], node = iNode, parents[node]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>算法编程</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客的搭建</title>
    <link href="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>​前面的搭建内容已经忘了，主要是参考以下网站进行的。</p><p><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a></p><p>​而在hexo typora github体系下如何插入图片做了太多尝试，改的乱七八槽的，这里便不在记录。可能有用的应是如下网址：</p><p><a href="https://blog.csdn.net/qq_36408085/article/details/104117319">Hexo+Github博客：网站内图片不能正常显示，但本地文件可以显示_hexo部署在github上图片http403-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a>（这篇为主）</p><span id="more"></span><h1>搭建</h1><p>​接下来将记录其他美化博客的操作，并且我的风格是简约为主。</p><h2 id="「第三期」-hexo-github搭建博客（主题美化）-知乎-zhihu-com"><a href="https://zhuanlan.zhihu.com/p/376367026">「第三期」 hexo+github搭建博客（主题美化） - 知乎 (zhihu.com)</a></h2><h3 id="新建分类categories">新建分类categories</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo new page &quot;categories&quot;<br></code></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">---<br>title: categories<br>date: 2021-05-07 20:08:39<br>type: &quot;categories&quot;<br>layout: &quot;categories&quot;<br>---<br></code></pre></td></tr></table></figure><h3 id="新建标签tags页">新建标签tags页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo new page &quot;tags&quot;<br></code></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">---<br>title: tags<br>date: 2021-05-07 17:25:30<br>type: &quot;tags&quot;<br>layout: &quot;tags&quot;<br>---<br></code></pre></td></tr></table></figure><h3 id="新建关于我about页">新建关于我about页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo new page &quot;about&quot;<br></code></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">---<br>title: about<br>date: 2021-05-07 17:25:30<br>type: &quot;about&quot;<br>layout: &quot;about&quot;<br>---<br></code></pre></td></tr></table></figure><p>目前这三个貌似对博客并没有什么影响。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231020164849323.png" alt="image-20231020164849323"></p><h3 id="代码高亮（没采用）">代码高亮（没采用）</h3><p>之前的代码风格如下：</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231020164920225.png" alt="image-20231020164920225"></p><p>还行，但我喜欢darker。</p><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://link.zhihu.com/?target=https%3A//github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">npm i -S hexo-prism-plugin<br></code></pre></td></tr></table></figure><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism_plugin</code> 插件相关的配置，主要配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">prism_plugin:</span><br>  <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;preprocess&#x27;</span>    <span class="hljs-comment"># realtime/preprocess</span><br>  <span class="hljs-attr">theme:</span> <span class="hljs-string">&#x27;tomorrow&#x27;</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">false</span>    <span class="hljs-comment"># default false</span><br>  <span class="hljs-attr">custom_css:</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改之后，也不是很好看，主要没有彩色高亮，不采用。<img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231020165356115.png" alt="image-20231020165356115"></p><h3 id="删除插件">删除插件</h3><p>于是学习了一下怎么删除插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm uninstall &lt;你的插件名&gt;<br></code></pre></td></tr></table></figure><h3 id="搜索功能">搜索功能</h3><p>本主题中还使用到了 <a href="https://link.zhihu.com/?target=https%3A//github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install hexo-generator-search --save<br></code></pre></td></tr></table></figure><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">search:</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">search.xml</span><br>  <span class="hljs-attr">field:</span> <span class="hljs-string">post</span><br></code></pre></td></tr></table></figure><p>加了好像也没有什么影响。</p><p>由于上述的网站的美化操作对于我的博客来说似乎没有什么用，于是我打算针对性的去搜索进行美化。</p><h2 id="MY">MY</h2><h3 id="文章摘要">文章摘要</h3><ol><li>修改配置</li></ol><p>在next主题的_config.yml中打开设置（默认是打开）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Automatically excerpt description in homepage as preamble text.</span><br><span class="hljs-attr">excerpt_description:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>两种方法</p><ul><li><p>概述</p><p>在文章的<code>front-matter</code>中添加<code>description</code>，其中description中的内容就会被显示在首页上，其余一律不显示。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">---<br>title: 让首页显示部分内容<br>date: 2020-02-23 22:55:10<br>description: 这是显示在首页的概述，正文内容均会被隐藏。<br>---<br><br></code></pre></td></tr></table></figure></li><li><p>文章截断</p><p>在需要截断的地方加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--more--&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><p>效果如下</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231020171446736.png" alt="image-20231020171446736"></p><h3 id="更换主题为fuild">更换主题为fuild</h3><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/tree/master">fluid-dev/hexo-theme-fluid: :ocean: 一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo (github.com)</a></p><p>按照上述网址的readme进行主题的更换，更换后需要<code>hexo clean</code>并<code>hexo g</code>，不然打开是白屏的，且</p><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><p><strong>注意</strong></p><blockquote><p>Hexo 5.0.0 版本以上的用户，在博客目录下创建 <code>_config.fluid.yml</code> 文件，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml (opens new window)</a>全部配置（或部分配置）复制过去。</p><p>以后如果修改任何主题配置，都只需修改 <code>_config.fluid.yml</code> 的配置即可。</p><p>注意：</p><ul><li>只要存在于 <code>_config.fluid.yml</code> 的配置都是高优先级，修改原 <code>_config.yml</code> 是无效的。</li><li>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对 <code>_config.fluid.yml</code> 同步修改。</li><li>想查看覆盖配置有没有生效，可以通过 <code>hexo g --debug</code> 查看命令行输出。</li><li>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的，比如：</li></ul></blockquote><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231024114250471.png" alt="image-20231024114250471"></p><p>素服了，且之前配置的关于，分类，搜索等也能看见了。</p><h3 id="增加latex显示功能">增加latex显示功能</h3><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><ul><li><p>按照指南配置，不采用官方的hexo-math插件。</p></li><li><p>需要显示latex的需要在格式头增加<code>math: true</code></p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231024115429856.png" alt="image-20231024115429856"></p></li><li><p>使用<code>mathjax</code>渲染器失败，采用<code>katex</code>，显示ok。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231024122906362.png" alt="image-20231024122906362"></p></li><li><p>另附<a href="https://www.luogu.com.cn/blog/IowaBattleship/latex-gong-shi-tai-quan">LaTeX 数学公式大全 - Iowa_BattleShip 的博客 - 洛谷博客 (luogu.com.cn)</a></p></li></ul><h3 id="修改浏览器图标，slogan，关于页">修改浏览器图标，slogan，关于页</h3><p>到主题配置中去修改就好，注意图标存放的位置在<code>Blog\themes\fluid\source\img</code>，任何时候不要去public修改文件，那个文件夹一<code>hexo clean</code>就无了。但仍没成功。</p><h3 id="tags，categories的格式">tags，categories的格式</h3><p>两者格式一致。对于分类，下方的分类将会是上方分类的子分类。</p><h3 id="自定义图标">自定义图标</h3><p><a href="https://blog.csdn.net/qq_36852780/article/details/112166727">Hexo fluid主题如何自定义iconfont图标 - Hexo_hexo换图标_ClearlightY的博客-CSDN博客</a></p><h3 id="文章跳转">文章跳转</h3><p><a href="https://xuanyabulema.github.io/posts/Hexo-Posts-Links.html">Hexo 文章跳转（链接） | 悬崖不勒马的小站 (xuanyabulema.github.io)</a>总结的很好。</p><h4 id="Hexo标题与id关系"><code>Hexo</code>标题与<code>id</code>关系</h4><p>Hexo Markdown文章的标题会自动生成对应的<code>id</code>，注意：</p><p>1、如果标题中间有 <code>半角空格</code> 或者 <code>全角空格</code> ，空格都会变成连字符，多个空格会合并成一个连字符；</p><p>2、大写字母会变成小写字母；</p><p>3、多级序号需要去除 <code>.</code></p><p>4、<code>——</code>等字符去除</p><p>示例</p><table><thead><tr><th style="text-align:center">标题</th><th style="text-align:center">id</th><th style="text-align:center">锚点</th></tr></thead><tbody><tr><td style="text-align:center"><code>## 我是一个二级标题</code></td><td style="text-align:center"><code>id=&quot;我是一个二级标题&quot;</code></td><td style="text-align:center">#我是一个二级标题</td></tr><tr><td style="text-align:center"><code>## 部署Hexo到GitHub</code></td><td style="text-align:center"><code>id=&quot;部署hexo到github&quot;</code></td><td style="text-align:center">#部署hexo到github</td></tr><tr><td style="text-align:center"><code>## Hello　　World</code></td><td style="text-align:center"><code>id=&quot;hello-world&quot;</code></td><td style="text-align:center">#hello-world</td></tr><tr><td style="text-align:center"><code>修改并配置Hexo主题——NexT主题</code></td><td style="text-align:center"><code>id=&quot;修改并配置hexo主题next主题&quot;</code></td><td style="text-align:center">#修改并配置hexo主题next主题</td></tr><tr><td style="text-align:center"><code>### 2.3. Github 标题</code></td><td style="text-align:center"><code>id=&quot;23-github-标题&quot;</code></td><td style="text-align:center">#23-github-标题</td></tr></tbody></table><h4 id="当前文章跳转">当前文章跳转</h4><p>使用 Markdown内置的链接方式即可，其中如果有空格，需要把空格换成连字符 <code>-</code> ，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<span class="hljs-string">跳转到本文的“站内其他文章锚点跳转“章节</span>](<span class="hljs-link">#站内其他文章锚点跳转</span>)<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">[MY文章摘要](#文章摘要)<br></code></pre></td></tr></table></figure><p><a href="#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81">MY文章摘要</a></p><h4 id="站内文章跳转">站内文章跳转</h4><p><a href="https://hexo.io/zh-cn/docs/tag-plugins#%E5%BC%95%E7%94%A8%E6%96%87%E7%AB%A0">官方使用说明</a>，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% post<span class="hljs-emphasis">_link filename [title] [escape] %&#125;</span><br></code></pre></td></tr></table></figure><p>即</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% post<span class="hljs-emphasis">_link 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&#123;% post_link leetcode23-12 &#x27;文章链接&#x27; %&#125;<br></code></pre></td></tr></table></figure><a href="/2023/12/08/leetcode23-12/" title="leetcode23-12">文章链接</a><h4 id="站内其他文章锚点跳转">站内其他文章锚点跳转</h4><p>上面的 <code>post_link</code> 方式并不支持跳转到站内其他文章锚点，此外有一点不好的是：目前该方式并不能在<code>Typora</code>这个<code>Mrakdown</code>编辑器中渲染。官方文档还有一个 <code>post_path</code> ，用于获取文章路径。</p><p>使用<code>HTML</code>的<code>a标签</code>实现，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% post_path 文章文件名（不要后缀） %&#125;#章节名&quot;</span>&gt;</span></span>显示的文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>例如，注意去掉了<code>.</code>，<code> </code>（空格）变成了<code>-</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% post_path &#x27;leetcode23-12&#x27; %&#125;#1631-最小体力消耗路径&quot;</span>&gt;</span>1631. 最小体力消耗路径<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="/2023/12/08/leetcode23-12/#1631-最小体力消耗路径">1631. 最小体力消耗路径</a></p><h3 id="文章浏览量">文章浏览量</h3><p><a href="https://blog.csdn.net/qq_48759664/article/details/119460188">Hexo-fluid主题设置统计博客阅读量_给fluid主题设置统计数量-CSDN博客</a></p><ol><li><p>修改主题配置文件<code>_config.fluid.yml</code>中的<code>web_analytics</code>的<code>enable</code>字段为<code>true</code>。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231211160918534.png" alt="image-20231211160918534"></p></li><li><p>打开<code>leancloud</code>官网，注册账号，创建应用，选择开发版，打开设置。</p></li><li><p>复制<code>AppID</code>、<code>AppKey</code>、<code>REST API</code>到<code>_config.fluid.yml</code>文件中的<code>leancloud</code>下，对应<code>app_id</code>、<code>app_key</code>、<code>server_url</code>。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231211161146978.png" alt="image-20231211161146978"></p></li><li><p>修改主题配置文件<code>_config.fluid.yml</code>中的<code>views</code>的相应字段。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231211162623219.png" alt="image-20231211162623219"></p></li></ol><p>然后站点顶部就可以看见浏览次数了（呜呜呜，只有一次）。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231211161611960.png" alt="image-20231211161611960"></p><h3 id="评论区">评论区</h3><p><a href="https://www.cnblogs.com/peyshine/p/13218168.html">Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三) - 沛山 - 博客园 (cnblogs.com)</a></p><p>同样使用leancloud</p><ol><li>修改主题配置文件<code>_config.fluid.yml</code>中的<code>comments</code>的<code>enable</code>字段为<code>true</code>，<code>type</code>为<code>valine</code>。</li><li>修改主题配置文件<code>_config.fluid.yml</code>中的<code>valine</code>相应字段，与<a href="#%E6%96%87%E7%AB%A0%E6%B5%8F%E8%A7%88%E9%87%8F">文章浏览量</a>类似。</li></ol><p>效果如下。</p><p><img src="/2023/10/20/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20231211162356413.png" alt="image-20231211162356413"></p><h3 id="内容折叠">内容折叠</h3><p>参见<a href="/2023/10/26/hexo%E6%8A%98%E5%8F%A0%E5%86%85%E5%AE%B9/" title="hexo折叠内容">hexo折叠内容</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>个人</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux期末复习</title>
    <link href="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>linux期末复习</h1><h2 id="开始使用Linux">开始使用Linux</h2><h3 id="使用系统命令">使用系统命令</h3><h4 id="man">man</h4><ul><li><p>man name</p></li><li><p>man section name（用于区分不同section中的同一个name）</p><p>一般章节编号：1 命令；2 系统调用；3 库函数；5 配置文件</p></li><li><p>man -k regexp</p><p>列出与关键字正则表达式regexp相关的手册目录。</p></li></ul><h4 id="date">date</h4><ul><li><p>可以根据需要定制输出格式</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615230416980-16868424622501.png" alt="image-20230615230416980"></p></li><li><p>通过 NTP 协议校对系统时间：命令 ntpdate</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615230505504-16868424622502.png" alt="image-20230615230505504"></p></li></ul><h4 id="who，tty">who，tty</h4><ul><li>who 列出当前已登录入系统的用户<br><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615230600769-16868424622503.png" alt="image-20230615230600769"></li><li>tty 可以打印出当前终端的设备文件名</li><li>who am i 可以列出当前终端上的登录 用户</li></ul><h4 id="uptime，w，sar">uptime，w，sar</h4><ul><li><p>命令 uptime</p><ul><li><p>系统自启动后到现在的运行时间（年龄）</p></li><li><p>当前登录入系统的用户数</p></li><li><p>近期 1 分钟， 5 分钟， 15 分钟内系统 CPU 的负载（平均调度队列长度）</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615230936669-16868424622504.png" alt="image-20230615230936669"></p></li></ul></li><li><p>w 命令（ Who &amp; What）</p><ul><li>列出终端的空闲时间（ IDLE）</li><li>JCPU ：终端上正在运行的作业占用的 CPU 时间（包括前台程序和后台<br>程序）</li><li>PCPU ：终端上正在运行的前台程序占用 CPU 时间</li><li>WHAT 列出终端上的用户正在执行什么命令</li></ul><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615230953055-16868424622515.png" alt="image-20230615230953055"></p></li><li><p>sar 命令 (system activity）</p><ul><li>打印系统活动报告</li></ul></li><li><p>其他： top htop nmon 等监控系统性能的工具</p></li></ul><h4 id="ps">ps</h4><ul><li>功能：查阅 进程状态 (process）（ 实际上就是将内核中进程状态信息有选择地打印出来)</li><li>选项：<ul><li>无选项：只列出在当前终端上启动的进程</li><li>e 选项：列出系统中所有的进程（进程范围 )</li><li>f 选项：以 full 格式列出每一个进程（控制列的数目 )</li><li>l 选项：以 long 格式列出每一个进程（控制列的数目）</li></ul></li><li>列出的进程属性<ul><li>UID ：用户 ID( 注册名）</li><li>PID ：进程 ID</li><li>PPID ：父进程的 PID</li><li>C：CPU 占用指数：最近一段时间（秒级别）进程占用 CPU 情况</li><li>STIME ：启动时间</li><li>SZ ：进程逻辑内存大小 (Size)</li><li>TTY ：终端的名字</li><li>COMMAND ：命令名</li><li>WCHAN ：进程在内核的何处睡眠 (Wait Channel)</li><li>TIME ：累计执行时间（占用 CPU 的时间 )</li><li>PRI ：优先级</li><li>S ：状态 S(Sleep) R(Run) Z(Zombie)</li></ul></li></ul><h4 id="top">top</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615231520416-16868424622517.png" alt="image-20230615231520416"></p><ul><li>PR: 进程优先级，越小越优先； NI 进程优先级值可被修正数据值</li><li>VIRT: 进程 逻辑地址空间大小 (virtual） VIRT=SWAP+RES</li><li>RES: 驻留 内存数(resident）也就是占用物理内存 数， RES=CODE+DATA</li><li>S: 进程状态 。 D= 不可中断的睡眠状态 R= 运行 S= 睡眠 T= 跟踪 停止 Z= 僵尸进程</li><li>SHR ：与其 他进程共享的内存数 (Share )</li><li>CPU ：占用 CPU 百分比； ；%MEM ：占用 内存百分比</li></ul><h4 id="free">free</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615231716977-16868424622516.png" alt="image-20230615231716977"></p><h4 id="vmstat">vmstat</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615231802483-16868424622518.png" alt="image-20230615231802483"></p><h4 id="passwd">passwd</h4><ul><li><p>普通用户</p><p>使用 passwd 命令更改自己的上机口令，在更改前系统会先验证原来的口令</p></li><li><p>超级用户</p><ul><li>修改口令之前不验证旧的口令</li><li>可修改自己的口令，还可强迫设置其它用户口令</li><li>修改超级用户 root 的口令时要特别注意</li></ul></li></ul><h5 id="linux口令的保存与验证">linux口令的保存与验证</h5><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615232519245.png" alt="image-20230615232519245"></p><h3 id="通信命令">通信命令</h3><h4 id="telnet或ssh">telnet或ssh</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615233032709.png" alt="image-20230615233032709"></p><h4 id="ftp">ftp</h4><ul><li><p>用法</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615233053781.png" alt="image-20230615233053781"></p></li><li><p>常用命令</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615233115819.png" alt="image-20230615233115819"></p></li></ul><h3 id="linux文本格式">linux文本格式</h3><ul><li><p>Windows 和 Unix 文本文件结构的不同</p><p>文本文件行的行尾不同</p><ul><li>UNIX ：行尾处仅存 换行 字符</li><li>Windows ：行尾处存 回车 和换行 两个字符</li></ul><p>这还会导致两者的大小不一样</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230615233305581.png" alt="image-20230615233305581"></p></li></ul><h3 id="中文编码">中文编码</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616081544244.png" alt="image-20230616081544244"></p><h3 id="实用程序指令">实用程序指令</h3><h4 id="cal">cal</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616081629979.png" alt="image-20230616081629979"></p><h4 id="bc">bc</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616081642026.png" alt="image-20230616081642026"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616081651669.png" alt="image-20230616081651669"></p><h2 id="文本文件处理">文本文件处理</h2><h3 id="文本文件处理及工具">文本文件处理及工具</h3><p>主要涉及的概念</p><ul><li>进程的标准输入输出</li><li>重定向机制</li><li>管道机制</li><li>文件通配符</li></ul><h3 id="读取文本内容">读取文本内容</h3><h4 id="more，less">more，less</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082100144.png" alt="image-20230616082100144"></p><p>more</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082114628.png" alt="image-20230616082114628"></p><p>less</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082134292.png" alt="image-20230616082134292"></p><h4 id="cat与od">cat与od</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082155313.png" alt="image-20230616082155313"></p><h4 id="head与tail">head与tail</h4><p>-f 选项可以实时打印内容。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082248944.png" alt="image-20230616082248944"></p><h4 id="tee">tee</h4><p>三通可以远程操作其他人的终端。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082357438.png" alt="image-20230616082357438"></p><h4 id="wc">wc</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082501645.png" alt="image-20230616082501645"></p><h4 id="sort">sort</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082525369.png" alt="image-20230616082525369"></p><h4 id="tr">tr</h4><p>用于替换，但是翻译。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082620669.png" alt="image-20230616082620669"></p><h4 id="uniq">uniq</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082703865.png" alt="image-20230616082703865"></p><h3 id="正则表达式及应用">正则表达式及应用</h3><h4 id="正则表达式的功能">正则表达式的功能</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082834764.png" alt="image-20230616082834764"></p><h4 id="单字符正则表达式">单字符正则表达式</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082900925.png" alt="image-20230616082900925"></p><p><strong>定义集合</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082933637.png" alt="image-20230616082933637"></p><h4 id="多字符表达式">多字符表达式</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616082951367.png" alt="image-20230616082951367"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083014776.png" alt="image-20230616083014776"></p><h4 id="锚点">锚点</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083036415.png" alt="image-20230616083036415"></p><h4 id="文本行筛选（grep）">文本行筛选（grep）</h4><p>寻找符合条件的文本行。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083211225.png" alt="image-20230616083211225"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083308935.png" alt="image-20230616083308935"></p><h4 id="流编辑（sed）">流编辑（sed）</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083415265.png" alt="image-20230616083415265"></p><p>正则表达式替换</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083531877.png" alt="image-20230616083531877"></p><h4 id="复杂筛选及加工（awk）">复杂筛选及加工（awk）</h4><p><strong>内置变量NR，表示行号。</strong></p><p><strong>$n表示第几列，特别的，$0表示一整行。</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083611478.png" alt="image-20230616083611478"></p><p>描述条件</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083628155.png" alt="image-20230616083628155"></p><p>动作</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083734961.png" alt="image-20230616083734961"></p><p>举例</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616083757348.png" alt="image-20230616083757348"></p><h4 id="sed与awk对比">sed与awk对比</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084034607.png" alt="image-20230616084034607"></p><h4 id="举例">举例</h4><p>例1</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084336584.png" alt="image-20230616084336584"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084347218.png" alt="image-20230616084347218"></p><p>例2</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084401108.png" alt="image-20230616084401108"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084413342.png" alt="image-20230616084413342"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084427852.png" alt="image-20230616084427852"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084438710.png" alt="image-20230616084438710"></p><p>例3</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084458642.png" alt="image-20230616084458642"></p><h3 id="文件比对">文件比对</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084725099.png" alt="image-20230616084725099"></p><h4 id="cmp">cmp</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084742233.png" alt="image-20230616084742233"></p><h4 id="md5sum">md5sum</h4><p>用于比较大文件内容</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084819973.png" alt="image-20230616084819973"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084856944.png" alt="image-20230616084856944"></p><h4 id="diff">diff</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084914882.png" alt="image-20230616084914882"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616084944497.png" alt="image-20230616084944497"></p><h4 id="举例-2">举例</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085020215.png" alt="image-20230616085020215"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085029314.png" alt="image-20230616085029314"></p><h3 id="vi编辑器">vi编辑器</h3><h4 id="用户偏好设置">用户偏好设置</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085103223.png" alt="image-20230616085103223"></p><h4 id="工作状态">工作状态</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085136811.png" alt="image-20230616085136811"></p><h4 id="编辑与光标移动">编辑与光标移动</h4><p><strong>光标单字符移动</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085159640.png" alt="image-20230616085159640"></p><p><strong>翻页</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085213041.png" alt="image-20230616085213041"></p><p><strong>光标快速移动</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085237032.png" alt="image-20230616085237032"></p><p><strong>光标移动到指定行</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085300920.png" alt="image-20230616085300920"></p><h4 id="查找、编辑及存盘">查找、编辑及存盘</h4><p><strong>删除</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085454205.png" alt="image-20230616085454205"></p><p><strong>字符替换</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085516360.png" alt="image-20230616085516360"></p><p><strong>取消和重复</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085533044.png" alt="image-20230616085533044"></p><p><strong>存盘操作</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085556339.png" alt="image-20230616085556339"></p><p><strong>剪切板</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085622825.png" alt="image-20230616085622825"></p><p><strong>快操作（删除和复制）</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085656653.png" alt="image-20230616085656653"></p><p><strong>行合并，刷屏，状态显示</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085727227.png" alt="image-20230616085727227"></p><p><strong>模式查找</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085748055.png" alt="image-20230616085748055"></p><p><strong>模式替换</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085808084.png" alt="image-20230616085808084"></p><p><strong>模式转义符</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085837004.png" alt="image-20230616085837004"></p><p><strong>模式中的正则表达式</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085908969.png" alt="image-20230616085908969"></p><h4 id="编辑命令">编辑命令</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085943538.png" alt="image-20230616085943538"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616085952887.png" alt="image-20230616085952887"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090002049.png" alt="image-20230616090002049"></p><h4 id="可能会出现的问题">可能会出现的问题</h4><p><strong>死机问题</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090032243.png" alt="image-20230616090032243"></p><p><strong>意外中止问题（jobs）</strong></p><p>使用jobs</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090049103.png" alt="image-20230616090049103"></p><p><strong>退格键无法使用</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090200197.png" alt="image-20230616090200197"></p><p><strong>屏幕显示乱码</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090233977.png" alt="image-20230616090233977"></p><p><strong>文件格式问题（windows）</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090304664.png" alt="image-20230616090304664"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090314128.png" alt="image-20230616090314128"></p><p><strong>中文编码问题</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090334721.png" alt="image-20230616090334721"></p><h2 id="文件系统管理">文件系统管理</h2><h3 id="文件名和文件通配符">文件名和文件通配符</h3><h4 id="文件命名和目录结构">文件命名和目录结构</h4><p><strong>命名规则</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090921661.png" alt="image-20230616090921661"></p><p><strong>常见目录和文件</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090943234.png" alt="image-20230616090943234"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616090956401.png" alt="image-20230616090956401"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091020444.png" alt="image-20230616091020444"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091031350.png" alt="image-20230616091031350"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091128039.png" alt="image-20230616091128039"></p><p><strong>动态链接</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091107409.png" alt="image-20230616091107409"></p><h4 id="文件通配符规则">文件通配符规则</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091213584.png" alt="image-20230616091213584"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091221086.png" alt="image-20230616091221086"></p><p>点与点点不是通配符，而是目录存储结构。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091231540.png" alt="image-20230616091231540"></p><p><strong>注意</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091345004.png" alt="image-20230616091345004"></p><h4 id="文件通配符处理过程">文件通配符处理过程</h4><p><strong>shell与kernel</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091426166.png" alt="image-20230616091426166"></p><p><strong>获取命令行参数</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091454401.png" alt="image-20230616091454401"></p><p><strong>shell通配符处理</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091524390.png" alt="image-20230616091524390"></p><p><strong>举例</strong></p><p>注意有无引号的区别</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091603362.png" alt="image-20230616091603362"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091629891.png" alt="image-20230616091629891"></p><h3 id="文件和目录管理">文件和目录管理</h3><h4 id="列出文件目录（ls）">列出文件目录（ls）</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091747096.png" alt="image-20230616091747096"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091805604.png" alt="image-20230616091805604"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091823267.png" alt="image-20230616091823267"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091832014.png" alt="image-20230616091832014"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091840902.png" alt="image-20230616091840902"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091856467.png" alt="image-20230616091856467"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091908698.png" alt="image-20230616091908698"></p><h4 id="文件的复制与删除（cp，mv）">文件的复制与删除（cp，mv）</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091923109.png" alt="image-20230616091923109"></p><p>注意拷贝到当前目录的正确用法。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616091933639.png" alt="image-20230616091933639"></p><p><strong>mv</strong></p><p>mv命令可以改名。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092152866.png" alt="image-20230616092152866"></p><p><strong>rm</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092231919.png" alt="image-20230616092231919"></p><p>显示区分命令选项和处理对象，-- 结束命令解析。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092308694.png" alt="image-20230616092308694"></p><h4 id="目录管理（mkdir，rmdir，cp-v-u，rsync）">目录管理（mkdir，rmdir，cp -v -u，rsync）</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092451116.png" alt="image-20230616092451116"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092507234.png" alt="image-20230616092507234"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092524837.png" alt="image-20230616092524837"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092558597.png" alt="image-20230616092558597"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092612102.png" alt="image-20230616092612102"></p><p><strong>举例</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092754372.png" alt="image-20230616092754372"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092812018.png" alt="image-20230616092812018"></p><h4 id="目录遍历">目录遍历</h4><h5 id="find">find</h5><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092906896.png" alt="image-20230616092906896"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092925771.png" alt="image-20230616092925771"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092935019.png" alt="image-20230616092935019"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616092944064.png" alt="image-20230616092944064"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093026633.png" alt="image-20230616093026633"></p><p><strong>find动作</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093048712.png" alt="image-20230616093048712"></p><h5 id="应用">应用</h5><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093111231.png" alt="image-20230616093111231"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093126770.png" alt="image-20230616093126770"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093135171.png" alt="image-20230616093135171"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093150875.png" alt="image-20230616093150875"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093202122.png" alt="image-20230616093202122"></p><h4 id="批量处理文件（xargs）">批量处理文件（xargs）</h4><p>重点在于find配置其他命令会不断创建进程。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093325709.png" alt="image-20230616093325709"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093506321.png" alt="image-20230616093506321"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093520982.png" alt="image-20230616093520982"></p><h4 id="打包与压缩（tar）">打包与压缩（tar）</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093613443.png" alt="image-20230616093613443"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093622354.png" alt="image-20230616093622354"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093631284.png" alt="image-20230616093631284"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093639080.png" alt="image-20230616093639080"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093647892.png" alt="image-20230616093647892"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616093655961.png" alt="image-20230616093655961"></p><h3 id="命令获取信息方法">命令获取信息方法</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094526316.png" alt="image-20230616094526316"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094534765.png" alt="image-20230616094534765"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094543615.png" alt="image-20230616094543615"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094555755.png" alt="image-20230616094555755"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094609675.png" alt="image-20230616094609675"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094622568.png" alt="image-20230616094622568"></p><p><strong>命令行参数的三种风格</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094702368.png" alt="image-20230616094702368"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094710128.png" alt="image-20230616094710128"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094721464.png" alt="image-20230616094721464"></p><h3 id="文件系统">文件系统</h3><h4 id="文件系统的创建与安装">文件系统的创建与安装</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094747531.png" alt="image-20230616094747531"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094805661.png" alt="image-20230616094805661"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094815628.png" alt="image-20230616094815628"></p><h4 id="文件系统的存储结构">文件系统的存储结构</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094843189.png" alt="image-20230616094843189"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094852779.png" alt="image-20230616094852779"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094904233.png" alt="image-20230616094904233"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094918564.png" alt="image-20230616094918564"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094933211.png" alt="image-20230616094933211"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616094946652.png" alt="image-20230616094946652"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616095045139.png" alt="image-20230616095045139"></p><h4 id="硬链接">硬链接</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616100032500.png" alt="image-20230616100032500"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616100042068.png" alt="image-20230616100042068"></p><p>+2是当前目录.和上级目录的链接；直属子目录数来自下级目录的…</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616100055216.png" alt="image-20230616100055216"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101245293.png" alt="image-20230616101245293"></p><h4 id="符号链接">符号链接</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101257264.png" alt="image-20230616101257264"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101321361.png" alt="image-20230616101321361"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101333060.png" alt="image-20230616101333060"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101404331.png" alt="image-20230616101404331"></p><h4 id="系统调用">系统调用</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101513717.png" alt="image-20230616101513717"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101522912.png" alt="image-20230616101522912"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101539799.png" alt="image-20230616101539799"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101554822.png" alt="image-20230616101554822"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101606729.png" alt="image-20230616101606729"></p><h4 id="访问i节点和目录">访问i节点和目录</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101642017.png" alt="image-20230616101642017"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101649068.png" alt="image-20230616101649068"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101700222.png" alt="image-20230616101700222"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101709034.png" alt="image-20230616101709034"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101718706.png" alt="image-20230616101718706"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101736673.png" alt="image-20230616101736673"></p><h3 id="文件和目录权限">文件和目录权限</h3><h4 id="文件的权限">文件的权限</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101813559.png" alt="image-20230616101813559"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616101821956.png" alt="image-20230616101821956"></p><h4 id="目录权限">目录权限</h4><p>目录权限的理解</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103446495.png" alt="image-20230616103446495"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103511542.png" alt="image-20230616103511542"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103530831.png" alt="image-20230616103530831"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103552689.png" alt="image-20230616103552689"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103617784.png" alt="image-20230616103617784"></p><h4 id="权限相关命令">权限相关命令</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103638548.png" alt="image-20230616103638548"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103645702.png" alt="image-20230616103645702"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103654282.png" alt="image-20230616103654282"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103703613.png" alt="image-20230616103703613"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103716608.png" alt="image-20230616103716608"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103741513.png" alt="image-20230616103741513"></p><h4 id="设定文件和目录权限">设定文件和目录权限</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103824279.png" alt="image-20230616103824279"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103832011.png" alt="image-20230616103832011"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616103842153.png" alt="image-20230616103842153"></p><h4 id="SUID权限">SUID权限</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616114434374.png" alt="image-20230616114434374"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616114455954.png" alt="image-20230616114455954"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616114504283.png" alt="image-20230616114504283"></p><p>SUID使得用户可以通过文件主提供的程序，以文件主的权限访问文件。</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616114525313.png" alt="image-20230616114525313"></p><h2 id="bash及脚本程序设计">bash及脚本程序设计</h2><h3 id="shell的基本机制">shell的基本机制</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115051476.png" alt="image-20230616115051476"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115104331.png" alt="image-20230616115104331"></p><h4 id="bash的启动">bash的启动</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115136463.png" alt="image-20230616115136463"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115151885.png" alt="image-20230616115151885"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115209110.png" alt="image-20230616115209110"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115334359.png" alt="image-20230616115334359"></p><h4 id="历史与别名">历史与别名</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115352009.png" alt="image-20230616115352009"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115400250.png" alt="image-20230616115400250"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115410331.png" alt="image-20230616115410331"></p><h4 id="输入重定向">输入重定向</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115436420.png" alt="image-20230616115436420"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115521151.png" alt="image-20230616115521151"></p><h4 id="输出重定向">输出重定向</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115533295.png" alt="image-20230616115533295"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115543694.png" alt="image-20230616115543694"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115551486.png" alt="image-20230616115551486"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115600052.png" alt="image-20230616115600052"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115616437.png" alt="image-20230616115616437"></p><p><strong>举例</strong></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115634138.png" alt="image-20230616115634138"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115729248.png" alt="image-20230616115729248"></p><p>注意先后顺序</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115809077.png" alt="image-20230616115809077"></p><h4 id="管道">管道</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616115916941.png" alt="image-20230616115916941"></p><h3 id="变量">变量</h3><h4 id="变量赋值及使用">变量赋值及使用</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120300800.png" alt="image-20230616120300800"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120311234.png" alt="image-20230616120311234"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120345615.png" alt="image-20230616120345615"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120355737.png" alt="image-20230616120355737"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120405343.png" alt="image-20230616120405343"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120413323.png" alt="image-20230616120413323"></p><h4 id="在脚本中编辑文件">在脚本中编辑文件</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120431557.png" alt="image-20230616120431557"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120453425.png" alt="image-20230616120453425"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120508710.png" alt="image-20230616120508710"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120517245.png" alt="image-20230616120517245"></p><h4 id="环境变量">环境变量</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120532832.png" alt="image-20230616120532832"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120547396.png" alt="image-20230616120547396"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120554929.png" alt="image-20230616120554929"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120604010.png" alt="image-20230616120604010"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616120632643.png" alt="image-20230616120632643"></p><h3 id="替换">替换</h3><p>无正则表达式替换</p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121003053.png" alt="image-20230616121003053"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121045533.png" alt="image-20230616121045533"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121125990.png" alt="image-20230616121125990"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121134429.png" alt="image-20230616121134429"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121155302.png" alt="image-20230616121155302"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121318660.png" alt="image-20230616121318660"></p><h3 id="元字符和转义字符">元字符和转义字符</h3><h4 id="元字符">元字符</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121334696.png" alt="image-20230616121334696"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121511249.png" alt="image-20230616121511249"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121527371.png" alt="image-20230616121527371"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121618312.png" alt="image-20230616121618312"></p><h4 id="引号和转义字符">引号和转义字符</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121653451.png" alt="image-20230616121653451"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121705041.png" alt="image-20230616121705041"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121748462.png" alt="image-20230616121748462"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121909939.png" alt="image-20230616121909939"></p><h4 id="例：终止指定名字的所有进程">例：终止指定名字的所有进程</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616121922017.png" alt="image-20230616121922017"></p><h3 id="条件">条件</h3><h4 id="shell中逻辑判断">shell中逻辑判断</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122152520.png" alt="image-20230616122152520"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122222289.png" alt="image-20230616122222289"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122233406.png" alt="image-20230616122233406"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122243203.png" alt="image-20230616122243203"></p><h4 id="test命令和方括号命令">test命令和方括号命令</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122337261.png" alt="image-20230616122337261"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122346942.png" alt="image-20230616122346942"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122424730.png" alt="image-20230616122424730"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122432385.png" alt="image-20230616122432385"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122440472.png" alt="image-20230616122440472"></p><h4 id="命令组合">命令组合</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122454132.png" alt="image-20230616122454132"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122503432.png" alt="image-20230616122503432"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122520099.png" alt="image-20230616122520099"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122540636.png" alt="image-20230616122540636"></p><h4 id="条件分支">条件分支</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122553164.png" alt="image-20230616122553164"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122606462.png" alt="image-20230616122606462"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122615256.png" alt="image-20230616122615256"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122625453.png" alt="image-20230616122625453"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122634398.png" alt="image-20230616122634398"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122647796.png" alt="image-20230616122647796"></p><h3 id="循环">循环</h3><h4 id="表达式运算">表达式运算</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122700915.png" alt="image-20230616122700915"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122709336.png" alt="image-20230616122709336"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122724695.png" alt="image-20230616122724695"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122732232.png" alt="image-20230616122732232"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122742815.png" alt="image-20230616122742815"></p><h4 id="内部命令eval">内部命令eval</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122905612.png" alt="image-20230616122905612"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616122917922.png" alt="image-20230616122917922"></p><h4 id="while循环">while循环</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123014990.png" alt="image-20230616123014990"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123024648.png" alt="image-20230616123024648"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123035218.png" alt="image-20230616123035218"></p><h4 id="for循环">for循环</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123050457.png" alt="image-20230616123050457"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123058482.png" alt="image-20230616123058482"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123112777.png" alt="image-20230616123112777"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123208692.png" alt="image-20230616123208692"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123219802.png" alt="image-20230616123219802"></p><h3 id="函数">函数</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123231123.png" alt="image-20230616123231123"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123240079.png" alt="image-20230616123240079"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123257421.png" alt="image-20230616123257421"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123312772.png" alt="image-20230616123312772"></p><h2 id="进程控制">进程控制</h2><h3 id="数据">数据</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123407380.png" alt="image-20230616123407380"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123414810.png" alt="image-20230616123414810"></p><h3 id="fork">fork</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123429623.png" alt="image-20230616123429623"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123447151.png" alt="image-20230616123447151"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123455702.png" alt="image-20230616123455702"></p><h3 id="exec">exec</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123510628.png" alt="image-20230616123510628"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123519704.png" alt="image-20230616123519704"></p><h3 id="命令行参数和环境参数">命令行参数和环境参数</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123547666.png" alt="image-20230616123547666"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123555788.png" alt="image-20230616123555788"></p><h3 id="僵尸进程">僵尸进程</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123616043.png" alt="image-20230616123616043"></p><h3 id="wait">wait</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123648578.png" alt="image-20230616123648578"></p><h3 id="自编xsh0">自编xsh0</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123721648.png" alt="image-20230616123721648"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123728743.png" alt="image-20230616123728743"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123736376.png" alt="image-20230616123736376"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123751156.png" alt="image-20230616123751156"></p><h3 id="system">system</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123803398.png" alt="image-20230616123803398"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123814163.png" alt="image-20230616123814163"></p><h2 id="重定向与管道">重定向与管道</h2><h3 id="进程和文件描述符">进程和文件描述符</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123942687.png" alt="image-20230616123942687"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123951012.png" alt="image-20230616123951012"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616123958792.png" alt="image-20230616123958792"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124007419.png" alt="image-20230616124007419"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124015213.png" alt="image-20230616124015213"></p><h3 id="重定向">重定向</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124029808.png" alt="image-20230616124029808"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124102457.png" alt="image-20230616124102457"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124122540.png" alt="image-20230616124122540"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124224611.png" alt="image-20230616124224611"></p><h3 id="管道-2">管道</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124249421.png" alt="image-20230616124249421"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124256963.png" alt="image-20230616124256963"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124305716.png" alt="image-20230616124305716"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124313639.png" alt="image-20230616124313639"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124320610.png" alt="image-20230616124320610"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124327933.png" alt="image-20230616124327933"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124337430.png" alt="image-20230616124337430"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124346630.png" alt="image-20230616124346630"></p><h4 id="命名管道">命名管道</h4><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124405908.png" alt="image-20230616124405908"></p><h2 id="信号">信号</h2><h3 id="信号的产生及类型">信号的产生及类型</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124452054.png" alt="image-20230616124452054"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124459749.png" alt="image-20230616124459749"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124506434.png" alt="image-20230616124506434"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124513040.png" alt="image-20230616124513040"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124520571.png" alt="image-20230616124520571"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124529998.png" alt="image-20230616124529998"></p><h3 id="进程对信号的处理">进程对信号的处理</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124548314.png" alt="image-20230616124548314"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124556803.png" alt="image-20230616124556803"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124605260.png" alt="image-20230616124605260"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124613080.png" alt="image-20230616124613080"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124623813.png" alt="image-20230616124623813"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124631066.png" alt="image-20230616124631066"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124641951.png" alt="image-20230616124641951"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124650251.png" alt="image-20230616124650251"></p><h3 id="全局跳转">全局跳转</h3><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124712989.png" alt="image-20230616124712989"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124722339.png" alt="image-20230616124722339"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124730359.png" alt="image-20230616124730359"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124737313.png" alt="image-20230616124737313"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124745779.png" alt="image-20230616124745779"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124754407.png" alt="image-20230616124754407"></p><p><img src="/2023/06/15/linux%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/image-20230616124801738.png" alt="image-20230616124801738"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>大学</category>
      
      <category>大三下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
